//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ANTLR Version: 4.13.1
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// Generated from C:/Users/miskr/TKiK/TKiK_repozytorium/Grammars/C_Grammar.g4 by ANTLR 4.13.1

// Unreachable code detected
#pragma warning disable 0162
// The variable '...' is assigned but its value is never used
#pragma warning disable 0219
// Missing XML comment for publicly visible type or member '...'
#pragma warning disable 1591
// Ambiguous reference in cref attribute
#pragma warning disable 419

namespace CGrammar {
using System;
using System.IO;
using System.Text;
using System.Diagnostics;
using System.Collections.Generic;
using Antlr4.Runtime;
using Antlr4.Runtime.Atn;
using Antlr4.Runtime.Misc;
using Antlr4.Runtime.Tree;
using DFA = Antlr4.Runtime.Dfa.DFA;

[System.CodeDom.Compiler.GeneratedCode("ANTLR", "4.13.1")]
[System.CLSCompliant(false)]
public partial class C_GrammarParser : Parser {
	protected static DFA[] decisionToDFA;
	protected static PredictionContextCache sharedContextCache = new PredictionContextCache();
	public const int
		Hash_Include=1, Hash_Define=2, Hash_ifndef=3, Hash_endif=4, Hash_undef=5, 
		Hash_ifdef=6, Hash_if=7, Hash_elif=8, Hash_else=9, Const=10, Struct=11, 
		Typedef=12, Auto=13, Extern=14, Static=15, Register=16, Sizeof=17, Void=18, 
		Char=19, Short=20, Int=21, Long=22, Float=23, Double=24, Signed=25, Unsigned=26, 
		Bool=27, Return=28, If=29, Else=30, Switch=31, For=32, While=33, Case=34, 
		Default=35, Continue=36, Break=37, Do=38, Less=39, Greater=40, Semicolon=41, 
		Comma=42, Assign=43, QuestionMark=44, Colon=45, Multiply=46, Divide=47, 
		Plus=48, Minus=49, LeftParen=50, RightParen=51, LeftBrace=52, RightBrace=53, 
		LeftBracket=54, RightBracket=55, Ampersand=56, Mod=57, Arrow=58, Dot=59, 
		Exclamation=60, DecOp=61, IncOp=62, OrOp=63, AndOp=64, NeOp=65, EqOp=66, 
		GeOp=67, LeOp=68, AddAssign=69, SubAssign=70, MulAssign=71, DivAssign=72, 
		ModAssign=73, Identifier=74, Constant=75, DigitSequence=76, StringLiteral=77, 
		LibraryName=78, Whitespace=79, Newline=80, BlockComment=81, LineComment=82;
	public const int
		RULE_start = 0, RULE_translationUnit = 1, RULE_hashStatement = 2, RULE_conditionalStatement = 3, 
		RULE_ifStatement = 4, RULE_ifElseStatement = 5, RULE_elseIfBlock = 6, 
		RULE_elifStatement = 7, RULE_elseStatement = 8, RULE_defineStatement = 9, 
		RULE_undefStatement = 10, RULE_ifdefStatement = 11, RULE_ifndefStatement = 12, 
		RULE_includeStatement = 13, RULE_libraryName = 14, RULE_externalDeclaration = 15, 
		RULE_functionDefinition = 16, RULE_jumpStatement = 17, RULE_iterationStatement = 18, 
		RULE_selectionStatement = 19, RULE_expressionStatement = 20, RULE_statementList = 21, 
		RULE_declarationList = 22, RULE_compoundStatement = 23, RULE_blockItemList = 24, 
		RULE_blockItem = 25, RULE_labeledStatement = 26, RULE_statement = 27, 
		RULE_initializerList = 28, RULE_initializer = 29, RULE_identifierList = 30, 
		RULE_parameterDeclaration = 31, RULE_parameterList = 32, RULE_typeQualifierList = 33, 
		RULE_pointer = 34, RULE_directDeclarator = 35, RULE_declarator = 36, RULE_specifierQualifierList = 37, 
		RULE_structSpecifier = 38, RULE_structDeclarationList = 39, RULE_structDeclaration = 40, 
		RULE_structDeclaratorList = 41, RULE_structDeclarator = 42, RULE_storageClassSpecifier = 43, 
		RULE_typeSpecifier = 44, RULE_typeNameIdentifier = 45, RULE_typeName = 46, 
		RULE_declarationSpecifiers = 47, RULE_initDeclaratorList = 48, RULE_initDeclarator = 49, 
		RULE_declaration = 50, RULE_constantExpression = 51, RULE_expression = 52, 
		RULE_assignmentOperator = 53, RULE_assignmentExpression = 54, RULE_conditionalExpression = 55, 
		RULE_logicalOrExpression = 56, RULE_logicalAndExpression = 57, RULE_equalityExpression = 58, 
		RULE_relationalExpression = 59, RULE_additiveExpression = 60, RULE_multiplicativeExpression = 61, 
		RULE_castExpression = 62, RULE_unaryOperator = 63, RULE_unaryExpression = 64, 
		RULE_argumentExpressionList = 65, RULE_postfixExpression = 66, RULE_primaryExpression = 67;
	public static readonly string[] ruleNames = {
		"start", "translationUnit", "hashStatement", "conditionalStatement", "ifStatement", 
		"ifElseStatement", "elseIfBlock", "elifStatement", "elseStatement", "defineStatement", 
		"undefStatement", "ifdefStatement", "ifndefStatement", "includeStatement", 
		"libraryName", "externalDeclaration", "functionDefinition", "jumpStatement", 
		"iterationStatement", "selectionStatement", "expressionStatement", "statementList", 
		"declarationList", "compoundStatement", "blockItemList", "blockItem", 
		"labeledStatement", "statement", "initializerList", "initializer", "identifierList", 
		"parameterDeclaration", "parameterList", "typeQualifierList", "pointer", 
		"directDeclarator", "declarator", "specifierQualifierList", "structSpecifier", 
		"structDeclarationList", "structDeclaration", "structDeclaratorList", 
		"structDeclarator", "storageClassSpecifier", "typeSpecifier", "typeNameIdentifier", 
		"typeName", "declarationSpecifiers", "initDeclaratorList", "initDeclarator", 
		"declaration", "constantExpression", "expression", "assignmentOperator", 
		"assignmentExpression", "conditionalExpression", "logicalOrExpression", 
		"logicalAndExpression", "equalityExpression", "relationalExpression", 
		"additiveExpression", "multiplicativeExpression", "castExpression", "unaryOperator", 
		"unaryExpression", "argumentExpressionList", "postfixExpression", "primaryExpression"
	};

	private static readonly string[] _LiteralNames = {
		null, "'#include'", null, "'#ifndef'", "'#endif'", "'#undef'", "'#ifdef'", 
		"'#if'", "'#elif'", "'#else'", "'const'", "'struct'", "'typedef'", "'auto'", 
		"'extern'", "'static'", "'register'", "'sizeof'", "'void'", "'char'", 
		"'short'", "'int'", "'long'", "'float'", "'double'", "'signed'", "'unsigned'", 
		"'bool'", "'return'", "'if'", "'else'", "'switch'", "'for'", "'while'", 
		"'case'", "'default'", "'continue'", "'break'", "'do'", "'<'", "'>'", 
		"';'", "','", "'='", "'?'", "':'", "'*'", "'/'", "'+'", "'-'", "'('", 
		"')'", "'{'", "'}'", "'['", "']'", "'&'", "'%'", "'->'", "'.'", "'!'", 
		"'--'", "'++'", "'||'", "'&&'", "'!='", "'=='", "'>='", "'<='", "'+='", 
		"'-='", "'*='", "'/='", "'%='"
	};
	private static readonly string[] _SymbolicNames = {
		null, "Hash_Include", "Hash_Define", "Hash_ifndef", "Hash_endif", "Hash_undef", 
		"Hash_ifdef", "Hash_if", "Hash_elif", "Hash_else", "Const", "Struct", 
		"Typedef", "Auto", "Extern", "Static", "Register", "Sizeof", "Void", "Char", 
		"Short", "Int", "Long", "Float", "Double", "Signed", "Unsigned", "Bool", 
		"Return", "If", "Else", "Switch", "For", "While", "Case", "Default", "Continue", 
		"Break", "Do", "Less", "Greater", "Semicolon", "Comma", "Assign", "QuestionMark", 
		"Colon", "Multiply", "Divide", "Plus", "Minus", "LeftParen", "RightParen", 
		"LeftBrace", "RightBrace", "LeftBracket", "RightBracket", "Ampersand", 
		"Mod", "Arrow", "Dot", "Exclamation", "DecOp", "IncOp", "OrOp", "AndOp", 
		"NeOp", "EqOp", "GeOp", "LeOp", "AddAssign", "SubAssign", "MulAssign", 
		"DivAssign", "ModAssign", "Identifier", "Constant", "DigitSequence", "StringLiteral", 
		"LibraryName", "Whitespace", "Newline", "BlockComment", "LineComment"
	};
	public static readonly IVocabulary DefaultVocabulary = new Vocabulary(_LiteralNames, _SymbolicNames);

	[NotNull]
	public override IVocabulary Vocabulary
	{
		get
		{
			return DefaultVocabulary;
		}
	}

	public override string GrammarFileName { get { return "C_Grammar.g4"; } }

	public override string[] RuleNames { get { return ruleNames; } }

	public override int[] SerializedAtn { get { return _serializedATN; } }

	static C_GrammarParser() {
		decisionToDFA = new DFA[_ATN.NumberOfDecisions];
		for (int i = 0; i < _ATN.NumberOfDecisions; i++) {
			decisionToDFA[i] = new DFA(_ATN.GetDecisionState(i), i);
		}
	}

		public C_GrammarParser(ITokenStream input) : this(input, Console.Out, Console.Error) { }

		public C_GrammarParser(ITokenStream input, TextWriter output, TextWriter errorOutput)
		: base(input, output, errorOutput)
	{
		Interpreter = new ParserATNSimulator(this, _ATN, decisionToDFA, sharedContextCache);
	}

	public partial class StartContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Eof() { return GetToken(C_GrammarParser.Eof, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public TranslationUnitContext translationUnit() {
			return GetRuleContext<TranslationUnitContext>(0);
		}
		public StartContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_start; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.EnterStart(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.ExitStart(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IC_GrammarVisitor<TResult> typedVisitor = visitor as IC_GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitStart(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public StartContext start() {
		StartContext _localctx = new StartContext(Context, State);
		EnterRule(_localctx, 0, RULE_start);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 137;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if ((((_la) & ~0x3f) == 0 && ((1L << _la) & 1196268919323886L) != 0) || _la==Identifier) {
				{
				State = 136;
				translationUnit(0);
				}
			}

			State = 139;
			Match(Eof);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TranslationUnitContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public HashStatementContext hashStatement() {
			return GetRuleContext<HashStatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ExternalDeclarationContext externalDeclaration() {
			return GetRuleContext<ExternalDeclarationContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public TranslationUnitContext translationUnit() {
			return GetRuleContext<TranslationUnitContext>(0);
		}
		public TranslationUnitContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_translationUnit; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.EnterTranslationUnit(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.ExitTranslationUnit(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IC_GrammarVisitor<TResult> typedVisitor = visitor as IC_GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTranslationUnit(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public TranslationUnitContext translationUnit() {
		return translationUnit(0);
	}

	private TranslationUnitContext translationUnit(int _p) {
		ParserRuleContext _parentctx = Context;
		int _parentState = State;
		TranslationUnitContext _localctx = new TranslationUnitContext(Context, _parentState);
		TranslationUnitContext _prevctx = _localctx;
		int _startState = 2;
		EnterRecursionRule(_localctx, 2, RULE_translationUnit, _p);
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 144;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case Hash_Include:
			case Hash_Define:
			case Hash_ifndef:
			case Hash_undef:
			case Hash_ifdef:
			case Hash_if:
				{
				State = 142;
				hashStatement();
				}
				break;
			case Const:
			case Struct:
			case Typedef:
			case Auto:
			case Extern:
			case Static:
			case Register:
			case Void:
			case Char:
			case Short:
			case Int:
			case Long:
			case Float:
			case Double:
			case Signed:
			case Unsigned:
			case Bool:
			case Multiply:
			case LeftParen:
			case Identifier:
				{
				State = 143;
				externalDeclaration();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			Context.Stop = TokenStream.LT(-1);
			State = 152;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,3,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					if ( ParseListeners!=null )
						TriggerExitRuleEvent();
					_prevctx = _localctx;
					{
					State = 150;
					ErrorHandler.Sync(this);
					switch ( Interpreter.AdaptivePredict(TokenStream,2,Context) ) {
					case 1:
						{
						_localctx = new TranslationUnitContext(_parentctx, _parentState);
						PushNewRecursionContext(_localctx, _startState, RULE_translationUnit);
						State = 146;
						if (!(Precpred(Context, 2))) throw new FailedPredicateException(this, "Precpred(Context, 2)");
						State = 147;
						hashStatement();
						}
						break;
					case 2:
						{
						_localctx = new TranslationUnitContext(_parentctx, _parentState);
						PushNewRecursionContext(_localctx, _startState, RULE_translationUnit);
						State = 148;
						if (!(Precpred(Context, 1))) throw new FailedPredicateException(this, "Precpred(Context, 1)");
						State = 149;
						externalDeclaration();
						}
						break;
					}
					} 
				}
				State = 154;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,3,Context);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			UnrollRecursionContexts(_parentctx);
		}
		return _localctx;
	}

	public partial class HashStatementContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public IncludeStatementContext includeStatement() {
			return GetRuleContext<IncludeStatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public DefineStatementContext defineStatement() {
			return GetRuleContext<DefineStatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public UndefStatementContext undefStatement() {
			return GetRuleContext<UndefStatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ConditionalStatementContext conditionalStatement() {
			return GetRuleContext<ConditionalStatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public IfdefStatementContext ifdefStatement() {
			return GetRuleContext<IfdefStatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public IfndefStatementContext ifndefStatement() {
			return GetRuleContext<IfndefStatementContext>(0);
		}
		public HashStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_hashStatement; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.EnterHashStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.ExitHashStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IC_GrammarVisitor<TResult> typedVisitor = visitor as IC_GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitHashStatement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public HashStatementContext hashStatement() {
		HashStatementContext _localctx = new HashStatementContext(Context, State);
		EnterRule(_localctx, 4, RULE_hashStatement);
		try {
			State = 161;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case Hash_Include:
				EnterOuterAlt(_localctx, 1);
				{
				State = 155;
				includeStatement();
				}
				break;
			case Hash_Define:
				EnterOuterAlt(_localctx, 2);
				{
				State = 156;
				defineStatement();
				}
				break;
			case Hash_undef:
				EnterOuterAlt(_localctx, 3);
				{
				State = 157;
				undefStatement();
				}
				break;
			case Hash_if:
				EnterOuterAlt(_localctx, 4);
				{
				State = 158;
				conditionalStatement();
				}
				break;
			case Hash_ifdef:
				EnterOuterAlt(_localctx, 5);
				{
				State = 159;
				ifdefStatement();
				}
				break;
			case Hash_ifndef:
				EnterOuterAlt(_localctx, 6);
				{
				State = 160;
				ifndefStatement();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ConditionalStatementContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public IfStatementContext ifStatement() {
			return GetRuleContext<IfStatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Hash_endif() { return GetToken(C_GrammarParser.Hash_endif, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public IfElseStatementContext ifElseStatement() {
			return GetRuleContext<IfElseStatementContext>(0);
		}
		public ConditionalStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_conditionalStatement; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.EnterConditionalStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.ExitConditionalStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IC_GrammarVisitor<TResult> typedVisitor = visitor as IC_GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitConditionalStatement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ConditionalStatementContext conditionalStatement() {
		ConditionalStatementContext _localctx = new ConditionalStatementContext(Context, State);
		EnterRule(_localctx, 6, RULE_conditionalStatement);
		try {
			State = 169;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,5,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 163;
				ifStatement();
				State = 164;
				Match(Hash_endif);
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 166;
				ifElseStatement();
				State = 167;
				Match(Hash_endif);
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class IfStatementContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Hash_if() { return GetToken(C_GrammarParser.Hash_if, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public StatementListContext statementList() {
			return GetRuleContext<StatementListContext>(0);
		}
		public IfStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_ifStatement; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.EnterIfStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.ExitIfStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IC_GrammarVisitor<TResult> typedVisitor = visitor as IC_GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitIfStatement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public IfStatementContext ifStatement() {
		IfStatementContext _localctx = new IfStatementContext(Context, State);
		EnterRule(_localctx, 8, RULE_ifStatement);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 171;
			Match(Hash_if);
			State = 172;
			expression(0);
			State = 173;
			statementList(0);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class IfElseStatementContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public IfStatementContext ifStatement() {
			return GetRuleContext<IfStatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ElseIfBlockContext elseIfBlock() {
			return GetRuleContext<ElseIfBlockContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ElseStatementContext elseStatement() {
			return GetRuleContext<ElseStatementContext>(0);
		}
		public IfElseStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_ifElseStatement; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.EnterIfElseStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.ExitIfElseStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IC_GrammarVisitor<TResult> typedVisitor = visitor as IC_GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitIfElseStatement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public IfElseStatementContext ifElseStatement() {
		IfElseStatementContext _localctx = new IfElseStatementContext(Context, State);
		EnterRule(_localctx, 10, RULE_ifElseStatement);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 175;
			ifStatement();
			State = 177;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==Hash_elif) {
				{
				State = 176;
				elseIfBlock(0);
				}
			}

			State = 180;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==Hash_else) {
				{
				State = 179;
				elseStatement();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ElseIfBlockContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ElifStatementContext elifStatement() {
			return GetRuleContext<ElifStatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ElseIfBlockContext elseIfBlock() {
			return GetRuleContext<ElseIfBlockContext>(0);
		}
		public ElseIfBlockContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_elseIfBlock; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.EnterElseIfBlock(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.ExitElseIfBlock(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IC_GrammarVisitor<TResult> typedVisitor = visitor as IC_GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitElseIfBlock(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ElseIfBlockContext elseIfBlock() {
		return elseIfBlock(0);
	}

	private ElseIfBlockContext elseIfBlock(int _p) {
		ParserRuleContext _parentctx = Context;
		int _parentState = State;
		ElseIfBlockContext _localctx = new ElseIfBlockContext(Context, _parentState);
		ElseIfBlockContext _prevctx = _localctx;
		int _startState = 12;
		EnterRecursionRule(_localctx, 12, RULE_elseIfBlock, _p);
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			{
			State = 183;
			elifStatement();
			}
			Context.Stop = TokenStream.LT(-1);
			State = 189;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,8,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					if ( ParseListeners!=null )
						TriggerExitRuleEvent();
					_prevctx = _localctx;
					{
					{
					_localctx = new ElseIfBlockContext(_parentctx, _parentState);
					PushNewRecursionContext(_localctx, _startState, RULE_elseIfBlock);
					State = 185;
					if (!(Precpred(Context, 1))) throw new FailedPredicateException(this, "Precpred(Context, 1)");
					State = 186;
					elifStatement();
					}
					} 
				}
				State = 191;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,8,Context);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			UnrollRecursionContexts(_parentctx);
		}
		return _localctx;
	}

	public partial class ElifStatementContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Hash_elif() { return GetToken(C_GrammarParser.Hash_elif, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public StatementListContext statementList() {
			return GetRuleContext<StatementListContext>(0);
		}
		public ElifStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_elifStatement; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.EnterElifStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.ExitElifStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IC_GrammarVisitor<TResult> typedVisitor = visitor as IC_GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitElifStatement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ElifStatementContext elifStatement() {
		ElifStatementContext _localctx = new ElifStatementContext(Context, State);
		EnterRule(_localctx, 14, RULE_elifStatement);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 192;
			Match(Hash_elif);
			State = 193;
			expression(0);
			State = 194;
			statementList(0);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ElseStatementContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Hash_else() { return GetToken(C_GrammarParser.Hash_else, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public StatementListContext statementList() {
			return GetRuleContext<StatementListContext>(0);
		}
		public ElseStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_elseStatement; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.EnterElseStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.ExitElseStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IC_GrammarVisitor<TResult> typedVisitor = visitor as IC_GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitElseStatement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ElseStatementContext elseStatement() {
		ElseStatementContext _localctx = new ElseStatementContext(Context, State);
		EnterRule(_localctx, 16, RULE_elseStatement);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 196;
			Match(Hash_else);
			State = 197;
			statementList(0);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class DefineStatementContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Hash_Define() { return GetToken(C_GrammarParser.Hash_Define, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Identifier() { return GetToken(C_GrammarParser.Identifier, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Constant() { return GetToken(C_GrammarParser.Constant, 0); }
		public DefineStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_defineStatement; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.EnterDefineStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.ExitDefineStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IC_GrammarVisitor<TResult> typedVisitor = visitor as IC_GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitDefineStatement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public DefineStatementContext defineStatement() {
		DefineStatementContext _localctx = new DefineStatementContext(Context, State);
		EnterRule(_localctx, 18, RULE_defineStatement);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 199;
			Match(Hash_Define);
			State = 200;
			Match(Identifier);
			State = 201;
			Match(Constant);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class UndefStatementContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Hash_undef() { return GetToken(C_GrammarParser.Hash_undef, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Identifier() { return GetToken(C_GrammarParser.Identifier, 0); }
		public UndefStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_undefStatement; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.EnterUndefStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.ExitUndefStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IC_GrammarVisitor<TResult> typedVisitor = visitor as IC_GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitUndefStatement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public UndefStatementContext undefStatement() {
		UndefStatementContext _localctx = new UndefStatementContext(Context, State);
		EnterRule(_localctx, 20, RULE_undefStatement);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 203;
			Match(Hash_undef);
			State = 204;
			Match(Identifier);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class IfdefStatementContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Hash_ifdef() { return GetToken(C_GrammarParser.Hash_ifdef, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Identifier() { return GetToken(C_GrammarParser.Identifier, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public StatementListContext statementList() {
			return GetRuleContext<StatementListContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Hash_endif() { return GetToken(C_GrammarParser.Hash_endif, 0); }
		public IfdefStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_ifdefStatement; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.EnterIfdefStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.ExitIfdefStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IC_GrammarVisitor<TResult> typedVisitor = visitor as IC_GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitIfdefStatement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public IfdefStatementContext ifdefStatement() {
		IfdefStatementContext _localctx = new IfdefStatementContext(Context, State);
		EnterRule(_localctx, 22, RULE_ifdefStatement);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 206;
			Match(Hash_ifdef);
			State = 207;
			Match(Identifier);
			State = 208;
			statementList(0);
			State = 209;
			Match(Hash_endif);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class IfndefStatementContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Hash_ifndef() { return GetToken(C_GrammarParser.Hash_ifndef, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Identifier() { return GetToken(C_GrammarParser.Identifier, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public StatementListContext statementList() {
			return GetRuleContext<StatementListContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Hash_endif() { return GetToken(C_GrammarParser.Hash_endif, 0); }
		public IfndefStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_ifndefStatement; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.EnterIfndefStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.ExitIfndefStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IC_GrammarVisitor<TResult> typedVisitor = visitor as IC_GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitIfndefStatement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public IfndefStatementContext ifndefStatement() {
		IfndefStatementContext _localctx = new IfndefStatementContext(Context, State);
		EnterRule(_localctx, 24, RULE_ifndefStatement);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 211;
			Match(Hash_ifndef);
			State = 212;
			Match(Identifier);
			State = 213;
			statementList(0);
			State = 214;
			Match(Hash_endif);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class IncludeStatementContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Hash_Include() { return GetToken(C_GrammarParser.Hash_Include, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Less() { return GetToken(C_GrammarParser.Less, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public LibraryNameContext libraryName() {
			return GetRuleContext<LibraryNameContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Greater() { return GetToken(C_GrammarParser.Greater, 0); }
		public IncludeStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_includeStatement; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.EnterIncludeStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.ExitIncludeStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IC_GrammarVisitor<TResult> typedVisitor = visitor as IC_GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitIncludeStatement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public IncludeStatementContext includeStatement() {
		IncludeStatementContext _localctx = new IncludeStatementContext(Context, State);
		EnterRule(_localctx, 26, RULE_includeStatement);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 216;
			Match(Hash_Include);
			State = 217;
			Match(Less);
			State = 218;
			libraryName();
			State = 219;
			Match(Greater);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class LibraryNameContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LibraryName() { return GetToken(C_GrammarParser.LibraryName, 0); }
		public LibraryNameContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_libraryName; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.EnterLibraryName(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.ExitLibraryName(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IC_GrammarVisitor<TResult> typedVisitor = visitor as IC_GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitLibraryName(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public LibraryNameContext libraryName() {
		LibraryNameContext _localctx = new LibraryNameContext(Context, State);
		EnterRule(_localctx, 28, RULE_libraryName);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 221;
			Match(LibraryName);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ExternalDeclarationContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public FunctionDefinitionContext functionDefinition() {
			return GetRuleContext<FunctionDefinitionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public DeclarationContext declaration() {
			return GetRuleContext<DeclarationContext>(0);
		}
		public ExternalDeclarationContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_externalDeclaration; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.EnterExternalDeclaration(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.ExitExternalDeclaration(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IC_GrammarVisitor<TResult> typedVisitor = visitor as IC_GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitExternalDeclaration(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ExternalDeclarationContext externalDeclaration() {
		ExternalDeclarationContext _localctx = new ExternalDeclarationContext(Context, State);
		EnterRule(_localctx, 30, RULE_externalDeclaration);
		try {
			State = 225;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,9,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 223;
				functionDefinition();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 224;
				declaration();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class FunctionDefinitionContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public DeclarationSpecifiersContext declarationSpecifiers() {
			return GetRuleContext<DeclarationSpecifiersContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public DeclaratorContext declarator() {
			return GetRuleContext<DeclaratorContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public DeclarationListContext declarationList() {
			return GetRuleContext<DeclarationListContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public CompoundStatementContext compoundStatement() {
			return GetRuleContext<CompoundStatementContext>(0);
		}
		public FunctionDefinitionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_functionDefinition; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.EnterFunctionDefinition(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.ExitFunctionDefinition(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IC_GrammarVisitor<TResult> typedVisitor = visitor as IC_GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitFunctionDefinition(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public FunctionDefinitionContext functionDefinition() {
		FunctionDefinitionContext _localctx = new FunctionDefinitionContext(Context, State);
		EnterRule(_localctx, 32, RULE_functionDefinition);
		try {
			State = 243;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,10,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 227;
				declarationSpecifiers();
				State = 228;
				declarator();
				State = 229;
				declarationList(0);
				State = 230;
				compoundStatement();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 232;
				declarationSpecifiers();
				State = 233;
				declarator();
				State = 234;
				compoundStatement();
				}
				break;
			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 236;
				declarator();
				State = 237;
				declarationList(0);
				State = 238;
				compoundStatement();
				}
				break;
			case 4:
				EnterOuterAlt(_localctx, 4);
				{
				State = 240;
				declarator();
				State = 241;
				compoundStatement();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class JumpStatementContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Continue() { return GetToken(C_GrammarParser.Continue, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Semicolon() { return GetToken(C_GrammarParser.Semicolon, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Break() { return GetToken(C_GrammarParser.Break, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Return() { return GetToken(C_GrammarParser.Return, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public JumpStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_jumpStatement; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.EnterJumpStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.ExitJumpStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IC_GrammarVisitor<TResult> typedVisitor = visitor as IC_GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitJumpStatement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public JumpStatementContext jumpStatement() {
		JumpStatementContext _localctx = new JumpStatementContext(Context, State);
		EnterRule(_localctx, 34, RULE_jumpStatement);
		try {
			State = 255;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,11,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 245;
				Match(Continue);
				State = 246;
				Match(Semicolon);
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 247;
				Match(Break);
				State = 248;
				Match(Semicolon);
				}
				break;
			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 249;
				Match(Return);
				State = 250;
				Match(Semicolon);
				}
				break;
			case 4:
				EnterOuterAlt(_localctx, 4);
				{
				State = 251;
				Match(Return);
				State = 252;
				expression(0);
				State = 253;
				Match(Semicolon);
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class IterationStatementContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode While() { return GetToken(C_GrammarParser.While, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LeftParen() { return GetToken(C_GrammarParser.LeftParen, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RightParen() { return GetToken(C_GrammarParser.RightParen, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public StatementContext statement() {
			return GetRuleContext<StatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Do() { return GetToken(C_GrammarParser.Do, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Semicolon() { return GetToken(C_GrammarParser.Semicolon, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode For() { return GetToken(C_GrammarParser.For, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionStatementContext[] expressionStatement() {
			return GetRuleContexts<ExpressionStatementContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionStatementContext expressionStatement(int i) {
			return GetRuleContext<ExpressionStatementContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public DeclarationContext declaration() {
			return GetRuleContext<DeclarationContext>(0);
		}
		public IterationStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_iterationStatement; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.EnterIterationStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.ExitIterationStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IC_GrammarVisitor<TResult> typedVisitor = visitor as IC_GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitIterationStatement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public IterationStatementContext iterationStatement() {
		IterationStatementContext _localctx = new IterationStatementContext(Context, State);
		EnterRule(_localctx, 36, RULE_iterationStatement);
		try {
			State = 292;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,14,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 257;
				Match(While);
				State = 258;
				Match(LeftParen);
				State = 259;
				expression(0);
				State = 260;
				Match(RightParen);
				State = 261;
				statement();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 263;
				Match(Do);
				State = 264;
				statement();
				State = 265;
				Match(While);
				State = 266;
				Match(LeftParen);
				State = 267;
				expression(0);
				State = 268;
				Match(RightParen);
				State = 269;
				Match(Semicolon);
				}
				break;
			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 271;
				Match(For);
				State = 272;
				Match(LeftParen);
				State = 275;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,12,Context) ) {
				case 1:
					{
					State = 273;
					expressionStatement();
					}
					break;
				case 2:
					{
					State = 274;
					declaration();
					}
					break;
				}
				State = 277;
				expressionStatement();
				State = 278;
				Match(RightParen);
				State = 279;
				statement();
				}
				break;
			case 4:
				EnterOuterAlt(_localctx, 4);
				{
				State = 281;
				Match(For);
				State = 282;
				Match(LeftParen);
				State = 285;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,13,Context) ) {
				case 1:
					{
					State = 283;
					expressionStatement();
					}
					break;
				case 2:
					{
					State = 284;
					declaration();
					}
					break;
				}
				State = 287;
				expressionStatement();
				State = 288;
				expression(0);
				State = 289;
				Match(RightParen);
				State = 290;
				statement();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SelectionStatementContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode If() { return GetToken(C_GrammarParser.If, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LeftParen() { return GetToken(C_GrammarParser.LeftParen, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RightParen() { return GetToken(C_GrammarParser.RightParen, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public StatementContext[] statement() {
			return GetRuleContexts<StatementContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public StatementContext statement(int i) {
			return GetRuleContext<StatementContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Else() { return GetToken(C_GrammarParser.Else, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Switch() { return GetToken(C_GrammarParser.Switch, 0); }
		public SelectionStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_selectionStatement; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.EnterSelectionStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.ExitSelectionStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IC_GrammarVisitor<TResult> typedVisitor = visitor as IC_GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSelectionStatement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public SelectionStatementContext selectionStatement() {
		SelectionStatementContext _localctx = new SelectionStatementContext(Context, State);
		EnterRule(_localctx, 38, RULE_selectionStatement);
		try {
			State = 314;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,15,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 294;
				Match(If);
				State = 295;
				Match(LeftParen);
				State = 296;
				expression(0);
				State = 297;
				Match(RightParen);
				State = 298;
				statement();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 300;
				Match(If);
				State = 301;
				Match(LeftParen);
				State = 302;
				expression(0);
				State = 303;
				Match(RightParen);
				State = 304;
				statement();
				State = 305;
				Match(Else);
				State = 306;
				statement();
				}
				break;
			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 308;
				Match(Switch);
				State = 309;
				Match(LeftParen);
				State = 310;
				expression(0);
				State = 311;
				Match(RightParen);
				State = 312;
				statement();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ExpressionStatementContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Semicolon() { return GetToken(C_GrammarParser.Semicolon, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public ExpressionStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_expressionStatement; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.EnterExpressionStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.ExitExpressionStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IC_GrammarVisitor<TResult> typedVisitor = visitor as IC_GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitExpressionStatement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ExpressionStatementContext expressionStatement() {
		ExpressionStatementContext _localctx = new ExpressionStatementContext(Context, State);
		EnterRule(_localctx, 40, RULE_expressionStatement);
		try {
			State = 320;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case Semicolon:
				EnterOuterAlt(_localctx, 1);
				{
				State = 316;
				Match(Semicolon);
				}
				break;
			case Sizeof:
			case Multiply:
			case Plus:
			case Minus:
			case LeftParen:
			case Ampersand:
			case Exclamation:
			case DecOp:
			case IncOp:
			case Identifier:
			case Constant:
			case StringLiteral:
				EnterOuterAlt(_localctx, 2);
				{
				State = 317;
				expression(0);
				State = 318;
				Match(Semicolon);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class StatementListContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public StatementContext statement() {
			return GetRuleContext<StatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public StatementListContext statementList() {
			return GetRuleContext<StatementListContext>(0);
		}
		public StatementListContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_statementList; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.EnterStatementList(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.ExitStatementList(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IC_GrammarVisitor<TResult> typedVisitor = visitor as IC_GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitStatementList(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public StatementListContext statementList() {
		return statementList(0);
	}

	private StatementListContext statementList(int _p) {
		ParserRuleContext _parentctx = Context;
		int _parentState = State;
		StatementListContext _localctx = new StatementListContext(Context, _parentState);
		StatementListContext _prevctx = _localctx;
		int _startState = 42;
		EnterRecursionRule(_localctx, 42, RULE_statementList, _p);
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			{
			State = 323;
			statement();
			}
			Context.Stop = TokenStream.LT(-1);
			State = 329;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,17,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					if ( ParseListeners!=null )
						TriggerExitRuleEvent();
					_prevctx = _localctx;
					{
					{
					_localctx = new StatementListContext(_parentctx, _parentState);
					PushNewRecursionContext(_localctx, _startState, RULE_statementList);
					State = 325;
					if (!(Precpred(Context, 1))) throw new FailedPredicateException(this, "Precpred(Context, 1)");
					State = 326;
					statement();
					}
					} 
				}
				State = 331;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,17,Context);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			UnrollRecursionContexts(_parentctx);
		}
		return _localctx;
	}

	public partial class DeclarationListContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public DeclarationContext declaration() {
			return GetRuleContext<DeclarationContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public DeclarationListContext declarationList() {
			return GetRuleContext<DeclarationListContext>(0);
		}
		public DeclarationListContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_declarationList; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.EnterDeclarationList(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.ExitDeclarationList(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IC_GrammarVisitor<TResult> typedVisitor = visitor as IC_GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitDeclarationList(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public DeclarationListContext declarationList() {
		return declarationList(0);
	}

	private DeclarationListContext declarationList(int _p) {
		ParserRuleContext _parentctx = Context;
		int _parentState = State;
		DeclarationListContext _localctx = new DeclarationListContext(Context, _parentState);
		DeclarationListContext _prevctx = _localctx;
		int _startState = 44;
		EnterRecursionRule(_localctx, 44, RULE_declarationList, _p);
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			{
			State = 333;
			declaration();
			}
			Context.Stop = TokenStream.LT(-1);
			State = 339;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,18,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					if ( ParseListeners!=null )
						TriggerExitRuleEvent();
					_prevctx = _localctx;
					{
					{
					_localctx = new DeclarationListContext(_parentctx, _parentState);
					PushNewRecursionContext(_localctx, _startState, RULE_declarationList);
					State = 335;
					if (!(Precpred(Context, 1))) throw new FailedPredicateException(this, "Precpred(Context, 1)");
					State = 336;
					declaration();
					}
					} 
				}
				State = 341;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,18,Context);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			UnrollRecursionContexts(_parentctx);
		}
		return _localctx;
	}

	public partial class CompoundStatementContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LeftBrace() { return GetToken(C_GrammarParser.LeftBrace, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RightBrace() { return GetToken(C_GrammarParser.RightBrace, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public BlockItemListContext blockItemList() {
			return GetRuleContext<BlockItemListContext>(0);
		}
		public CompoundStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_compoundStatement; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.EnterCompoundStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.ExitCompoundStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IC_GrammarVisitor<TResult> typedVisitor = visitor as IC_GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCompoundStatement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public CompoundStatementContext compoundStatement() {
		CompoundStatementContext _localctx = new CompoundStatementContext(Context, State);
		EnterRule(_localctx, 46, RULE_compoundStatement);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 342;
			Match(LeftBrace);
			State = 344;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if ((((_la) & ~0x3f) == 0 && ((1L << _la) & 8149055167199706112L) != 0) || ((((_la - 74)) & ~0x3f) == 0 && ((1L << (_la - 74)) & 11L) != 0)) {
				{
				State = 343;
				blockItemList(0);
				}
			}

			State = 346;
			Match(RightBrace);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class BlockItemListContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public BlockItemContext blockItem() {
			return GetRuleContext<BlockItemContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public BlockItemListContext blockItemList() {
			return GetRuleContext<BlockItemListContext>(0);
		}
		public BlockItemListContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_blockItemList; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.EnterBlockItemList(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.ExitBlockItemList(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IC_GrammarVisitor<TResult> typedVisitor = visitor as IC_GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitBlockItemList(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public BlockItemListContext blockItemList() {
		return blockItemList(0);
	}

	private BlockItemListContext blockItemList(int _p) {
		ParserRuleContext _parentctx = Context;
		int _parentState = State;
		BlockItemListContext _localctx = new BlockItemListContext(Context, _parentState);
		BlockItemListContext _prevctx = _localctx;
		int _startState = 48;
		EnterRecursionRule(_localctx, 48, RULE_blockItemList, _p);
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			{
			State = 349;
			blockItem();
			}
			Context.Stop = TokenStream.LT(-1);
			State = 355;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,20,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					if ( ParseListeners!=null )
						TriggerExitRuleEvent();
					_prevctx = _localctx;
					{
					{
					_localctx = new BlockItemListContext(_parentctx, _parentState);
					PushNewRecursionContext(_localctx, _startState, RULE_blockItemList);
					State = 351;
					if (!(Precpred(Context, 1))) throw new FailedPredicateException(this, "Precpred(Context, 1)");
					State = 352;
					blockItem();
					}
					} 
				}
				State = 357;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,20,Context);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			UnrollRecursionContexts(_parentctx);
		}
		return _localctx;
	}

	public partial class BlockItemContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public StatementListContext statementList() {
			return GetRuleContext<StatementListContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public DeclarationListContext declarationList() {
			return GetRuleContext<DeclarationListContext>(0);
		}
		public BlockItemContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_blockItem; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.EnterBlockItem(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.ExitBlockItem(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IC_GrammarVisitor<TResult> typedVisitor = visitor as IC_GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitBlockItem(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public BlockItemContext blockItem() {
		BlockItemContext _localctx = new BlockItemContext(Context, State);
		EnterRule(_localctx, 50, RULE_blockItem);
		try {
			State = 360;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,21,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 358;
				statementList(0);
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 359;
				declarationList(0);
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class LabeledStatementContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Identifier() { return GetToken(C_GrammarParser.Identifier, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Colon() { return GetToken(C_GrammarParser.Colon, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public StatementContext statement() {
			return GetRuleContext<StatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Case() { return GetToken(C_GrammarParser.Case, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ConstantExpressionContext constantExpression() {
			return GetRuleContext<ConstantExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Default() { return GetToken(C_GrammarParser.Default, 0); }
		public LabeledStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_labeledStatement; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.EnterLabeledStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.ExitLabeledStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IC_GrammarVisitor<TResult> typedVisitor = visitor as IC_GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitLabeledStatement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public LabeledStatementContext labeledStatement() {
		LabeledStatementContext _localctx = new LabeledStatementContext(Context, State);
		EnterRule(_localctx, 52, RULE_labeledStatement);
		try {
			State = 373;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case Identifier:
				EnterOuterAlt(_localctx, 1);
				{
				State = 362;
				Match(Identifier);
				State = 363;
				Match(Colon);
				State = 364;
				statement();
				}
				break;
			case Case:
				EnterOuterAlt(_localctx, 2);
				{
				State = 365;
				Match(Case);
				State = 366;
				constantExpression();
				State = 367;
				Match(Colon);
				State = 368;
				statement();
				}
				break;
			case Default:
				EnterOuterAlt(_localctx, 3);
				{
				State = 370;
				Match(Default);
				State = 371;
				Match(Colon);
				State = 372;
				statement();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class StatementContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public LabeledStatementContext labeledStatement() {
			return GetRuleContext<LabeledStatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public CompoundStatementContext compoundStatement() {
			return GetRuleContext<CompoundStatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionStatementContext expressionStatement() {
			return GetRuleContext<ExpressionStatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public SelectionStatementContext selectionStatement() {
			return GetRuleContext<SelectionStatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public IterationStatementContext iterationStatement() {
			return GetRuleContext<IterationStatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public JumpStatementContext jumpStatement() {
			return GetRuleContext<JumpStatementContext>(0);
		}
		public StatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_statement; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.EnterStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.ExitStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IC_GrammarVisitor<TResult> typedVisitor = visitor as IC_GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitStatement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public StatementContext statement() {
		StatementContext _localctx = new StatementContext(Context, State);
		EnterRule(_localctx, 54, RULE_statement);
		try {
			State = 381;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,23,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 375;
				labeledStatement();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 376;
				compoundStatement();
				}
				break;
			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 377;
				expressionStatement();
				}
				break;
			case 4:
				EnterOuterAlt(_localctx, 4);
				{
				State = 378;
				selectionStatement();
				}
				break;
			case 5:
				EnterOuterAlt(_localctx, 5);
				{
				State = 379;
				iterationStatement();
				}
				break;
			case 6:
				EnterOuterAlt(_localctx, 6);
				{
				State = 380;
				jumpStatement();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class InitializerListContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public InitializerContext initializer() {
			return GetRuleContext<InitializerContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public InitializerListContext initializerList() {
			return GetRuleContext<InitializerListContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Comma() { return GetToken(C_GrammarParser.Comma, 0); }
		public InitializerListContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_initializerList; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.EnterInitializerList(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.ExitInitializerList(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IC_GrammarVisitor<TResult> typedVisitor = visitor as IC_GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitInitializerList(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public InitializerListContext initializerList() {
		return initializerList(0);
	}

	private InitializerListContext initializerList(int _p) {
		ParserRuleContext _parentctx = Context;
		int _parentState = State;
		InitializerListContext _localctx = new InitializerListContext(Context, _parentState);
		InitializerListContext _prevctx = _localctx;
		int _startState = 56;
		EnterRecursionRule(_localctx, 56, RULE_initializerList, _p);
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			{
			State = 384;
			initializer();
			}
			Context.Stop = TokenStream.LT(-1);
			State = 391;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,24,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					if ( ParseListeners!=null )
						TriggerExitRuleEvent();
					_prevctx = _localctx;
					{
					{
					_localctx = new InitializerListContext(_parentctx, _parentState);
					PushNewRecursionContext(_localctx, _startState, RULE_initializerList);
					State = 386;
					if (!(Precpred(Context, 1))) throw new FailedPredicateException(this, "Precpred(Context, 1)");
					State = 387;
					Match(Comma);
					State = 388;
					initializer();
					}
					} 
				}
				State = 393;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,24,Context);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			UnrollRecursionContexts(_parentctx);
		}
		return _localctx;
	}

	public partial class InitializerContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public AssignmentExpressionContext assignmentExpression() {
			return GetRuleContext<AssignmentExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LeftBrace() { return GetToken(C_GrammarParser.LeftBrace, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public InitializerListContext initializerList() {
			return GetRuleContext<InitializerListContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RightBrace() { return GetToken(C_GrammarParser.RightBrace, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Comma() { return GetToken(C_GrammarParser.Comma, 0); }
		public InitializerContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_initializer; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.EnterInitializer(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.ExitInitializer(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IC_GrammarVisitor<TResult> typedVisitor = visitor as IC_GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitInitializer(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public InitializerContext initializer() {
		InitializerContext _localctx = new InitializerContext(Context, State);
		EnterRule(_localctx, 58, RULE_initializer);
		try {
			State = 404;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,25,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 394;
				assignmentExpression();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 395;
				Match(LeftBrace);
				State = 396;
				initializerList(0);
				State = 397;
				Match(RightBrace);
				}
				break;
			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 399;
				Match(LeftBrace);
				State = 400;
				initializerList(0);
				State = 401;
				Match(Comma);
				State = 402;
				Match(RightBrace);
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class IdentifierListContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Identifier() { return GetToken(C_GrammarParser.Identifier, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public IdentifierListContext identifierList() {
			return GetRuleContext<IdentifierListContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Comma() { return GetToken(C_GrammarParser.Comma, 0); }
		public IdentifierListContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_identifierList; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.EnterIdentifierList(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.ExitIdentifierList(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IC_GrammarVisitor<TResult> typedVisitor = visitor as IC_GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitIdentifierList(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public IdentifierListContext identifierList() {
		return identifierList(0);
	}

	private IdentifierListContext identifierList(int _p) {
		ParserRuleContext _parentctx = Context;
		int _parentState = State;
		IdentifierListContext _localctx = new IdentifierListContext(Context, _parentState);
		IdentifierListContext _prevctx = _localctx;
		int _startState = 60;
		EnterRecursionRule(_localctx, 60, RULE_identifierList, _p);
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			{
			State = 407;
			Match(Identifier);
			}
			Context.Stop = TokenStream.LT(-1);
			State = 414;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,26,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					if ( ParseListeners!=null )
						TriggerExitRuleEvent();
					_prevctx = _localctx;
					{
					{
					_localctx = new IdentifierListContext(_parentctx, _parentState);
					PushNewRecursionContext(_localctx, _startState, RULE_identifierList);
					State = 409;
					if (!(Precpred(Context, 1))) throw new FailedPredicateException(this, "Precpred(Context, 1)");
					State = 410;
					Match(Comma);
					State = 411;
					Match(Identifier);
					}
					} 
				}
				State = 416;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,26,Context);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			UnrollRecursionContexts(_parentctx);
		}
		return _localctx;
	}

	public partial class ParameterDeclarationContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public DeclarationSpecifiersContext declarationSpecifiers() {
			return GetRuleContext<DeclarationSpecifiersContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public DeclaratorContext declarator() {
			return GetRuleContext<DeclaratorContext>(0);
		}
		public ParameterDeclarationContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_parameterDeclaration; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.EnterParameterDeclaration(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.ExitParameterDeclaration(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IC_GrammarVisitor<TResult> typedVisitor = visitor as IC_GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitParameterDeclaration(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ParameterDeclarationContext parameterDeclaration() {
		ParameterDeclarationContext _localctx = new ParameterDeclarationContext(Context, State);
		EnterRule(_localctx, 62, RULE_parameterDeclaration);
		try {
			State = 421;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,27,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 417;
				declarationSpecifiers();
				State = 418;
				declarator();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 420;
				declarationSpecifiers();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ParameterListContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ParameterDeclarationContext parameterDeclaration() {
			return GetRuleContext<ParameterDeclarationContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ParameterListContext parameterList() {
			return GetRuleContext<ParameterListContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Comma() { return GetToken(C_GrammarParser.Comma, 0); }
		public ParameterListContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_parameterList; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.EnterParameterList(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.ExitParameterList(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IC_GrammarVisitor<TResult> typedVisitor = visitor as IC_GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitParameterList(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ParameterListContext parameterList() {
		return parameterList(0);
	}

	private ParameterListContext parameterList(int _p) {
		ParserRuleContext _parentctx = Context;
		int _parentState = State;
		ParameterListContext _localctx = new ParameterListContext(Context, _parentState);
		ParameterListContext _prevctx = _localctx;
		int _startState = 64;
		EnterRecursionRule(_localctx, 64, RULE_parameterList, _p);
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			{
			State = 424;
			parameterDeclaration();
			}
			Context.Stop = TokenStream.LT(-1);
			State = 431;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,28,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					if ( ParseListeners!=null )
						TriggerExitRuleEvent();
					_prevctx = _localctx;
					{
					{
					_localctx = new ParameterListContext(_parentctx, _parentState);
					PushNewRecursionContext(_localctx, _startState, RULE_parameterList);
					State = 426;
					if (!(Precpred(Context, 1))) throw new FailedPredicateException(this, "Precpred(Context, 1)");
					State = 427;
					Match(Comma);
					State = 428;
					parameterDeclaration();
					}
					} 
				}
				State = 433;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,28,Context);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			UnrollRecursionContexts(_parentctx);
		}
		return _localctx;
	}

	public partial class TypeQualifierListContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Const() { return GetToken(C_GrammarParser.Const, 0); }
		public TypeQualifierListContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_typeQualifierList; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.EnterTypeQualifierList(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.ExitTypeQualifierList(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IC_GrammarVisitor<TResult> typedVisitor = visitor as IC_GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTypeQualifierList(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public TypeQualifierListContext typeQualifierList() {
		TypeQualifierListContext _localctx = new TypeQualifierListContext(Context, State);
		EnterRule(_localctx, 66, RULE_typeQualifierList);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 434;
			Match(Const);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class PointerContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Multiply() { return GetToken(C_GrammarParser.Multiply, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public TypeQualifierListContext typeQualifierList() {
			return GetRuleContext<TypeQualifierListContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public PointerContext pointer() {
			return GetRuleContext<PointerContext>(0);
		}
		public PointerContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_pointer; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.EnterPointer(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.ExitPointer(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IC_GrammarVisitor<TResult> typedVisitor = visitor as IC_GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitPointer(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public PointerContext pointer() {
		PointerContext _localctx = new PointerContext(Context, State);
		EnterRule(_localctx, 68, RULE_pointer);
		try {
			State = 445;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,29,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 436;
				Match(Multiply);
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 437;
				Match(Multiply);
				State = 438;
				typeQualifierList();
				}
				break;
			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 439;
				Match(Multiply);
				State = 440;
				pointer();
				}
				break;
			case 4:
				EnterOuterAlt(_localctx, 4);
				{
				State = 441;
				Match(Multiply);
				State = 442;
				typeQualifierList();
				State = 443;
				pointer();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class DirectDeclaratorContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Identifier() { return GetToken(C_GrammarParser.Identifier, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LeftParen() { return GetToken(C_GrammarParser.LeftParen, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public DeclaratorContext declarator() {
			return GetRuleContext<DeclaratorContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RightParen() { return GetToken(C_GrammarParser.RightParen, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public DirectDeclaratorContext directDeclarator() {
			return GetRuleContext<DirectDeclaratorContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LeftBracket() { return GetToken(C_GrammarParser.LeftBracket, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ConstantExpressionContext constantExpression() {
			return GetRuleContext<ConstantExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RightBracket() { return GetToken(C_GrammarParser.RightBracket, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ParameterListContext parameterList() {
			return GetRuleContext<ParameterListContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public IdentifierListContext identifierList() {
			return GetRuleContext<IdentifierListContext>(0);
		}
		public DirectDeclaratorContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_directDeclarator; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.EnterDirectDeclarator(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.ExitDirectDeclarator(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IC_GrammarVisitor<TResult> typedVisitor = visitor as IC_GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitDirectDeclarator(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public DirectDeclaratorContext directDeclarator() {
		return directDeclarator(0);
	}

	private DirectDeclaratorContext directDeclarator(int _p) {
		ParserRuleContext _parentctx = Context;
		int _parentState = State;
		DirectDeclaratorContext _localctx = new DirectDeclaratorContext(Context, _parentState);
		DirectDeclaratorContext _prevctx = _localctx;
		int _startState = 70;
		EnterRecursionRule(_localctx, 70, RULE_directDeclarator, _p);
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 453;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case Identifier:
				{
				State = 448;
				Match(Identifier);
				}
				break;
			case LeftParen:
				{
				State = 449;
				Match(LeftParen);
				State = 450;
				declarator();
				State = 451;
				Match(RightParen);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			Context.Stop = TokenStream.LT(-1);
			State = 478;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,32,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					if ( ParseListeners!=null )
						TriggerExitRuleEvent();
					_prevctx = _localctx;
					{
					State = 476;
					ErrorHandler.Sync(this);
					switch ( Interpreter.AdaptivePredict(TokenStream,31,Context) ) {
					case 1:
						{
						_localctx = new DirectDeclaratorContext(_parentctx, _parentState);
						PushNewRecursionContext(_localctx, _startState, RULE_directDeclarator);
						State = 455;
						if (!(Precpred(Context, 5))) throw new FailedPredicateException(this, "Precpred(Context, 5)");
						State = 456;
						Match(LeftBracket);
						State = 457;
						constantExpression();
						State = 458;
						Match(RightBracket);
						}
						break;
					case 2:
						{
						_localctx = new DirectDeclaratorContext(_parentctx, _parentState);
						PushNewRecursionContext(_localctx, _startState, RULE_directDeclarator);
						State = 460;
						if (!(Precpred(Context, 4))) throw new FailedPredicateException(this, "Precpred(Context, 4)");
						State = 461;
						Match(LeftBracket);
						State = 462;
						Match(RightBracket);
						}
						break;
					case 3:
						{
						_localctx = new DirectDeclaratorContext(_parentctx, _parentState);
						PushNewRecursionContext(_localctx, _startState, RULE_directDeclarator);
						State = 463;
						if (!(Precpred(Context, 3))) throw new FailedPredicateException(this, "Precpred(Context, 3)");
						State = 464;
						Match(LeftParen);
						State = 465;
						parameterList(0);
						State = 466;
						Match(RightParen);
						}
						break;
					case 4:
						{
						_localctx = new DirectDeclaratorContext(_parentctx, _parentState);
						PushNewRecursionContext(_localctx, _startState, RULE_directDeclarator);
						State = 468;
						if (!(Precpred(Context, 2))) throw new FailedPredicateException(this, "Precpred(Context, 2)");
						State = 469;
						Match(LeftParen);
						State = 470;
						identifierList(0);
						State = 471;
						Match(RightParen);
						}
						break;
					case 5:
						{
						_localctx = new DirectDeclaratorContext(_parentctx, _parentState);
						PushNewRecursionContext(_localctx, _startState, RULE_directDeclarator);
						State = 473;
						if (!(Precpred(Context, 1))) throw new FailedPredicateException(this, "Precpred(Context, 1)");
						State = 474;
						Match(LeftParen);
						State = 475;
						Match(RightParen);
						}
						break;
					}
					} 
				}
				State = 480;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,32,Context);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			UnrollRecursionContexts(_parentctx);
		}
		return _localctx;
	}

	public partial class DeclaratorContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public PointerContext pointer() {
			return GetRuleContext<PointerContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public DirectDeclaratorContext directDeclarator() {
			return GetRuleContext<DirectDeclaratorContext>(0);
		}
		public DeclaratorContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_declarator; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.EnterDeclarator(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.ExitDeclarator(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IC_GrammarVisitor<TResult> typedVisitor = visitor as IC_GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitDeclarator(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public DeclaratorContext declarator() {
		DeclaratorContext _localctx = new DeclaratorContext(Context, State);
		EnterRule(_localctx, 72, RULE_declarator);
		try {
			State = 485;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case Multiply:
				EnterOuterAlt(_localctx, 1);
				{
				State = 481;
				pointer();
				State = 482;
				directDeclarator(0);
				}
				break;
			case LeftParen:
			case Identifier:
				EnterOuterAlt(_localctx, 2);
				{
				State = 484;
				directDeclarator(0);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SpecifierQualifierListContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public TypeSpecifierContext typeSpecifier() {
			return GetRuleContext<TypeSpecifierContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public SpecifierQualifierListContext specifierQualifierList() {
			return GetRuleContext<SpecifierQualifierListContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Const() { return GetToken(C_GrammarParser.Const, 0); }
		public SpecifierQualifierListContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_specifierQualifierList; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.EnterSpecifierQualifierList(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.ExitSpecifierQualifierList(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IC_GrammarVisitor<TResult> typedVisitor = visitor as IC_GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSpecifierQualifierList(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public SpecifierQualifierListContext specifierQualifierList() {
		SpecifierQualifierListContext _localctx = new SpecifierQualifierListContext(Context, State);
		EnterRule(_localctx, 74, RULE_specifierQualifierList);
		try {
			State = 494;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,34,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 487;
				typeSpecifier();
				State = 488;
				specifierQualifierList();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 490;
				typeSpecifier();
				}
				break;
			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 491;
				Match(Const);
				State = 492;
				specifierQualifierList();
				}
				break;
			case 4:
				EnterOuterAlt(_localctx, 4);
				{
				State = 493;
				Match(Const);
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class StructSpecifierContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Struct() { return GetToken(C_GrammarParser.Struct, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Identifier() { return GetToken(C_GrammarParser.Identifier, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LeftBrace() { return GetToken(C_GrammarParser.LeftBrace, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public StructDeclarationListContext structDeclarationList() {
			return GetRuleContext<StructDeclarationListContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RightBrace() { return GetToken(C_GrammarParser.RightBrace, 0); }
		public StructSpecifierContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_structSpecifier; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.EnterStructSpecifier(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.ExitStructSpecifier(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IC_GrammarVisitor<TResult> typedVisitor = visitor as IC_GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitStructSpecifier(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public StructSpecifierContext structSpecifier() {
		StructSpecifierContext _localctx = new StructSpecifierContext(Context, State);
		EnterRule(_localctx, 76, RULE_structSpecifier);
		try {
			State = 504;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,35,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 496;
				Match(Struct);
				State = 497;
				Match(Identifier);
				State = 498;
				Match(LeftBrace);
				State = 499;
				structDeclarationList(0);
				State = 500;
				Match(RightBrace);
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 502;
				Match(Struct);
				State = 503;
				Match(Identifier);
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class StructDeclarationListContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public StructDeclarationContext structDeclaration() {
			return GetRuleContext<StructDeclarationContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public StructDeclarationListContext structDeclarationList() {
			return GetRuleContext<StructDeclarationListContext>(0);
		}
		public StructDeclarationListContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_structDeclarationList; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.EnterStructDeclarationList(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.ExitStructDeclarationList(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IC_GrammarVisitor<TResult> typedVisitor = visitor as IC_GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitStructDeclarationList(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public StructDeclarationListContext structDeclarationList() {
		return structDeclarationList(0);
	}

	private StructDeclarationListContext structDeclarationList(int _p) {
		ParserRuleContext _parentctx = Context;
		int _parentState = State;
		StructDeclarationListContext _localctx = new StructDeclarationListContext(Context, _parentState);
		StructDeclarationListContext _prevctx = _localctx;
		int _startState = 78;
		EnterRecursionRule(_localctx, 78, RULE_structDeclarationList, _p);
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			{
			State = 507;
			structDeclaration();
			}
			Context.Stop = TokenStream.LT(-1);
			State = 513;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,36,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					if ( ParseListeners!=null )
						TriggerExitRuleEvent();
					_prevctx = _localctx;
					{
					{
					_localctx = new StructDeclarationListContext(_parentctx, _parentState);
					PushNewRecursionContext(_localctx, _startState, RULE_structDeclarationList);
					State = 509;
					if (!(Precpred(Context, 1))) throw new FailedPredicateException(this, "Precpred(Context, 1)");
					State = 510;
					structDeclaration();
					}
					} 
				}
				State = 515;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,36,Context);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			UnrollRecursionContexts(_parentctx);
		}
		return _localctx;
	}

	public partial class StructDeclarationContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public SpecifierQualifierListContext specifierQualifierList() {
			return GetRuleContext<SpecifierQualifierListContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public StructDeclaratorListContext structDeclaratorList() {
			return GetRuleContext<StructDeclaratorListContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Semicolon() { return GetToken(C_GrammarParser.Semicolon, 0); }
		public StructDeclarationContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_structDeclaration; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.EnterStructDeclaration(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.ExitStructDeclaration(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IC_GrammarVisitor<TResult> typedVisitor = visitor as IC_GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitStructDeclaration(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public StructDeclarationContext structDeclaration() {
		StructDeclarationContext _localctx = new StructDeclarationContext(Context, State);
		EnterRule(_localctx, 80, RULE_structDeclaration);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 516;
			specifierQualifierList();
			State = 517;
			structDeclaratorList(0);
			State = 518;
			Match(Semicolon);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class StructDeclaratorListContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public StructDeclaratorContext structDeclarator() {
			return GetRuleContext<StructDeclaratorContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public StructDeclaratorListContext structDeclaratorList() {
			return GetRuleContext<StructDeclaratorListContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Comma() { return GetToken(C_GrammarParser.Comma, 0); }
		public StructDeclaratorListContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_structDeclaratorList; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.EnterStructDeclaratorList(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.ExitStructDeclaratorList(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IC_GrammarVisitor<TResult> typedVisitor = visitor as IC_GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitStructDeclaratorList(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public StructDeclaratorListContext structDeclaratorList() {
		return structDeclaratorList(0);
	}

	private StructDeclaratorListContext structDeclaratorList(int _p) {
		ParserRuleContext _parentctx = Context;
		int _parentState = State;
		StructDeclaratorListContext _localctx = new StructDeclaratorListContext(Context, _parentState);
		StructDeclaratorListContext _prevctx = _localctx;
		int _startState = 82;
		EnterRecursionRule(_localctx, 82, RULE_structDeclaratorList, _p);
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			{
			State = 521;
			structDeclarator();
			}
			Context.Stop = TokenStream.LT(-1);
			State = 528;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,37,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					if ( ParseListeners!=null )
						TriggerExitRuleEvent();
					_prevctx = _localctx;
					{
					{
					_localctx = new StructDeclaratorListContext(_parentctx, _parentState);
					PushNewRecursionContext(_localctx, _startState, RULE_structDeclaratorList);
					State = 523;
					if (!(Precpred(Context, 1))) throw new FailedPredicateException(this, "Precpred(Context, 1)");
					State = 524;
					Match(Comma);
					State = 525;
					structDeclarator();
					}
					} 
				}
				State = 530;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,37,Context);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			UnrollRecursionContexts(_parentctx);
		}
		return _localctx;
	}

	public partial class StructDeclaratorContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public DeclaratorContext declarator() {
			return GetRuleContext<DeclaratorContext>(0);
		}
		public StructDeclaratorContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_structDeclarator; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.EnterStructDeclarator(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.ExitStructDeclarator(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IC_GrammarVisitor<TResult> typedVisitor = visitor as IC_GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitStructDeclarator(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public StructDeclaratorContext structDeclarator() {
		StructDeclaratorContext _localctx = new StructDeclaratorContext(Context, State);
		EnterRule(_localctx, 84, RULE_structDeclarator);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 531;
			declarator();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class StorageClassSpecifierContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Typedef() { return GetToken(C_GrammarParser.Typedef, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Extern() { return GetToken(C_GrammarParser.Extern, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Static() { return GetToken(C_GrammarParser.Static, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Auto() { return GetToken(C_GrammarParser.Auto, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Register() { return GetToken(C_GrammarParser.Register, 0); }
		public StorageClassSpecifierContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_storageClassSpecifier; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.EnterStorageClassSpecifier(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.ExitStorageClassSpecifier(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IC_GrammarVisitor<TResult> typedVisitor = visitor as IC_GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitStorageClassSpecifier(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public StorageClassSpecifierContext storageClassSpecifier() {
		StorageClassSpecifierContext _localctx = new StorageClassSpecifierContext(Context, State);
		EnterRule(_localctx, 86, RULE_storageClassSpecifier);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 533;
			_la = TokenStream.LA(1);
			if ( !((((_la) & ~0x3f) == 0 && ((1L << _la) & 126976L) != 0)) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TypeSpecifierContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Void() { return GetToken(C_GrammarParser.Void, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Char() { return GetToken(C_GrammarParser.Char, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Short() { return GetToken(C_GrammarParser.Short, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Int() { return GetToken(C_GrammarParser.Int, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Long() { return GetToken(C_GrammarParser.Long, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Float() { return GetToken(C_GrammarParser.Float, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Double() { return GetToken(C_GrammarParser.Double, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Signed() { return GetToken(C_GrammarParser.Signed, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Unsigned() { return GetToken(C_GrammarParser.Unsigned, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Bool() { return GetToken(C_GrammarParser.Bool, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public StructSpecifierContext structSpecifier() {
			return GetRuleContext<StructSpecifierContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public TypeNameIdentifierContext typeNameIdentifier() {
			return GetRuleContext<TypeNameIdentifierContext>(0);
		}
		public TypeSpecifierContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_typeSpecifier; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.EnterTypeSpecifier(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.ExitTypeSpecifier(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IC_GrammarVisitor<TResult> typedVisitor = visitor as IC_GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTypeSpecifier(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public TypeSpecifierContext typeSpecifier() {
		TypeSpecifierContext _localctx = new TypeSpecifierContext(Context, State);
		EnterRule(_localctx, 88, RULE_typeSpecifier);
		try {
			State = 547;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case Void:
				EnterOuterAlt(_localctx, 1);
				{
				State = 535;
				Match(Void);
				}
				break;
			case Char:
				EnterOuterAlt(_localctx, 2);
				{
				State = 536;
				Match(Char);
				}
				break;
			case Short:
				EnterOuterAlt(_localctx, 3);
				{
				State = 537;
				Match(Short);
				}
				break;
			case Int:
				EnterOuterAlt(_localctx, 4);
				{
				State = 538;
				Match(Int);
				}
				break;
			case Long:
				EnterOuterAlt(_localctx, 5);
				{
				State = 539;
				Match(Long);
				}
				break;
			case Float:
				EnterOuterAlt(_localctx, 6);
				{
				State = 540;
				Match(Float);
				}
				break;
			case Double:
				EnterOuterAlt(_localctx, 7);
				{
				State = 541;
				Match(Double);
				}
				break;
			case Signed:
				EnterOuterAlt(_localctx, 8);
				{
				State = 542;
				Match(Signed);
				}
				break;
			case Unsigned:
				EnterOuterAlt(_localctx, 9);
				{
				State = 543;
				Match(Unsigned);
				}
				break;
			case Bool:
				EnterOuterAlt(_localctx, 10);
				{
				State = 544;
				Match(Bool);
				}
				break;
			case Struct:
				EnterOuterAlt(_localctx, 11);
				{
				State = 545;
				structSpecifier();
				}
				break;
			case Identifier:
				EnterOuterAlt(_localctx, 12);
				{
				State = 546;
				typeNameIdentifier();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TypeNameIdentifierContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Identifier() { return GetToken(C_GrammarParser.Identifier, 0); }
		public TypeNameIdentifierContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_typeNameIdentifier; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.EnterTypeNameIdentifier(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.ExitTypeNameIdentifier(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IC_GrammarVisitor<TResult> typedVisitor = visitor as IC_GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTypeNameIdentifier(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public TypeNameIdentifierContext typeNameIdentifier() {
		TypeNameIdentifierContext _localctx = new TypeNameIdentifierContext(Context, State);
		EnterRule(_localctx, 90, RULE_typeNameIdentifier);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 549;
			Match(Identifier);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TypeNameContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public SpecifierQualifierListContext specifierQualifierList() {
			return GetRuleContext<SpecifierQualifierListContext>(0);
		}
		public TypeNameContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_typeName; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.EnterTypeName(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.ExitTypeName(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IC_GrammarVisitor<TResult> typedVisitor = visitor as IC_GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTypeName(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public TypeNameContext typeName() {
		TypeNameContext _localctx = new TypeNameContext(Context, State);
		EnterRule(_localctx, 92, RULE_typeName);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 551;
			specifierQualifierList();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class DeclarationSpecifiersContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public StorageClassSpecifierContext storageClassSpecifier() {
			return GetRuleContext<StorageClassSpecifierContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public DeclarationSpecifiersContext declarationSpecifiers() {
			return GetRuleContext<DeclarationSpecifiersContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public TypeSpecifierContext typeSpecifier() {
			return GetRuleContext<TypeSpecifierContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Const() { return GetToken(C_GrammarParser.Const, 0); }
		public DeclarationSpecifiersContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_declarationSpecifiers; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.EnterDeclarationSpecifiers(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.ExitDeclarationSpecifiers(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IC_GrammarVisitor<TResult> typedVisitor = visitor as IC_GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitDeclarationSpecifiers(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public DeclarationSpecifiersContext declarationSpecifiers() {
		DeclarationSpecifiersContext _localctx = new DeclarationSpecifiersContext(Context, State);
		EnterRule(_localctx, 94, RULE_declarationSpecifiers);
		try {
			State = 564;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,39,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 553;
				storageClassSpecifier();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 554;
				storageClassSpecifier();
				State = 555;
				declarationSpecifiers();
				}
				break;
			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 557;
				typeSpecifier();
				}
				break;
			case 4:
				EnterOuterAlt(_localctx, 4);
				{
				State = 558;
				typeSpecifier();
				State = 559;
				declarationSpecifiers();
				}
				break;
			case 5:
				EnterOuterAlt(_localctx, 5);
				{
				State = 561;
				Match(Const);
				}
				break;
			case 6:
				EnterOuterAlt(_localctx, 6);
				{
				State = 562;
				Match(Const);
				State = 563;
				declarationSpecifiers();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class InitDeclaratorListContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public InitDeclaratorContext initDeclarator() {
			return GetRuleContext<InitDeclaratorContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public InitDeclaratorListContext initDeclaratorList() {
			return GetRuleContext<InitDeclaratorListContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Comma() { return GetToken(C_GrammarParser.Comma, 0); }
		public InitDeclaratorListContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_initDeclaratorList; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.EnterInitDeclaratorList(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.ExitInitDeclaratorList(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IC_GrammarVisitor<TResult> typedVisitor = visitor as IC_GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitInitDeclaratorList(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public InitDeclaratorListContext initDeclaratorList() {
		return initDeclaratorList(0);
	}

	private InitDeclaratorListContext initDeclaratorList(int _p) {
		ParserRuleContext _parentctx = Context;
		int _parentState = State;
		InitDeclaratorListContext _localctx = new InitDeclaratorListContext(Context, _parentState);
		InitDeclaratorListContext _prevctx = _localctx;
		int _startState = 96;
		EnterRecursionRule(_localctx, 96, RULE_initDeclaratorList, _p);
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			{
			State = 567;
			initDeclarator();
			}
			Context.Stop = TokenStream.LT(-1);
			State = 574;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,40,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					if ( ParseListeners!=null )
						TriggerExitRuleEvent();
					_prevctx = _localctx;
					{
					{
					_localctx = new InitDeclaratorListContext(_parentctx, _parentState);
					PushNewRecursionContext(_localctx, _startState, RULE_initDeclaratorList);
					State = 569;
					if (!(Precpred(Context, 1))) throw new FailedPredicateException(this, "Precpred(Context, 1)");
					State = 570;
					Match(Comma);
					State = 571;
					initDeclarator();
					}
					} 
				}
				State = 576;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,40,Context);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			UnrollRecursionContexts(_parentctx);
		}
		return _localctx;
	}

	public partial class InitDeclaratorContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public DeclaratorContext declarator() {
			return GetRuleContext<DeclaratorContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Assign() { return GetToken(C_GrammarParser.Assign, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public InitializerContext initializer() {
			return GetRuleContext<InitializerContext>(0);
		}
		public InitDeclaratorContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_initDeclarator; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.EnterInitDeclarator(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.ExitInitDeclarator(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IC_GrammarVisitor<TResult> typedVisitor = visitor as IC_GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitInitDeclarator(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public InitDeclaratorContext initDeclarator() {
		InitDeclaratorContext _localctx = new InitDeclaratorContext(Context, State);
		EnterRule(_localctx, 98, RULE_initDeclarator);
		try {
			State = 582;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,41,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 577;
				declarator();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 578;
				declarator();
				State = 579;
				Match(Assign);
				State = 580;
				initializer();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class DeclarationContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public DeclarationSpecifiersContext declarationSpecifiers() {
			return GetRuleContext<DeclarationSpecifiersContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Semicolon() { return GetToken(C_GrammarParser.Semicolon, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public InitDeclaratorListContext initDeclaratorList() {
			return GetRuleContext<InitDeclaratorListContext>(0);
		}
		public DeclarationContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_declaration; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.EnterDeclaration(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.ExitDeclaration(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IC_GrammarVisitor<TResult> typedVisitor = visitor as IC_GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitDeclaration(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public DeclarationContext declaration() {
		DeclarationContext _localctx = new DeclarationContext(Context, State);
		EnterRule(_localctx, 100, RULE_declaration);
		try {
			State = 591;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,42,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 584;
				declarationSpecifiers();
				State = 585;
				Match(Semicolon);
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 587;
				declarationSpecifiers();
				State = 588;
				initDeclaratorList(0);
				State = 589;
				Match(Semicolon);
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ConstantExpressionContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ConditionalExpressionContext conditionalExpression() {
			return GetRuleContext<ConditionalExpressionContext>(0);
		}
		public ConstantExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_constantExpression; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.EnterConstantExpression(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.ExitConstantExpression(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IC_GrammarVisitor<TResult> typedVisitor = visitor as IC_GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitConstantExpression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ConstantExpressionContext constantExpression() {
		ConstantExpressionContext _localctx = new ConstantExpressionContext(Context, State);
		EnterRule(_localctx, 102, RULE_constantExpression);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 593;
			conditionalExpression();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ExpressionContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public AssignmentExpressionContext assignmentExpression() {
			return GetRuleContext<AssignmentExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Comma() { return GetToken(C_GrammarParser.Comma, 0); }
		public ExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_expression; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.EnterExpression(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.ExitExpression(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IC_GrammarVisitor<TResult> typedVisitor = visitor as IC_GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitExpression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ExpressionContext expression() {
		return expression(0);
	}

	private ExpressionContext expression(int _p) {
		ParserRuleContext _parentctx = Context;
		int _parentState = State;
		ExpressionContext _localctx = new ExpressionContext(Context, _parentState);
		ExpressionContext _prevctx = _localctx;
		int _startState = 104;
		EnterRecursionRule(_localctx, 104, RULE_expression, _p);
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			{
			State = 596;
			assignmentExpression();
			}
			Context.Stop = TokenStream.LT(-1);
			State = 603;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,43,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					if ( ParseListeners!=null )
						TriggerExitRuleEvent();
					_prevctx = _localctx;
					{
					{
					_localctx = new ExpressionContext(_parentctx, _parentState);
					PushNewRecursionContext(_localctx, _startState, RULE_expression);
					State = 598;
					if (!(Precpred(Context, 1))) throw new FailedPredicateException(this, "Precpred(Context, 1)");
					State = 599;
					Match(Comma);
					State = 600;
					assignmentExpression();
					}
					} 
				}
				State = 605;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,43,Context);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			UnrollRecursionContexts(_parentctx);
		}
		return _localctx;
	}

	public partial class AssignmentOperatorContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Assign() { return GetToken(C_GrammarParser.Assign, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode MulAssign() { return GetToken(C_GrammarParser.MulAssign, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DivAssign() { return GetToken(C_GrammarParser.DivAssign, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ModAssign() { return GetToken(C_GrammarParser.ModAssign, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode AddAssign() { return GetToken(C_GrammarParser.AddAssign, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SubAssign() { return GetToken(C_GrammarParser.SubAssign, 0); }
		public AssignmentOperatorContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_assignmentOperator; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.EnterAssignmentOperator(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.ExitAssignmentOperator(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IC_GrammarVisitor<TResult> typedVisitor = visitor as IC_GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAssignmentOperator(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public AssignmentOperatorContext assignmentOperator() {
		AssignmentOperatorContext _localctx = new AssignmentOperatorContext(Context, State);
		EnterRule(_localctx, 106, RULE_assignmentOperator);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 606;
			_la = TokenStream.LA(1);
			if ( !(((((_la - 43)) & ~0x3f) == 0 && ((1L << (_la - 43)) & 2080374785L) != 0)) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class AssignmentExpressionContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ConditionalExpressionContext conditionalExpression() {
			return GetRuleContext<ConditionalExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public UnaryExpressionContext unaryExpression() {
			return GetRuleContext<UnaryExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public AssignmentOperatorContext assignmentOperator() {
			return GetRuleContext<AssignmentOperatorContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public AssignmentExpressionContext assignmentExpression() {
			return GetRuleContext<AssignmentExpressionContext>(0);
		}
		public AssignmentExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_assignmentExpression; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.EnterAssignmentExpression(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.ExitAssignmentExpression(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IC_GrammarVisitor<TResult> typedVisitor = visitor as IC_GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAssignmentExpression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public AssignmentExpressionContext assignmentExpression() {
		AssignmentExpressionContext _localctx = new AssignmentExpressionContext(Context, State);
		EnterRule(_localctx, 108, RULE_assignmentExpression);
		try {
			State = 613;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,44,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 608;
				conditionalExpression();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 609;
				unaryExpression();
				State = 610;
				assignmentOperator();
				State = 611;
				assignmentExpression();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ConditionalExpressionContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public LogicalOrExpressionContext logicalOrExpression() {
			return GetRuleContext<LogicalOrExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode QuestionMark() { return GetToken(C_GrammarParser.QuestionMark, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Colon() { return GetToken(C_GrammarParser.Colon, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ConditionalExpressionContext conditionalExpression() {
			return GetRuleContext<ConditionalExpressionContext>(0);
		}
		public ConditionalExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_conditionalExpression; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.EnterConditionalExpression(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.ExitConditionalExpression(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IC_GrammarVisitor<TResult> typedVisitor = visitor as IC_GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitConditionalExpression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ConditionalExpressionContext conditionalExpression() {
		ConditionalExpressionContext _localctx = new ConditionalExpressionContext(Context, State);
		EnterRule(_localctx, 110, RULE_conditionalExpression);
		try {
			State = 622;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,45,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 615;
				logicalOrExpression(0);
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 616;
				logicalOrExpression(0);
				State = 617;
				Match(QuestionMark);
				State = 618;
				expression(0);
				State = 619;
				Match(Colon);
				State = 620;
				conditionalExpression();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class LogicalOrExpressionContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public LogicalAndExpressionContext logicalAndExpression() {
			return GetRuleContext<LogicalAndExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public LogicalOrExpressionContext logicalOrExpression() {
			return GetRuleContext<LogicalOrExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode OrOp() { return GetToken(C_GrammarParser.OrOp, 0); }
		public LogicalOrExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_logicalOrExpression; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.EnterLogicalOrExpression(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.ExitLogicalOrExpression(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IC_GrammarVisitor<TResult> typedVisitor = visitor as IC_GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitLogicalOrExpression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public LogicalOrExpressionContext logicalOrExpression() {
		return logicalOrExpression(0);
	}

	private LogicalOrExpressionContext logicalOrExpression(int _p) {
		ParserRuleContext _parentctx = Context;
		int _parentState = State;
		LogicalOrExpressionContext _localctx = new LogicalOrExpressionContext(Context, _parentState);
		LogicalOrExpressionContext _prevctx = _localctx;
		int _startState = 112;
		EnterRecursionRule(_localctx, 112, RULE_logicalOrExpression, _p);
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			{
			State = 625;
			logicalAndExpression(0);
			}
			Context.Stop = TokenStream.LT(-1);
			State = 632;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,46,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					if ( ParseListeners!=null )
						TriggerExitRuleEvent();
					_prevctx = _localctx;
					{
					{
					_localctx = new LogicalOrExpressionContext(_parentctx, _parentState);
					PushNewRecursionContext(_localctx, _startState, RULE_logicalOrExpression);
					State = 627;
					if (!(Precpred(Context, 1))) throw new FailedPredicateException(this, "Precpred(Context, 1)");
					State = 628;
					Match(OrOp);
					State = 629;
					logicalAndExpression(0);
					}
					} 
				}
				State = 634;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,46,Context);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			UnrollRecursionContexts(_parentctx);
		}
		return _localctx;
	}

	public partial class LogicalAndExpressionContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public EqualityExpressionContext equalityExpression() {
			return GetRuleContext<EqualityExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public LogicalAndExpressionContext logicalAndExpression() {
			return GetRuleContext<LogicalAndExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode AndOp() { return GetToken(C_GrammarParser.AndOp, 0); }
		public LogicalAndExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_logicalAndExpression; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.EnterLogicalAndExpression(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.ExitLogicalAndExpression(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IC_GrammarVisitor<TResult> typedVisitor = visitor as IC_GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitLogicalAndExpression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public LogicalAndExpressionContext logicalAndExpression() {
		return logicalAndExpression(0);
	}

	private LogicalAndExpressionContext logicalAndExpression(int _p) {
		ParserRuleContext _parentctx = Context;
		int _parentState = State;
		LogicalAndExpressionContext _localctx = new LogicalAndExpressionContext(Context, _parentState);
		LogicalAndExpressionContext _prevctx = _localctx;
		int _startState = 114;
		EnterRecursionRule(_localctx, 114, RULE_logicalAndExpression, _p);
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			{
			State = 636;
			equalityExpression(0);
			}
			Context.Stop = TokenStream.LT(-1);
			State = 643;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,47,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					if ( ParseListeners!=null )
						TriggerExitRuleEvent();
					_prevctx = _localctx;
					{
					{
					_localctx = new LogicalAndExpressionContext(_parentctx, _parentState);
					PushNewRecursionContext(_localctx, _startState, RULE_logicalAndExpression);
					State = 638;
					if (!(Precpred(Context, 1))) throw new FailedPredicateException(this, "Precpred(Context, 1)");
					State = 639;
					Match(AndOp);
					State = 640;
					equalityExpression(0);
					}
					} 
				}
				State = 645;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,47,Context);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			UnrollRecursionContexts(_parentctx);
		}
		return _localctx;
	}

	public partial class EqualityExpressionContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public RelationalExpressionContext relationalExpression() {
			return GetRuleContext<RelationalExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public EqualityExpressionContext equalityExpression() {
			return GetRuleContext<EqualityExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode EqOp() { return GetToken(C_GrammarParser.EqOp, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NeOp() { return GetToken(C_GrammarParser.NeOp, 0); }
		public EqualityExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_equalityExpression; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.EnterEqualityExpression(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.ExitEqualityExpression(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IC_GrammarVisitor<TResult> typedVisitor = visitor as IC_GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitEqualityExpression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public EqualityExpressionContext equalityExpression() {
		return equalityExpression(0);
	}

	private EqualityExpressionContext equalityExpression(int _p) {
		ParserRuleContext _parentctx = Context;
		int _parentState = State;
		EqualityExpressionContext _localctx = new EqualityExpressionContext(Context, _parentState);
		EqualityExpressionContext _prevctx = _localctx;
		int _startState = 116;
		EnterRecursionRule(_localctx, 116, RULE_equalityExpression, _p);
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			{
			State = 647;
			relationalExpression(0);
			}
			Context.Stop = TokenStream.LT(-1);
			State = 657;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,49,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					if ( ParseListeners!=null )
						TriggerExitRuleEvent();
					_prevctx = _localctx;
					{
					State = 655;
					ErrorHandler.Sync(this);
					switch ( Interpreter.AdaptivePredict(TokenStream,48,Context) ) {
					case 1:
						{
						_localctx = new EqualityExpressionContext(_parentctx, _parentState);
						PushNewRecursionContext(_localctx, _startState, RULE_equalityExpression);
						State = 649;
						if (!(Precpred(Context, 2))) throw new FailedPredicateException(this, "Precpred(Context, 2)");
						State = 650;
						Match(EqOp);
						State = 651;
						relationalExpression(0);
						}
						break;
					case 2:
						{
						_localctx = new EqualityExpressionContext(_parentctx, _parentState);
						PushNewRecursionContext(_localctx, _startState, RULE_equalityExpression);
						State = 652;
						if (!(Precpred(Context, 1))) throw new FailedPredicateException(this, "Precpred(Context, 1)");
						State = 653;
						Match(NeOp);
						State = 654;
						relationalExpression(0);
						}
						break;
					}
					} 
				}
				State = 659;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,49,Context);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			UnrollRecursionContexts(_parentctx);
		}
		return _localctx;
	}

	public partial class RelationalExpressionContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public AdditiveExpressionContext additiveExpression() {
			return GetRuleContext<AdditiveExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public RelationalExpressionContext relationalExpression() {
			return GetRuleContext<RelationalExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Less() { return GetToken(C_GrammarParser.Less, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Greater() { return GetToken(C_GrammarParser.Greater, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LeOp() { return GetToken(C_GrammarParser.LeOp, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode GeOp() { return GetToken(C_GrammarParser.GeOp, 0); }
		public RelationalExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_relationalExpression; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.EnterRelationalExpression(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.ExitRelationalExpression(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IC_GrammarVisitor<TResult> typedVisitor = visitor as IC_GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitRelationalExpression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public RelationalExpressionContext relationalExpression() {
		return relationalExpression(0);
	}

	private RelationalExpressionContext relationalExpression(int _p) {
		ParserRuleContext _parentctx = Context;
		int _parentState = State;
		RelationalExpressionContext _localctx = new RelationalExpressionContext(Context, _parentState);
		RelationalExpressionContext _prevctx = _localctx;
		int _startState = 118;
		EnterRecursionRule(_localctx, 118, RULE_relationalExpression, _p);
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			{
			State = 661;
			additiveExpression(0);
			}
			Context.Stop = TokenStream.LT(-1);
			State = 677;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,51,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					if ( ParseListeners!=null )
						TriggerExitRuleEvent();
					_prevctx = _localctx;
					{
					State = 675;
					ErrorHandler.Sync(this);
					switch ( Interpreter.AdaptivePredict(TokenStream,50,Context) ) {
					case 1:
						{
						_localctx = new RelationalExpressionContext(_parentctx, _parentState);
						PushNewRecursionContext(_localctx, _startState, RULE_relationalExpression);
						State = 663;
						if (!(Precpred(Context, 4))) throw new FailedPredicateException(this, "Precpred(Context, 4)");
						State = 664;
						Match(Less);
						State = 665;
						additiveExpression(0);
						}
						break;
					case 2:
						{
						_localctx = new RelationalExpressionContext(_parentctx, _parentState);
						PushNewRecursionContext(_localctx, _startState, RULE_relationalExpression);
						State = 666;
						if (!(Precpred(Context, 3))) throw new FailedPredicateException(this, "Precpred(Context, 3)");
						State = 667;
						Match(Greater);
						State = 668;
						additiveExpression(0);
						}
						break;
					case 3:
						{
						_localctx = new RelationalExpressionContext(_parentctx, _parentState);
						PushNewRecursionContext(_localctx, _startState, RULE_relationalExpression);
						State = 669;
						if (!(Precpred(Context, 2))) throw new FailedPredicateException(this, "Precpred(Context, 2)");
						State = 670;
						Match(LeOp);
						State = 671;
						additiveExpression(0);
						}
						break;
					case 4:
						{
						_localctx = new RelationalExpressionContext(_parentctx, _parentState);
						PushNewRecursionContext(_localctx, _startState, RULE_relationalExpression);
						State = 672;
						if (!(Precpred(Context, 1))) throw new FailedPredicateException(this, "Precpred(Context, 1)");
						State = 673;
						Match(GeOp);
						State = 674;
						additiveExpression(0);
						}
						break;
					}
					} 
				}
				State = 679;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,51,Context);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			UnrollRecursionContexts(_parentctx);
		}
		return _localctx;
	}

	public partial class AdditiveExpressionContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public MultiplicativeExpressionContext multiplicativeExpression() {
			return GetRuleContext<MultiplicativeExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public AdditiveExpressionContext additiveExpression() {
			return GetRuleContext<AdditiveExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Plus() { return GetToken(C_GrammarParser.Plus, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Minus() { return GetToken(C_GrammarParser.Minus, 0); }
		public AdditiveExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_additiveExpression; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.EnterAdditiveExpression(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.ExitAdditiveExpression(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IC_GrammarVisitor<TResult> typedVisitor = visitor as IC_GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAdditiveExpression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public AdditiveExpressionContext additiveExpression() {
		return additiveExpression(0);
	}

	private AdditiveExpressionContext additiveExpression(int _p) {
		ParserRuleContext _parentctx = Context;
		int _parentState = State;
		AdditiveExpressionContext _localctx = new AdditiveExpressionContext(Context, _parentState);
		AdditiveExpressionContext _prevctx = _localctx;
		int _startState = 120;
		EnterRecursionRule(_localctx, 120, RULE_additiveExpression, _p);
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			{
			State = 681;
			multiplicativeExpression(0);
			}
			Context.Stop = TokenStream.LT(-1);
			State = 691;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,53,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					if ( ParseListeners!=null )
						TriggerExitRuleEvent();
					_prevctx = _localctx;
					{
					State = 689;
					ErrorHandler.Sync(this);
					switch ( Interpreter.AdaptivePredict(TokenStream,52,Context) ) {
					case 1:
						{
						_localctx = new AdditiveExpressionContext(_parentctx, _parentState);
						PushNewRecursionContext(_localctx, _startState, RULE_additiveExpression);
						State = 683;
						if (!(Precpred(Context, 2))) throw new FailedPredicateException(this, "Precpred(Context, 2)");
						State = 684;
						Match(Plus);
						State = 685;
						multiplicativeExpression(0);
						}
						break;
					case 2:
						{
						_localctx = new AdditiveExpressionContext(_parentctx, _parentState);
						PushNewRecursionContext(_localctx, _startState, RULE_additiveExpression);
						State = 686;
						if (!(Precpred(Context, 1))) throw new FailedPredicateException(this, "Precpred(Context, 1)");
						State = 687;
						Match(Minus);
						State = 688;
						multiplicativeExpression(0);
						}
						break;
					}
					} 
				}
				State = 693;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,53,Context);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			UnrollRecursionContexts(_parentctx);
		}
		return _localctx;
	}

	public partial class MultiplicativeExpressionContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public CastExpressionContext castExpression() {
			return GetRuleContext<CastExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public MultiplicativeExpressionContext multiplicativeExpression() {
			return GetRuleContext<MultiplicativeExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Multiply() { return GetToken(C_GrammarParser.Multiply, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Divide() { return GetToken(C_GrammarParser.Divide, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Mod() { return GetToken(C_GrammarParser.Mod, 0); }
		public MultiplicativeExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_multiplicativeExpression; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.EnterMultiplicativeExpression(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.ExitMultiplicativeExpression(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IC_GrammarVisitor<TResult> typedVisitor = visitor as IC_GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitMultiplicativeExpression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public MultiplicativeExpressionContext multiplicativeExpression() {
		return multiplicativeExpression(0);
	}

	private MultiplicativeExpressionContext multiplicativeExpression(int _p) {
		ParserRuleContext _parentctx = Context;
		int _parentState = State;
		MultiplicativeExpressionContext _localctx = new MultiplicativeExpressionContext(Context, _parentState);
		MultiplicativeExpressionContext _prevctx = _localctx;
		int _startState = 122;
		EnterRecursionRule(_localctx, 122, RULE_multiplicativeExpression, _p);
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			{
			State = 695;
			castExpression();
			}
			Context.Stop = TokenStream.LT(-1);
			State = 708;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,55,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					if ( ParseListeners!=null )
						TriggerExitRuleEvent();
					_prevctx = _localctx;
					{
					State = 706;
					ErrorHandler.Sync(this);
					switch ( Interpreter.AdaptivePredict(TokenStream,54,Context) ) {
					case 1:
						{
						_localctx = new MultiplicativeExpressionContext(_parentctx, _parentState);
						PushNewRecursionContext(_localctx, _startState, RULE_multiplicativeExpression);
						State = 697;
						if (!(Precpred(Context, 3))) throw new FailedPredicateException(this, "Precpred(Context, 3)");
						State = 698;
						Match(Multiply);
						State = 699;
						castExpression();
						}
						break;
					case 2:
						{
						_localctx = new MultiplicativeExpressionContext(_parentctx, _parentState);
						PushNewRecursionContext(_localctx, _startState, RULE_multiplicativeExpression);
						State = 700;
						if (!(Precpred(Context, 2))) throw new FailedPredicateException(this, "Precpred(Context, 2)");
						State = 701;
						Match(Divide);
						State = 702;
						castExpression();
						}
						break;
					case 3:
						{
						_localctx = new MultiplicativeExpressionContext(_parentctx, _parentState);
						PushNewRecursionContext(_localctx, _startState, RULE_multiplicativeExpression);
						State = 703;
						if (!(Precpred(Context, 1))) throw new FailedPredicateException(this, "Precpred(Context, 1)");
						State = 704;
						Match(Mod);
						State = 705;
						castExpression();
						}
						break;
					}
					} 
				}
				State = 710;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,55,Context);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			UnrollRecursionContexts(_parentctx);
		}
		return _localctx;
	}

	public partial class CastExpressionContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public UnaryExpressionContext unaryExpression() {
			return GetRuleContext<UnaryExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LeftParen() { return GetToken(C_GrammarParser.LeftParen, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public TypeNameContext typeName() {
			return GetRuleContext<TypeNameContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RightParen() { return GetToken(C_GrammarParser.RightParen, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public CastExpressionContext castExpression() {
			return GetRuleContext<CastExpressionContext>(0);
		}
		public CastExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_castExpression; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.EnterCastExpression(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.ExitCastExpression(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IC_GrammarVisitor<TResult> typedVisitor = visitor as IC_GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCastExpression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public CastExpressionContext castExpression() {
		CastExpressionContext _localctx = new CastExpressionContext(Context, State);
		EnterRule(_localctx, 124, RULE_castExpression);
		try {
			State = 717;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,56,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 711;
				unaryExpression();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 712;
				Match(LeftParen);
				State = 713;
				typeName();
				State = 714;
				Match(RightParen);
				State = 715;
				castExpression();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class UnaryOperatorContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Ampersand() { return GetToken(C_GrammarParser.Ampersand, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Multiply() { return GetToken(C_GrammarParser.Multiply, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Plus() { return GetToken(C_GrammarParser.Plus, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Minus() { return GetToken(C_GrammarParser.Minus, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Exclamation() { return GetToken(C_GrammarParser.Exclamation, 0); }
		public UnaryOperatorContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_unaryOperator; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.EnterUnaryOperator(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.ExitUnaryOperator(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IC_GrammarVisitor<TResult> typedVisitor = visitor as IC_GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitUnaryOperator(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public UnaryOperatorContext unaryOperator() {
		UnaryOperatorContext _localctx = new UnaryOperatorContext(Context, State);
		EnterRule(_localctx, 126, RULE_unaryOperator);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 719;
			_la = TokenStream.LA(1);
			if ( !((((_la) & ~0x3f) == 0 && ((1L << _la) & 1225893892319084544L) != 0)) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class UnaryExpressionContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public PostfixExpressionContext postfixExpression() {
			return GetRuleContext<PostfixExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode IncOp() { return GetToken(C_GrammarParser.IncOp, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public UnaryExpressionContext unaryExpression() {
			return GetRuleContext<UnaryExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DecOp() { return GetToken(C_GrammarParser.DecOp, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public UnaryOperatorContext unaryOperator() {
			return GetRuleContext<UnaryOperatorContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public CastExpressionContext castExpression() {
			return GetRuleContext<CastExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Sizeof() { return GetToken(C_GrammarParser.Sizeof, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LeftParen() { return GetToken(C_GrammarParser.LeftParen, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public TypeNameContext typeName() {
			return GetRuleContext<TypeNameContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RightParen() { return GetToken(C_GrammarParser.RightParen, 0); }
		public UnaryExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_unaryExpression; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.EnterUnaryExpression(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.ExitUnaryExpression(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IC_GrammarVisitor<TResult> typedVisitor = visitor as IC_GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitUnaryExpression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public UnaryExpressionContext unaryExpression() {
		UnaryExpressionContext _localctx = new UnaryExpressionContext(Context, State);
		EnterRule(_localctx, 128, RULE_unaryExpression);
		try {
			State = 736;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,57,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 721;
				postfixExpression(0);
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 722;
				Match(IncOp);
				State = 723;
				unaryExpression();
				}
				break;
			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 724;
				Match(DecOp);
				State = 725;
				unaryExpression();
				}
				break;
			case 4:
				EnterOuterAlt(_localctx, 4);
				{
				State = 726;
				unaryOperator();
				State = 727;
				castExpression();
				}
				break;
			case 5:
				EnterOuterAlt(_localctx, 5);
				{
				State = 729;
				Match(Sizeof);
				State = 730;
				unaryExpression();
				}
				break;
			case 6:
				EnterOuterAlt(_localctx, 6);
				{
				State = 731;
				Match(Sizeof);
				State = 732;
				Match(LeftParen);
				State = 733;
				typeName();
				State = 734;
				Match(RightParen);
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ArgumentExpressionListContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public AssignmentExpressionContext assignmentExpression() {
			return GetRuleContext<AssignmentExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ArgumentExpressionListContext argumentExpressionList() {
			return GetRuleContext<ArgumentExpressionListContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Comma() { return GetToken(C_GrammarParser.Comma, 0); }
		public ArgumentExpressionListContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_argumentExpressionList; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.EnterArgumentExpressionList(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.ExitArgumentExpressionList(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IC_GrammarVisitor<TResult> typedVisitor = visitor as IC_GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitArgumentExpressionList(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ArgumentExpressionListContext argumentExpressionList() {
		return argumentExpressionList(0);
	}

	private ArgumentExpressionListContext argumentExpressionList(int _p) {
		ParserRuleContext _parentctx = Context;
		int _parentState = State;
		ArgumentExpressionListContext _localctx = new ArgumentExpressionListContext(Context, _parentState);
		ArgumentExpressionListContext _prevctx = _localctx;
		int _startState = 130;
		EnterRecursionRule(_localctx, 130, RULE_argumentExpressionList, _p);
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			{
			State = 739;
			assignmentExpression();
			}
			Context.Stop = TokenStream.LT(-1);
			State = 746;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,58,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					if ( ParseListeners!=null )
						TriggerExitRuleEvent();
					_prevctx = _localctx;
					{
					{
					_localctx = new ArgumentExpressionListContext(_parentctx, _parentState);
					PushNewRecursionContext(_localctx, _startState, RULE_argumentExpressionList);
					State = 741;
					if (!(Precpred(Context, 1))) throw new FailedPredicateException(this, "Precpred(Context, 1)");
					State = 742;
					Match(Comma);
					State = 743;
					assignmentExpression();
					}
					} 
				}
				State = 748;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,58,Context);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			UnrollRecursionContexts(_parentctx);
		}
		return _localctx;
	}

	public partial class PostfixExpressionContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public PrimaryExpressionContext primaryExpression() {
			return GetRuleContext<PrimaryExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public PostfixExpressionContext postfixExpression() {
			return GetRuleContext<PostfixExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LeftBracket() { return GetToken(C_GrammarParser.LeftBracket, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RightBracket() { return GetToken(C_GrammarParser.RightBracket, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LeftParen() { return GetToken(C_GrammarParser.LeftParen, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RightParen() { return GetToken(C_GrammarParser.RightParen, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ArgumentExpressionListContext argumentExpressionList() {
			return GetRuleContext<ArgumentExpressionListContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Dot() { return GetToken(C_GrammarParser.Dot, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Identifier() { return GetToken(C_GrammarParser.Identifier, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Arrow() { return GetToken(C_GrammarParser.Arrow, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode IncOp() { return GetToken(C_GrammarParser.IncOp, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DecOp() { return GetToken(C_GrammarParser.DecOp, 0); }
		public PostfixExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_postfixExpression; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.EnterPostfixExpression(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.ExitPostfixExpression(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IC_GrammarVisitor<TResult> typedVisitor = visitor as IC_GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitPostfixExpression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public PostfixExpressionContext postfixExpression() {
		return postfixExpression(0);
	}

	private PostfixExpressionContext postfixExpression(int _p) {
		ParserRuleContext _parentctx = Context;
		int _parentState = State;
		PostfixExpressionContext _localctx = new PostfixExpressionContext(Context, _parentState);
		PostfixExpressionContext _prevctx = _localctx;
		int _startState = 132;
		EnterRecursionRule(_localctx, 132, RULE_postfixExpression, _p);
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			{
			State = 750;
			primaryExpression();
			}
			Context.Stop = TokenStream.LT(-1);
			State = 777;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,60,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					if ( ParseListeners!=null )
						TriggerExitRuleEvent();
					_prevctx = _localctx;
					{
					State = 775;
					ErrorHandler.Sync(this);
					switch ( Interpreter.AdaptivePredict(TokenStream,59,Context) ) {
					case 1:
						{
						_localctx = new PostfixExpressionContext(_parentctx, _parentState);
						PushNewRecursionContext(_localctx, _startState, RULE_postfixExpression);
						State = 752;
						if (!(Precpred(Context, 7))) throw new FailedPredicateException(this, "Precpred(Context, 7)");
						State = 753;
						Match(LeftBracket);
						State = 754;
						expression(0);
						State = 755;
						Match(RightBracket);
						}
						break;
					case 2:
						{
						_localctx = new PostfixExpressionContext(_parentctx, _parentState);
						PushNewRecursionContext(_localctx, _startState, RULE_postfixExpression);
						State = 757;
						if (!(Precpred(Context, 6))) throw new FailedPredicateException(this, "Precpred(Context, 6)");
						State = 758;
						Match(LeftParen);
						State = 759;
						Match(RightParen);
						}
						break;
					case 3:
						{
						_localctx = new PostfixExpressionContext(_parentctx, _parentState);
						PushNewRecursionContext(_localctx, _startState, RULE_postfixExpression);
						State = 760;
						if (!(Precpred(Context, 5))) throw new FailedPredicateException(this, "Precpred(Context, 5)");
						State = 761;
						Match(LeftParen);
						State = 762;
						argumentExpressionList(0);
						State = 763;
						Match(RightParen);
						}
						break;
					case 4:
						{
						_localctx = new PostfixExpressionContext(_parentctx, _parentState);
						PushNewRecursionContext(_localctx, _startState, RULE_postfixExpression);
						State = 765;
						if (!(Precpred(Context, 4))) throw new FailedPredicateException(this, "Precpred(Context, 4)");
						State = 766;
						Match(Dot);
						State = 767;
						Match(Identifier);
						}
						break;
					case 5:
						{
						_localctx = new PostfixExpressionContext(_parentctx, _parentState);
						PushNewRecursionContext(_localctx, _startState, RULE_postfixExpression);
						State = 768;
						if (!(Precpred(Context, 3))) throw new FailedPredicateException(this, "Precpred(Context, 3)");
						State = 769;
						Match(Arrow);
						State = 770;
						Match(Identifier);
						}
						break;
					case 6:
						{
						_localctx = new PostfixExpressionContext(_parentctx, _parentState);
						PushNewRecursionContext(_localctx, _startState, RULE_postfixExpression);
						State = 771;
						if (!(Precpred(Context, 2))) throw new FailedPredicateException(this, "Precpred(Context, 2)");
						State = 772;
						Match(IncOp);
						}
						break;
					case 7:
						{
						_localctx = new PostfixExpressionContext(_parentctx, _parentState);
						PushNewRecursionContext(_localctx, _startState, RULE_postfixExpression);
						State = 773;
						if (!(Precpred(Context, 1))) throw new FailedPredicateException(this, "Precpred(Context, 1)");
						State = 774;
						Match(DecOp);
						}
						break;
					}
					} 
				}
				State = 779;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,60,Context);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			UnrollRecursionContexts(_parentctx);
		}
		return _localctx;
	}

	public partial class PrimaryExpressionContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Identifier() { return GetToken(C_GrammarParser.Identifier, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Constant() { return GetToken(C_GrammarParser.Constant, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode StringLiteral() { return GetToken(C_GrammarParser.StringLiteral, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LeftParen() { return GetToken(C_GrammarParser.LeftParen, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RightParen() { return GetToken(C_GrammarParser.RightParen, 0); }
		public PrimaryExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_primaryExpression; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.EnterPrimaryExpression(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.ExitPrimaryExpression(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IC_GrammarVisitor<TResult> typedVisitor = visitor as IC_GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitPrimaryExpression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public PrimaryExpressionContext primaryExpression() {
		PrimaryExpressionContext _localctx = new PrimaryExpressionContext(Context, State);
		EnterRule(_localctx, 134, RULE_primaryExpression);
		try {
			State = 787;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case Identifier:
				EnterOuterAlt(_localctx, 1);
				{
				State = 780;
				Match(Identifier);
				}
				break;
			case Constant:
				EnterOuterAlt(_localctx, 2);
				{
				State = 781;
				Match(Constant);
				}
				break;
			case StringLiteral:
				EnterOuterAlt(_localctx, 3);
				{
				State = 782;
				Match(StringLiteral);
				}
				break;
			case LeftParen:
				EnterOuterAlt(_localctx, 4);
				{
				State = 783;
				Match(LeftParen);
				State = 784;
				expression(0);
				State = 785;
				Match(RightParen);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public override bool Sempred(RuleContext _localctx, int ruleIndex, int predIndex) {
		switch (ruleIndex) {
		case 1: return translationUnit_sempred((TranslationUnitContext)_localctx, predIndex);
		case 6: return elseIfBlock_sempred((ElseIfBlockContext)_localctx, predIndex);
		case 21: return statementList_sempred((StatementListContext)_localctx, predIndex);
		case 22: return declarationList_sempred((DeclarationListContext)_localctx, predIndex);
		case 24: return blockItemList_sempred((BlockItemListContext)_localctx, predIndex);
		case 28: return initializerList_sempred((InitializerListContext)_localctx, predIndex);
		case 30: return identifierList_sempred((IdentifierListContext)_localctx, predIndex);
		case 32: return parameterList_sempred((ParameterListContext)_localctx, predIndex);
		case 35: return directDeclarator_sempred((DirectDeclaratorContext)_localctx, predIndex);
		case 39: return structDeclarationList_sempred((StructDeclarationListContext)_localctx, predIndex);
		case 41: return structDeclaratorList_sempred((StructDeclaratorListContext)_localctx, predIndex);
		case 48: return initDeclaratorList_sempred((InitDeclaratorListContext)_localctx, predIndex);
		case 52: return expression_sempred((ExpressionContext)_localctx, predIndex);
		case 56: return logicalOrExpression_sempred((LogicalOrExpressionContext)_localctx, predIndex);
		case 57: return logicalAndExpression_sempred((LogicalAndExpressionContext)_localctx, predIndex);
		case 58: return equalityExpression_sempred((EqualityExpressionContext)_localctx, predIndex);
		case 59: return relationalExpression_sempred((RelationalExpressionContext)_localctx, predIndex);
		case 60: return additiveExpression_sempred((AdditiveExpressionContext)_localctx, predIndex);
		case 61: return multiplicativeExpression_sempred((MultiplicativeExpressionContext)_localctx, predIndex);
		case 65: return argumentExpressionList_sempred((ArgumentExpressionListContext)_localctx, predIndex);
		case 66: return postfixExpression_sempred((PostfixExpressionContext)_localctx, predIndex);
		}
		return true;
	}
	private bool translationUnit_sempred(TranslationUnitContext _localctx, int predIndex) {
		switch (predIndex) {
		case 0: return Precpred(Context, 2);
		case 1: return Precpred(Context, 1);
		}
		return true;
	}
	private bool elseIfBlock_sempred(ElseIfBlockContext _localctx, int predIndex) {
		switch (predIndex) {
		case 2: return Precpred(Context, 1);
		}
		return true;
	}
	private bool statementList_sempred(StatementListContext _localctx, int predIndex) {
		switch (predIndex) {
		case 3: return Precpred(Context, 1);
		}
		return true;
	}
	private bool declarationList_sempred(DeclarationListContext _localctx, int predIndex) {
		switch (predIndex) {
		case 4: return Precpred(Context, 1);
		}
		return true;
	}
	private bool blockItemList_sempred(BlockItemListContext _localctx, int predIndex) {
		switch (predIndex) {
		case 5: return Precpred(Context, 1);
		}
		return true;
	}
	private bool initializerList_sempred(InitializerListContext _localctx, int predIndex) {
		switch (predIndex) {
		case 6: return Precpred(Context, 1);
		}
		return true;
	}
	private bool identifierList_sempred(IdentifierListContext _localctx, int predIndex) {
		switch (predIndex) {
		case 7: return Precpred(Context, 1);
		}
		return true;
	}
	private bool parameterList_sempred(ParameterListContext _localctx, int predIndex) {
		switch (predIndex) {
		case 8: return Precpred(Context, 1);
		}
		return true;
	}
	private bool directDeclarator_sempred(DirectDeclaratorContext _localctx, int predIndex) {
		switch (predIndex) {
		case 9: return Precpred(Context, 5);
		case 10: return Precpred(Context, 4);
		case 11: return Precpred(Context, 3);
		case 12: return Precpred(Context, 2);
		case 13: return Precpred(Context, 1);
		}
		return true;
	}
	private bool structDeclarationList_sempred(StructDeclarationListContext _localctx, int predIndex) {
		switch (predIndex) {
		case 14: return Precpred(Context, 1);
		}
		return true;
	}
	private bool structDeclaratorList_sempred(StructDeclaratorListContext _localctx, int predIndex) {
		switch (predIndex) {
		case 15: return Precpred(Context, 1);
		}
		return true;
	}
	private bool initDeclaratorList_sempred(InitDeclaratorListContext _localctx, int predIndex) {
		switch (predIndex) {
		case 16: return Precpred(Context, 1);
		}
		return true;
	}
	private bool expression_sempred(ExpressionContext _localctx, int predIndex) {
		switch (predIndex) {
		case 17: return Precpred(Context, 1);
		}
		return true;
	}
	private bool logicalOrExpression_sempred(LogicalOrExpressionContext _localctx, int predIndex) {
		switch (predIndex) {
		case 18: return Precpred(Context, 1);
		}
		return true;
	}
	private bool logicalAndExpression_sempred(LogicalAndExpressionContext _localctx, int predIndex) {
		switch (predIndex) {
		case 19: return Precpred(Context, 1);
		}
		return true;
	}
	private bool equalityExpression_sempred(EqualityExpressionContext _localctx, int predIndex) {
		switch (predIndex) {
		case 20: return Precpred(Context, 2);
		case 21: return Precpred(Context, 1);
		}
		return true;
	}
	private bool relationalExpression_sempred(RelationalExpressionContext _localctx, int predIndex) {
		switch (predIndex) {
		case 22: return Precpred(Context, 4);
		case 23: return Precpred(Context, 3);
		case 24: return Precpred(Context, 2);
		case 25: return Precpred(Context, 1);
		}
		return true;
	}
	private bool additiveExpression_sempred(AdditiveExpressionContext _localctx, int predIndex) {
		switch (predIndex) {
		case 26: return Precpred(Context, 2);
		case 27: return Precpred(Context, 1);
		}
		return true;
	}
	private bool multiplicativeExpression_sempred(MultiplicativeExpressionContext _localctx, int predIndex) {
		switch (predIndex) {
		case 28: return Precpred(Context, 3);
		case 29: return Precpred(Context, 2);
		case 30: return Precpred(Context, 1);
		}
		return true;
	}
	private bool argumentExpressionList_sempred(ArgumentExpressionListContext _localctx, int predIndex) {
		switch (predIndex) {
		case 31: return Precpred(Context, 1);
		}
		return true;
	}
	private bool postfixExpression_sempred(PostfixExpressionContext _localctx, int predIndex) {
		switch (predIndex) {
		case 32: return Precpred(Context, 7);
		case 33: return Precpred(Context, 6);
		case 34: return Precpred(Context, 5);
		case 35: return Precpred(Context, 4);
		case 36: return Precpred(Context, 3);
		case 37: return Precpred(Context, 2);
		case 38: return Precpred(Context, 1);
		}
		return true;
	}

	private static int[] _serializedATN = {
		4,1,82,790,2,0,7,0,2,1,7,1,2,2,7,2,2,3,7,3,2,4,7,4,2,5,7,5,2,6,7,6,2,7,
		7,7,2,8,7,8,2,9,7,9,2,10,7,10,2,11,7,11,2,12,7,12,2,13,7,13,2,14,7,14,
		2,15,7,15,2,16,7,16,2,17,7,17,2,18,7,18,2,19,7,19,2,20,7,20,2,21,7,21,
		2,22,7,22,2,23,7,23,2,24,7,24,2,25,7,25,2,26,7,26,2,27,7,27,2,28,7,28,
		2,29,7,29,2,30,7,30,2,31,7,31,2,32,7,32,2,33,7,33,2,34,7,34,2,35,7,35,
		2,36,7,36,2,37,7,37,2,38,7,38,2,39,7,39,2,40,7,40,2,41,7,41,2,42,7,42,
		2,43,7,43,2,44,7,44,2,45,7,45,2,46,7,46,2,47,7,47,2,48,7,48,2,49,7,49,
		2,50,7,50,2,51,7,51,2,52,7,52,2,53,7,53,2,54,7,54,2,55,7,55,2,56,7,56,
		2,57,7,57,2,58,7,58,2,59,7,59,2,60,7,60,2,61,7,61,2,62,7,62,2,63,7,63,
		2,64,7,64,2,65,7,65,2,66,7,66,2,67,7,67,1,0,3,0,138,8,0,1,0,1,0,1,1,1,
		1,1,1,3,1,145,8,1,1,1,1,1,1,1,1,1,5,1,151,8,1,10,1,12,1,154,9,1,1,2,1,
		2,1,2,1,2,1,2,1,2,3,2,162,8,2,1,3,1,3,1,3,1,3,1,3,1,3,3,3,170,8,3,1,4,
		1,4,1,4,1,4,1,5,1,5,3,5,178,8,5,1,5,3,5,181,8,5,1,6,1,6,1,6,1,6,1,6,5,
		6,188,8,6,10,6,12,6,191,9,6,1,7,1,7,1,7,1,7,1,8,1,8,1,8,1,9,1,9,1,9,1,
		9,1,10,1,10,1,10,1,11,1,11,1,11,1,11,1,11,1,12,1,12,1,12,1,12,1,12,1,13,
		1,13,1,13,1,13,1,13,1,14,1,14,1,15,1,15,3,15,226,8,15,1,16,1,16,1,16,1,
		16,1,16,1,16,1,16,1,16,1,16,1,16,1,16,1,16,1,16,1,16,1,16,1,16,3,16,244,
		8,16,1,17,1,17,1,17,1,17,1,17,1,17,1,17,1,17,1,17,1,17,3,17,256,8,17,1,
		18,1,18,1,18,1,18,1,18,1,18,1,18,1,18,1,18,1,18,1,18,1,18,1,18,1,18,1,
		18,1,18,1,18,1,18,3,18,276,8,18,1,18,1,18,1,18,1,18,1,18,1,18,1,18,1,18,
		3,18,286,8,18,1,18,1,18,1,18,1,18,1,18,3,18,293,8,18,1,19,1,19,1,19,1,
		19,1,19,1,19,1,19,1,19,1,19,1,19,1,19,1,19,1,19,1,19,1,19,1,19,1,19,1,
		19,1,19,1,19,3,19,315,8,19,1,20,1,20,1,20,1,20,3,20,321,8,20,1,21,1,21,
		1,21,1,21,1,21,5,21,328,8,21,10,21,12,21,331,9,21,1,22,1,22,1,22,1,22,
		1,22,5,22,338,8,22,10,22,12,22,341,9,22,1,23,1,23,3,23,345,8,23,1,23,1,
		23,1,24,1,24,1,24,1,24,1,24,5,24,354,8,24,10,24,12,24,357,9,24,1,25,1,
		25,3,25,361,8,25,1,26,1,26,1,26,1,26,1,26,1,26,1,26,1,26,1,26,1,26,1,26,
		3,26,374,8,26,1,27,1,27,1,27,1,27,1,27,1,27,3,27,382,8,27,1,28,1,28,1,
		28,1,28,1,28,1,28,5,28,390,8,28,10,28,12,28,393,9,28,1,29,1,29,1,29,1,
		29,1,29,1,29,1,29,1,29,1,29,1,29,3,29,405,8,29,1,30,1,30,1,30,1,30,1,30,
		1,30,5,30,413,8,30,10,30,12,30,416,9,30,1,31,1,31,1,31,1,31,3,31,422,8,
		31,1,32,1,32,1,32,1,32,1,32,1,32,5,32,430,8,32,10,32,12,32,433,9,32,1,
		33,1,33,1,34,1,34,1,34,1,34,1,34,1,34,1,34,1,34,1,34,3,34,446,8,34,1,35,
		1,35,1,35,1,35,1,35,1,35,3,35,454,8,35,1,35,1,35,1,35,1,35,1,35,1,35,1,
		35,1,35,1,35,1,35,1,35,1,35,1,35,1,35,1,35,1,35,1,35,1,35,1,35,1,35,1,
		35,5,35,477,8,35,10,35,12,35,480,9,35,1,36,1,36,1,36,1,36,3,36,486,8,36,
		1,37,1,37,1,37,1,37,1,37,1,37,1,37,3,37,495,8,37,1,38,1,38,1,38,1,38,1,
		38,1,38,1,38,1,38,3,38,505,8,38,1,39,1,39,1,39,1,39,1,39,5,39,512,8,39,
		10,39,12,39,515,9,39,1,40,1,40,1,40,1,40,1,41,1,41,1,41,1,41,1,41,1,41,
		5,41,527,8,41,10,41,12,41,530,9,41,1,42,1,42,1,43,1,43,1,44,1,44,1,44,
		1,44,1,44,1,44,1,44,1,44,1,44,1,44,1,44,1,44,3,44,548,8,44,1,45,1,45,1,
		46,1,46,1,47,1,47,1,47,1,47,1,47,1,47,1,47,1,47,1,47,1,47,1,47,3,47,565,
		8,47,1,48,1,48,1,48,1,48,1,48,1,48,5,48,573,8,48,10,48,12,48,576,9,48,
		1,49,1,49,1,49,1,49,1,49,3,49,583,8,49,1,50,1,50,1,50,1,50,1,50,1,50,1,
		50,3,50,592,8,50,1,51,1,51,1,52,1,52,1,52,1,52,1,52,1,52,5,52,602,8,52,
		10,52,12,52,605,9,52,1,53,1,53,1,54,1,54,1,54,1,54,1,54,3,54,614,8,54,
		1,55,1,55,1,55,1,55,1,55,1,55,1,55,3,55,623,8,55,1,56,1,56,1,56,1,56,1,
		56,1,56,5,56,631,8,56,10,56,12,56,634,9,56,1,57,1,57,1,57,1,57,1,57,1,
		57,5,57,642,8,57,10,57,12,57,645,9,57,1,58,1,58,1,58,1,58,1,58,1,58,1,
		58,1,58,1,58,5,58,656,8,58,10,58,12,58,659,9,58,1,59,1,59,1,59,1,59,1,
		59,1,59,1,59,1,59,1,59,1,59,1,59,1,59,1,59,1,59,1,59,5,59,676,8,59,10,
		59,12,59,679,9,59,1,60,1,60,1,60,1,60,1,60,1,60,1,60,1,60,1,60,5,60,690,
		8,60,10,60,12,60,693,9,60,1,61,1,61,1,61,1,61,1,61,1,61,1,61,1,61,1,61,
		1,61,1,61,1,61,5,61,707,8,61,10,61,12,61,710,9,61,1,62,1,62,1,62,1,62,
		1,62,1,62,3,62,718,8,62,1,63,1,63,1,64,1,64,1,64,1,64,1,64,1,64,1,64,1,
		64,1,64,1,64,1,64,1,64,1,64,1,64,1,64,3,64,737,8,64,1,65,1,65,1,65,1,65,
		1,65,1,65,5,65,745,8,65,10,65,12,65,748,9,65,1,66,1,66,1,66,1,66,1,66,
		1,66,1,66,1,66,1,66,1,66,1,66,1,66,1,66,1,66,1,66,1,66,1,66,1,66,1,66,
		1,66,1,66,1,66,1,66,1,66,1,66,1,66,5,66,776,8,66,10,66,12,66,779,9,66,
		1,67,1,67,1,67,1,67,1,67,1,67,1,67,3,67,788,8,67,1,67,0,21,2,12,42,44,
		48,56,60,64,70,78,82,96,104,112,114,116,118,120,122,130,132,68,0,2,4,6,
		8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52,54,
		56,58,60,62,64,66,68,70,72,74,76,78,80,82,84,86,88,90,92,94,96,98,100,
		102,104,106,108,110,112,114,116,118,120,122,124,126,128,130,132,134,0,
		3,1,0,12,16,2,0,43,43,69,73,4,0,46,46,48,49,56,56,60,60,835,0,137,1,0,
		0,0,2,144,1,0,0,0,4,161,1,0,0,0,6,169,1,0,0,0,8,171,1,0,0,0,10,175,1,0,
		0,0,12,182,1,0,0,0,14,192,1,0,0,0,16,196,1,0,0,0,18,199,1,0,0,0,20,203,
		1,0,0,0,22,206,1,0,0,0,24,211,1,0,0,0,26,216,1,0,0,0,28,221,1,0,0,0,30,
		225,1,0,0,0,32,243,1,0,0,0,34,255,1,0,0,0,36,292,1,0,0,0,38,314,1,0,0,
		0,40,320,1,0,0,0,42,322,1,0,0,0,44,332,1,0,0,0,46,342,1,0,0,0,48,348,1,
		0,0,0,50,360,1,0,0,0,52,373,1,0,0,0,54,381,1,0,0,0,56,383,1,0,0,0,58,404,
		1,0,0,0,60,406,1,0,0,0,62,421,1,0,0,0,64,423,1,0,0,0,66,434,1,0,0,0,68,
		445,1,0,0,0,70,453,1,0,0,0,72,485,1,0,0,0,74,494,1,0,0,0,76,504,1,0,0,
		0,78,506,1,0,0,0,80,516,1,0,0,0,82,520,1,0,0,0,84,531,1,0,0,0,86,533,1,
		0,0,0,88,547,1,0,0,0,90,549,1,0,0,0,92,551,1,0,0,0,94,564,1,0,0,0,96,566,
		1,0,0,0,98,582,1,0,0,0,100,591,1,0,0,0,102,593,1,0,0,0,104,595,1,0,0,0,
		106,606,1,0,0,0,108,613,1,0,0,0,110,622,1,0,0,0,112,624,1,0,0,0,114,635,
		1,0,0,0,116,646,1,0,0,0,118,660,1,0,0,0,120,680,1,0,0,0,122,694,1,0,0,
		0,124,717,1,0,0,0,126,719,1,0,0,0,128,736,1,0,0,0,130,738,1,0,0,0,132,
		749,1,0,0,0,134,787,1,0,0,0,136,138,3,2,1,0,137,136,1,0,0,0,137,138,1,
		0,0,0,138,139,1,0,0,0,139,140,5,0,0,1,140,1,1,0,0,0,141,142,6,1,-1,0,142,
		145,3,4,2,0,143,145,3,30,15,0,144,141,1,0,0,0,144,143,1,0,0,0,145,152,
		1,0,0,0,146,147,10,2,0,0,147,151,3,4,2,0,148,149,10,1,0,0,149,151,3,30,
		15,0,150,146,1,0,0,0,150,148,1,0,0,0,151,154,1,0,0,0,152,150,1,0,0,0,152,
		153,1,0,0,0,153,3,1,0,0,0,154,152,1,0,0,0,155,162,3,26,13,0,156,162,3,
		18,9,0,157,162,3,20,10,0,158,162,3,6,3,0,159,162,3,22,11,0,160,162,3,24,
		12,0,161,155,1,0,0,0,161,156,1,0,0,0,161,157,1,0,0,0,161,158,1,0,0,0,161,
		159,1,0,0,0,161,160,1,0,0,0,162,5,1,0,0,0,163,164,3,8,4,0,164,165,5,4,
		0,0,165,170,1,0,0,0,166,167,3,10,5,0,167,168,5,4,0,0,168,170,1,0,0,0,169,
		163,1,0,0,0,169,166,1,0,0,0,170,7,1,0,0,0,171,172,5,7,0,0,172,173,3,104,
		52,0,173,174,3,42,21,0,174,9,1,0,0,0,175,177,3,8,4,0,176,178,3,12,6,0,
		177,176,1,0,0,0,177,178,1,0,0,0,178,180,1,0,0,0,179,181,3,16,8,0,180,179,
		1,0,0,0,180,181,1,0,0,0,181,11,1,0,0,0,182,183,6,6,-1,0,183,184,3,14,7,
		0,184,189,1,0,0,0,185,186,10,1,0,0,186,188,3,14,7,0,187,185,1,0,0,0,188,
		191,1,0,0,0,189,187,1,0,0,0,189,190,1,0,0,0,190,13,1,0,0,0,191,189,1,0,
		0,0,192,193,5,8,0,0,193,194,3,104,52,0,194,195,3,42,21,0,195,15,1,0,0,
		0,196,197,5,9,0,0,197,198,3,42,21,0,198,17,1,0,0,0,199,200,5,2,0,0,200,
		201,5,74,0,0,201,202,5,75,0,0,202,19,1,0,0,0,203,204,5,5,0,0,204,205,5,
		74,0,0,205,21,1,0,0,0,206,207,5,6,0,0,207,208,5,74,0,0,208,209,3,42,21,
		0,209,210,5,4,0,0,210,23,1,0,0,0,211,212,5,3,0,0,212,213,5,74,0,0,213,
		214,3,42,21,0,214,215,5,4,0,0,215,25,1,0,0,0,216,217,5,1,0,0,217,218,5,
		39,0,0,218,219,3,28,14,0,219,220,5,40,0,0,220,27,1,0,0,0,221,222,5,78,
		0,0,222,29,1,0,0,0,223,226,3,32,16,0,224,226,3,100,50,0,225,223,1,0,0,
		0,225,224,1,0,0,0,226,31,1,0,0,0,227,228,3,94,47,0,228,229,3,72,36,0,229,
		230,3,44,22,0,230,231,3,46,23,0,231,244,1,0,0,0,232,233,3,94,47,0,233,
		234,3,72,36,0,234,235,3,46,23,0,235,244,1,0,0,0,236,237,3,72,36,0,237,
		238,3,44,22,0,238,239,3,46,23,0,239,244,1,0,0,0,240,241,3,72,36,0,241,
		242,3,46,23,0,242,244,1,0,0,0,243,227,1,0,0,0,243,232,1,0,0,0,243,236,
		1,0,0,0,243,240,1,0,0,0,244,33,1,0,0,0,245,246,5,36,0,0,246,256,5,41,0,
		0,247,248,5,37,0,0,248,256,5,41,0,0,249,250,5,28,0,0,250,256,5,41,0,0,
		251,252,5,28,0,0,252,253,3,104,52,0,253,254,5,41,0,0,254,256,1,0,0,0,255,
		245,1,0,0,0,255,247,1,0,0,0,255,249,1,0,0,0,255,251,1,0,0,0,256,35,1,0,
		0,0,257,258,5,33,0,0,258,259,5,50,0,0,259,260,3,104,52,0,260,261,5,51,
		0,0,261,262,3,54,27,0,262,293,1,0,0,0,263,264,5,38,0,0,264,265,3,54,27,
		0,265,266,5,33,0,0,266,267,5,50,0,0,267,268,3,104,52,0,268,269,5,51,0,
		0,269,270,5,41,0,0,270,293,1,0,0,0,271,272,5,32,0,0,272,275,5,50,0,0,273,
		276,3,40,20,0,274,276,3,100,50,0,275,273,1,0,0,0,275,274,1,0,0,0,276,277,
		1,0,0,0,277,278,3,40,20,0,278,279,5,51,0,0,279,280,3,54,27,0,280,293,1,
		0,0,0,281,282,5,32,0,0,282,285,5,50,0,0,283,286,3,40,20,0,284,286,3,100,
		50,0,285,283,1,0,0,0,285,284,1,0,0,0,286,287,1,0,0,0,287,288,3,40,20,0,
		288,289,3,104,52,0,289,290,5,51,0,0,290,291,3,54,27,0,291,293,1,0,0,0,
		292,257,1,0,0,0,292,263,1,0,0,0,292,271,1,0,0,0,292,281,1,0,0,0,293,37,
		1,0,0,0,294,295,5,29,0,0,295,296,5,50,0,0,296,297,3,104,52,0,297,298,5,
		51,0,0,298,299,3,54,27,0,299,315,1,0,0,0,300,301,5,29,0,0,301,302,5,50,
		0,0,302,303,3,104,52,0,303,304,5,51,0,0,304,305,3,54,27,0,305,306,5,30,
		0,0,306,307,3,54,27,0,307,315,1,0,0,0,308,309,5,31,0,0,309,310,5,50,0,
		0,310,311,3,104,52,0,311,312,5,51,0,0,312,313,3,54,27,0,313,315,1,0,0,
		0,314,294,1,0,0,0,314,300,1,0,0,0,314,308,1,0,0,0,315,39,1,0,0,0,316,321,
		5,41,0,0,317,318,3,104,52,0,318,319,5,41,0,0,319,321,1,0,0,0,320,316,1,
		0,0,0,320,317,1,0,0,0,321,41,1,0,0,0,322,323,6,21,-1,0,323,324,3,54,27,
		0,324,329,1,0,0,0,325,326,10,1,0,0,326,328,3,54,27,0,327,325,1,0,0,0,328,
		331,1,0,0,0,329,327,1,0,0,0,329,330,1,0,0,0,330,43,1,0,0,0,331,329,1,0,
		0,0,332,333,6,22,-1,0,333,334,3,100,50,0,334,339,1,0,0,0,335,336,10,1,
		0,0,336,338,3,100,50,0,337,335,1,0,0,0,338,341,1,0,0,0,339,337,1,0,0,0,
		339,340,1,0,0,0,340,45,1,0,0,0,341,339,1,0,0,0,342,344,5,52,0,0,343,345,
		3,48,24,0,344,343,1,0,0,0,344,345,1,0,0,0,345,346,1,0,0,0,346,347,5,53,
		0,0,347,47,1,0,0,0,348,349,6,24,-1,0,349,350,3,50,25,0,350,355,1,0,0,0,
		351,352,10,1,0,0,352,354,3,50,25,0,353,351,1,0,0,0,354,357,1,0,0,0,355,
		353,1,0,0,0,355,356,1,0,0,0,356,49,1,0,0,0,357,355,1,0,0,0,358,361,3,42,
		21,0,359,361,3,44,22,0,360,358,1,0,0,0,360,359,1,0,0,0,361,51,1,0,0,0,
		362,363,5,74,0,0,363,364,5,45,0,0,364,374,3,54,27,0,365,366,5,34,0,0,366,
		367,3,102,51,0,367,368,5,45,0,0,368,369,3,54,27,0,369,374,1,0,0,0,370,
		371,5,35,0,0,371,372,5,45,0,0,372,374,3,54,27,0,373,362,1,0,0,0,373,365,
		1,0,0,0,373,370,1,0,0,0,374,53,1,0,0,0,375,382,3,52,26,0,376,382,3,46,
		23,0,377,382,3,40,20,0,378,382,3,38,19,0,379,382,3,36,18,0,380,382,3,34,
		17,0,381,375,1,0,0,0,381,376,1,0,0,0,381,377,1,0,0,0,381,378,1,0,0,0,381,
		379,1,0,0,0,381,380,1,0,0,0,382,55,1,0,0,0,383,384,6,28,-1,0,384,385,3,
		58,29,0,385,391,1,0,0,0,386,387,10,1,0,0,387,388,5,42,0,0,388,390,3,58,
		29,0,389,386,1,0,0,0,390,393,1,0,0,0,391,389,1,0,0,0,391,392,1,0,0,0,392,
		57,1,0,0,0,393,391,1,0,0,0,394,405,3,108,54,0,395,396,5,52,0,0,396,397,
		3,56,28,0,397,398,5,53,0,0,398,405,1,0,0,0,399,400,5,52,0,0,400,401,3,
		56,28,0,401,402,5,42,0,0,402,403,5,53,0,0,403,405,1,0,0,0,404,394,1,0,
		0,0,404,395,1,0,0,0,404,399,1,0,0,0,405,59,1,0,0,0,406,407,6,30,-1,0,407,
		408,5,74,0,0,408,414,1,0,0,0,409,410,10,1,0,0,410,411,5,42,0,0,411,413,
		5,74,0,0,412,409,1,0,0,0,413,416,1,0,0,0,414,412,1,0,0,0,414,415,1,0,0,
		0,415,61,1,0,0,0,416,414,1,0,0,0,417,418,3,94,47,0,418,419,3,72,36,0,419,
		422,1,0,0,0,420,422,3,94,47,0,421,417,1,0,0,0,421,420,1,0,0,0,422,63,1,
		0,0,0,423,424,6,32,-1,0,424,425,3,62,31,0,425,431,1,0,0,0,426,427,10,1,
		0,0,427,428,5,42,0,0,428,430,3,62,31,0,429,426,1,0,0,0,430,433,1,0,0,0,
		431,429,1,0,0,0,431,432,1,0,0,0,432,65,1,0,0,0,433,431,1,0,0,0,434,435,
		5,10,0,0,435,67,1,0,0,0,436,446,5,46,0,0,437,438,5,46,0,0,438,446,3,66,
		33,0,439,440,5,46,0,0,440,446,3,68,34,0,441,442,5,46,0,0,442,443,3,66,
		33,0,443,444,3,68,34,0,444,446,1,0,0,0,445,436,1,0,0,0,445,437,1,0,0,0,
		445,439,1,0,0,0,445,441,1,0,0,0,446,69,1,0,0,0,447,448,6,35,-1,0,448,454,
		5,74,0,0,449,450,5,50,0,0,450,451,3,72,36,0,451,452,5,51,0,0,452,454,1,
		0,0,0,453,447,1,0,0,0,453,449,1,0,0,0,454,478,1,0,0,0,455,456,10,5,0,0,
		456,457,5,54,0,0,457,458,3,102,51,0,458,459,5,55,0,0,459,477,1,0,0,0,460,
		461,10,4,0,0,461,462,5,54,0,0,462,477,5,55,0,0,463,464,10,3,0,0,464,465,
		5,50,0,0,465,466,3,64,32,0,466,467,5,51,0,0,467,477,1,0,0,0,468,469,10,
		2,0,0,469,470,5,50,0,0,470,471,3,60,30,0,471,472,5,51,0,0,472,477,1,0,
		0,0,473,474,10,1,0,0,474,475,5,50,0,0,475,477,5,51,0,0,476,455,1,0,0,0,
		476,460,1,0,0,0,476,463,1,0,0,0,476,468,1,0,0,0,476,473,1,0,0,0,477,480,
		1,0,0,0,478,476,1,0,0,0,478,479,1,0,0,0,479,71,1,0,0,0,480,478,1,0,0,0,
		481,482,3,68,34,0,482,483,3,70,35,0,483,486,1,0,0,0,484,486,3,70,35,0,
		485,481,1,0,0,0,485,484,1,0,0,0,486,73,1,0,0,0,487,488,3,88,44,0,488,489,
		3,74,37,0,489,495,1,0,0,0,490,495,3,88,44,0,491,492,5,10,0,0,492,495,3,
		74,37,0,493,495,5,10,0,0,494,487,1,0,0,0,494,490,1,0,0,0,494,491,1,0,0,
		0,494,493,1,0,0,0,495,75,1,0,0,0,496,497,5,11,0,0,497,498,5,74,0,0,498,
		499,5,52,0,0,499,500,3,78,39,0,500,501,5,53,0,0,501,505,1,0,0,0,502,503,
		5,11,0,0,503,505,5,74,0,0,504,496,1,0,0,0,504,502,1,0,0,0,505,77,1,0,0,
		0,506,507,6,39,-1,0,507,508,3,80,40,0,508,513,1,0,0,0,509,510,10,1,0,0,
		510,512,3,80,40,0,511,509,1,0,0,0,512,515,1,0,0,0,513,511,1,0,0,0,513,
		514,1,0,0,0,514,79,1,0,0,0,515,513,1,0,0,0,516,517,3,74,37,0,517,518,3,
		82,41,0,518,519,5,41,0,0,519,81,1,0,0,0,520,521,6,41,-1,0,521,522,3,84,
		42,0,522,528,1,0,0,0,523,524,10,1,0,0,524,525,5,42,0,0,525,527,3,84,42,
		0,526,523,1,0,0,0,527,530,1,0,0,0,528,526,1,0,0,0,528,529,1,0,0,0,529,
		83,1,0,0,0,530,528,1,0,0,0,531,532,3,72,36,0,532,85,1,0,0,0,533,534,7,
		0,0,0,534,87,1,0,0,0,535,548,5,18,0,0,536,548,5,19,0,0,537,548,5,20,0,
		0,538,548,5,21,0,0,539,548,5,22,0,0,540,548,5,23,0,0,541,548,5,24,0,0,
		542,548,5,25,0,0,543,548,5,26,0,0,544,548,5,27,0,0,545,548,3,76,38,0,546,
		548,3,90,45,0,547,535,1,0,0,0,547,536,1,0,0,0,547,537,1,0,0,0,547,538,
		1,0,0,0,547,539,1,0,0,0,547,540,1,0,0,0,547,541,1,0,0,0,547,542,1,0,0,
		0,547,543,1,0,0,0,547,544,1,0,0,0,547,545,1,0,0,0,547,546,1,0,0,0,548,
		89,1,0,0,0,549,550,5,74,0,0,550,91,1,0,0,0,551,552,3,74,37,0,552,93,1,
		0,0,0,553,565,3,86,43,0,554,555,3,86,43,0,555,556,3,94,47,0,556,565,1,
		0,0,0,557,565,3,88,44,0,558,559,3,88,44,0,559,560,3,94,47,0,560,565,1,
		0,0,0,561,565,5,10,0,0,562,563,5,10,0,0,563,565,3,94,47,0,564,553,1,0,
		0,0,564,554,1,0,0,0,564,557,1,0,0,0,564,558,1,0,0,0,564,561,1,0,0,0,564,
		562,1,0,0,0,565,95,1,0,0,0,566,567,6,48,-1,0,567,568,3,98,49,0,568,574,
		1,0,0,0,569,570,10,1,0,0,570,571,5,42,0,0,571,573,3,98,49,0,572,569,1,
		0,0,0,573,576,1,0,0,0,574,572,1,0,0,0,574,575,1,0,0,0,575,97,1,0,0,0,576,
		574,1,0,0,0,577,583,3,72,36,0,578,579,3,72,36,0,579,580,5,43,0,0,580,581,
		3,58,29,0,581,583,1,0,0,0,582,577,1,0,0,0,582,578,1,0,0,0,583,99,1,0,0,
		0,584,585,3,94,47,0,585,586,5,41,0,0,586,592,1,0,0,0,587,588,3,94,47,0,
		588,589,3,96,48,0,589,590,5,41,0,0,590,592,1,0,0,0,591,584,1,0,0,0,591,
		587,1,0,0,0,592,101,1,0,0,0,593,594,3,110,55,0,594,103,1,0,0,0,595,596,
		6,52,-1,0,596,597,3,108,54,0,597,603,1,0,0,0,598,599,10,1,0,0,599,600,
		5,42,0,0,600,602,3,108,54,0,601,598,1,0,0,0,602,605,1,0,0,0,603,601,1,
		0,0,0,603,604,1,0,0,0,604,105,1,0,0,0,605,603,1,0,0,0,606,607,7,1,0,0,
		607,107,1,0,0,0,608,614,3,110,55,0,609,610,3,128,64,0,610,611,3,106,53,
		0,611,612,3,108,54,0,612,614,1,0,0,0,613,608,1,0,0,0,613,609,1,0,0,0,614,
		109,1,0,0,0,615,623,3,112,56,0,616,617,3,112,56,0,617,618,5,44,0,0,618,
		619,3,104,52,0,619,620,5,45,0,0,620,621,3,110,55,0,621,623,1,0,0,0,622,
		615,1,0,0,0,622,616,1,0,0,0,623,111,1,0,0,0,624,625,6,56,-1,0,625,626,
		3,114,57,0,626,632,1,0,0,0,627,628,10,1,0,0,628,629,5,63,0,0,629,631,3,
		114,57,0,630,627,1,0,0,0,631,634,1,0,0,0,632,630,1,0,0,0,632,633,1,0,0,
		0,633,113,1,0,0,0,634,632,1,0,0,0,635,636,6,57,-1,0,636,637,3,116,58,0,
		637,643,1,0,0,0,638,639,10,1,0,0,639,640,5,64,0,0,640,642,3,116,58,0,641,
		638,1,0,0,0,642,645,1,0,0,0,643,641,1,0,0,0,643,644,1,0,0,0,644,115,1,
		0,0,0,645,643,1,0,0,0,646,647,6,58,-1,0,647,648,3,118,59,0,648,657,1,0,
		0,0,649,650,10,2,0,0,650,651,5,66,0,0,651,656,3,118,59,0,652,653,10,1,
		0,0,653,654,5,65,0,0,654,656,3,118,59,0,655,649,1,0,0,0,655,652,1,0,0,
		0,656,659,1,0,0,0,657,655,1,0,0,0,657,658,1,0,0,0,658,117,1,0,0,0,659,
		657,1,0,0,0,660,661,6,59,-1,0,661,662,3,120,60,0,662,677,1,0,0,0,663,664,
		10,4,0,0,664,665,5,39,0,0,665,676,3,120,60,0,666,667,10,3,0,0,667,668,
		5,40,0,0,668,676,3,120,60,0,669,670,10,2,0,0,670,671,5,68,0,0,671,676,
		3,120,60,0,672,673,10,1,0,0,673,674,5,67,0,0,674,676,3,120,60,0,675,663,
		1,0,0,0,675,666,1,0,0,0,675,669,1,0,0,0,675,672,1,0,0,0,676,679,1,0,0,
		0,677,675,1,0,0,0,677,678,1,0,0,0,678,119,1,0,0,0,679,677,1,0,0,0,680,
		681,6,60,-1,0,681,682,3,122,61,0,682,691,1,0,0,0,683,684,10,2,0,0,684,
		685,5,48,0,0,685,690,3,122,61,0,686,687,10,1,0,0,687,688,5,49,0,0,688,
		690,3,122,61,0,689,683,1,0,0,0,689,686,1,0,0,0,690,693,1,0,0,0,691,689,
		1,0,0,0,691,692,1,0,0,0,692,121,1,0,0,0,693,691,1,0,0,0,694,695,6,61,-1,
		0,695,696,3,124,62,0,696,708,1,0,0,0,697,698,10,3,0,0,698,699,5,46,0,0,
		699,707,3,124,62,0,700,701,10,2,0,0,701,702,5,47,0,0,702,707,3,124,62,
		0,703,704,10,1,0,0,704,705,5,57,0,0,705,707,3,124,62,0,706,697,1,0,0,0,
		706,700,1,0,0,0,706,703,1,0,0,0,707,710,1,0,0,0,708,706,1,0,0,0,708,709,
		1,0,0,0,709,123,1,0,0,0,710,708,1,0,0,0,711,718,3,128,64,0,712,713,5,50,
		0,0,713,714,3,92,46,0,714,715,5,51,0,0,715,716,3,124,62,0,716,718,1,0,
		0,0,717,711,1,0,0,0,717,712,1,0,0,0,718,125,1,0,0,0,719,720,7,2,0,0,720,
		127,1,0,0,0,721,737,3,132,66,0,722,723,5,62,0,0,723,737,3,128,64,0,724,
		725,5,61,0,0,725,737,3,128,64,0,726,727,3,126,63,0,727,728,3,124,62,0,
		728,737,1,0,0,0,729,730,5,17,0,0,730,737,3,128,64,0,731,732,5,17,0,0,732,
		733,5,50,0,0,733,734,3,92,46,0,734,735,5,51,0,0,735,737,1,0,0,0,736,721,
		1,0,0,0,736,722,1,0,0,0,736,724,1,0,0,0,736,726,1,0,0,0,736,729,1,0,0,
		0,736,731,1,0,0,0,737,129,1,0,0,0,738,739,6,65,-1,0,739,740,3,108,54,0,
		740,746,1,0,0,0,741,742,10,1,0,0,742,743,5,42,0,0,743,745,3,108,54,0,744,
		741,1,0,0,0,745,748,1,0,0,0,746,744,1,0,0,0,746,747,1,0,0,0,747,131,1,
		0,0,0,748,746,1,0,0,0,749,750,6,66,-1,0,750,751,3,134,67,0,751,777,1,0,
		0,0,752,753,10,7,0,0,753,754,5,54,0,0,754,755,3,104,52,0,755,756,5,55,
		0,0,756,776,1,0,0,0,757,758,10,6,0,0,758,759,5,50,0,0,759,776,5,51,0,0,
		760,761,10,5,0,0,761,762,5,50,0,0,762,763,3,130,65,0,763,764,5,51,0,0,
		764,776,1,0,0,0,765,766,10,4,0,0,766,767,5,59,0,0,767,776,5,74,0,0,768,
		769,10,3,0,0,769,770,5,58,0,0,770,776,5,74,0,0,771,772,10,2,0,0,772,776,
		5,62,0,0,773,774,10,1,0,0,774,776,5,61,0,0,775,752,1,0,0,0,775,757,1,0,
		0,0,775,760,1,0,0,0,775,765,1,0,0,0,775,768,1,0,0,0,775,771,1,0,0,0,775,
		773,1,0,0,0,776,779,1,0,0,0,777,775,1,0,0,0,777,778,1,0,0,0,778,133,1,
		0,0,0,779,777,1,0,0,0,780,788,5,74,0,0,781,788,5,75,0,0,782,788,5,77,0,
		0,783,784,5,50,0,0,784,785,3,104,52,0,785,786,5,51,0,0,786,788,1,0,0,0,
		787,780,1,0,0,0,787,781,1,0,0,0,787,782,1,0,0,0,787,783,1,0,0,0,788,135,
		1,0,0,0,62,137,144,150,152,161,169,177,180,189,225,243,255,275,285,292,
		314,320,329,339,344,355,360,373,381,391,404,414,421,431,445,453,476,478,
		485,494,504,513,528,547,564,574,582,591,603,613,622,632,643,655,657,675,
		677,689,691,706,708,717,736,746,775,777,787
	};

	public static readonly ATN _ATN =
		new ATNDeserializer().Deserialize(_serializedATN);


}
} // namespace CGrammar
