//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ANTLR Version: 4.13.1
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// Generated from C:/Users/kacpe/OneDrive/Pulpit/Kompilatory/ProjektTKiK/Grammars/C_Grammar.g4 by ANTLR 4.13.1

// Unreachable code detected
#pragma warning disable 0162
// The variable '...' is assigned but its value is never used
#pragma warning disable 0219
// Missing XML comment for publicly visible type or member '...'
#pragma warning disable 1591
// Ambiguous reference in cref attribute
#pragma warning disable 419

namespace CGrammar {
using System;
using System.IO;
using System.Text;
using System.Diagnostics;
using System.Collections.Generic;
using Antlr4.Runtime;
using Antlr4.Runtime.Atn;
using Antlr4.Runtime.Misc;
using Antlr4.Runtime.Tree;
using DFA = Antlr4.Runtime.Dfa.DFA;

[System.CodeDom.Compiler.GeneratedCode("ANTLR", "4.13.1")]
[System.CLSCompliant(false)]
public partial class C_GrammarParser : Parser {
	protected static DFA[] decisionToDFA;
	protected static PredictionContextCache sharedContextCache = new PredictionContextCache();
	public const int
		Hash_Include=1, Hash_Define=2, Hash_ifndef=3, Hash_endif=4, Hash_undef=5, 
		Hash_ifdef=6, Hash_if=7, Hash_elif=8, Hash_else=9, Const=10, Struct=11, 
		Typedef=12, Auto=13, Extern=14, Static=15, Register=16, Sizeof=17, Void=18, 
		Char=19, Short=20, Int=21, Long=22, Float=23, Double=24, Signed=25, Unsigned=26, 
		Bool=27, Return=28, If=29, Else=30, Switch=31, For=32, While=33, Case=34, 
		Default=35, Continue=36, Break=37, Do=38, Less=39, Greater=40, Semicolon=41, 
		Comma=42, Assign=43, QuestionMark=44, Colon=45, Multiply=46, Divide=47, 
		Plus=48, Minus=49, LeftParen=50, RightParen=51, LeftBrace=52, RightBrace=53, 
		LeftBracket=54, RightBracket=55, Ampersand=56, Mod=57, Arrow=58, Dot=59, 
		Exclamation=60, DecOp=61, IncOp=62, OrOp=63, AndOp=64, NeOp=65, EqOp=66, 
		GeOp=67, LeOp=68, AddAssign=69, SubAssign=70, MulAssign=71, DivAssign=72, 
		ModAssign=73, Identifier=74, Constant=75, DigitSequence=76, StringLiteral=77, 
		LibraryName=78, Whitespace=79, Newline=80, BlockComment=81, LineComment=82;
	public const int
		RULE_start = 0, RULE_translationUnit = 1, RULE_hashStatement = 2, RULE_undefStatement = 3, 
		RULE_ifdefStatement = 4, RULE_ifStatement = 5, RULE_elifStatement = 6, 
		RULE_elseStatement = 7, RULE_ifndefStatement = 8, RULE_endIfStatement = 9, 
		RULE_defineStatement = 10, RULE_includeStatement = 11, RULE_libraryName = 12, 
		RULE_externalDeclaration = 13, RULE_functionDefinition = 14, RULE_jumpStatement = 15, 
		RULE_iterationStatement = 16, RULE_selectionStatement = 17, RULE_expressionStatement = 18, 
		RULE_statementList = 19, RULE_declarationList = 20, RULE_compoundStatement = 21, 
		RULE_blockItemList = 22, RULE_blockItem = 23, RULE_labeledStatement = 24, 
		RULE_statement = 25, RULE_initializerList = 26, RULE_initializer = 27, 
		RULE_directAbstractDeclarator = 28, RULE_abstractDeclarator = 29, RULE_identifierList = 30, 
		RULE_parameterDeclaration = 31, RULE_parameterList = 32, RULE_typeQualifierList = 33, 
		RULE_pointer = 34, RULE_directDeclarator = 35, RULE_declarator = 36, RULE_specifierQualifierList = 37, 
		RULE_structSpecifier = 38, RULE_structDeclarationList = 39, RULE_structDeclaration = 40, 
		RULE_structDeclaratorList = 41, RULE_structDeclarator = 42, RULE_storageClassSpecifier = 43, 
		RULE_typeSpecifier = 44, RULE_typeNameIdentifier = 45, RULE_typeName = 46, 
		RULE_declarationSpecifiers = 47, RULE_initDeclaratorList = 48, RULE_initDeclarator = 49, 
		RULE_declaration = 50, RULE_constantExpression = 51, RULE_expression = 52, 
		RULE_assignmentOperator = 53, RULE_assignmentExpression = 54, RULE_conditionalExpression = 55, 
		RULE_logicalOrExpression = 56, RULE_logicalAndExpression = 57, RULE_equalityExpression = 58, 
		RULE_relationalExpression = 59, RULE_additiveExpression = 60, RULE_multiplicativeExpression = 61, 
		RULE_castExpression = 62, RULE_unaryOperator = 63, RULE_unaryExpression = 64, 
		RULE_argumentExpressionList = 65, RULE_postfixExpression = 66, RULE_primaryExpression = 67;
	public static readonly string[] ruleNames = {
		"start", "translationUnit", "hashStatement", "undefStatement", "ifdefStatement", 
		"ifStatement", "elifStatement", "elseStatement", "ifndefStatement", "endIfStatement", 
		"defineStatement", "includeStatement", "libraryName", "externalDeclaration", 
		"functionDefinition", "jumpStatement", "iterationStatement", "selectionStatement", 
		"expressionStatement", "statementList", "declarationList", "compoundStatement", 
		"blockItemList", "blockItem", "labeledStatement", "statement", "initializerList", 
		"initializer", "directAbstractDeclarator", "abstractDeclarator", "identifierList", 
		"parameterDeclaration", "parameterList", "typeQualifierList", "pointer", 
		"directDeclarator", "declarator", "specifierQualifierList", "structSpecifier", 
		"structDeclarationList", "structDeclaration", "structDeclaratorList", 
		"structDeclarator", "storageClassSpecifier", "typeSpecifier", "typeNameIdentifier", 
		"typeName", "declarationSpecifiers", "initDeclaratorList", "initDeclarator", 
		"declaration", "constantExpression", "expression", "assignmentOperator", 
		"assignmentExpression", "conditionalExpression", "logicalOrExpression", 
		"logicalAndExpression", "equalityExpression", "relationalExpression", 
		"additiveExpression", "multiplicativeExpression", "castExpression", "unaryOperator", 
		"unaryExpression", "argumentExpressionList", "postfixExpression", "primaryExpression"
	};

	private static readonly string[] _LiteralNames = {
		null, "'#include'", null, "'#ifndef'", "'#endif'", "'#undef'", "'#ifdef'", 
		"'#if'", "'#elif'", "'#else'", "'const'", "'struct'", "'typedef'", "'auto'", 
		"'extern'", "'static'", "'register'", "'sizeof'", "'void'", "'char'", 
		"'short'", "'int'", "'long'", "'float'", "'double'", "'signed'", "'unsigned'", 
		"'bool'", "'return'", "'if'", "'else'", "'switch'", "'for'", "'while'", 
		"'case'", "'default'", "'continue'", "'break'", "'do'", "'<'", "'>'", 
		"';'", "','", "'='", "'?'", "':'", "'*'", "'/'", "'+'", "'-'", "'('", 
		"')'", "'{'", "'}'", "'['", "']'", "'&'", "'%'", "'->'", "'.'", "'!'", 
		"'--'", "'++'", "'||'", "'&&'", "'!='", "'=='", "'>='", "'<='", "'+='", 
		"'-='", "'*='", "'/='", "'%='"
	};
	private static readonly string[] _SymbolicNames = {
		null, "Hash_Include", "Hash_Define", "Hash_ifndef", "Hash_endif", "Hash_undef", 
		"Hash_ifdef", "Hash_if", "Hash_elif", "Hash_else", "Const", "Struct", 
		"Typedef", "Auto", "Extern", "Static", "Register", "Sizeof", "Void", "Char", 
		"Short", "Int", "Long", "Float", "Double", "Signed", "Unsigned", "Bool", 
		"Return", "If", "Else", "Switch", "For", "While", "Case", "Default", "Continue", 
		"Break", "Do", "Less", "Greater", "Semicolon", "Comma", "Assign", "QuestionMark", 
		"Colon", "Multiply", "Divide", "Plus", "Minus", "LeftParen", "RightParen", 
		"LeftBrace", "RightBrace", "LeftBracket", "RightBracket", "Ampersand", 
		"Mod", "Arrow", "Dot", "Exclamation", "DecOp", "IncOp", "OrOp", "AndOp", 
		"NeOp", "EqOp", "GeOp", "LeOp", "AddAssign", "SubAssign", "MulAssign", 
		"DivAssign", "ModAssign", "Identifier", "Constant", "DigitSequence", "StringLiteral", 
		"LibraryName", "Whitespace", "Newline", "BlockComment", "LineComment"
	};
	public static readonly IVocabulary DefaultVocabulary = new Vocabulary(_LiteralNames, _SymbolicNames);

	[NotNull]
	public override IVocabulary Vocabulary
	{
		get
		{
			return DefaultVocabulary;
		}
	}

	public override string GrammarFileName { get { return "C_Grammar.g4"; } }

	public override string[] RuleNames { get { return ruleNames; } }

	public override int[] SerializedAtn { get { return _serializedATN; } }

	static C_GrammarParser() {
		decisionToDFA = new DFA[_ATN.NumberOfDecisions];
		for (int i = 0; i < _ATN.NumberOfDecisions; i++) {
			decisionToDFA[i] = new DFA(_ATN.GetDecisionState(i), i);
		}
	}

		public C_GrammarParser(ITokenStream input) : this(input, Console.Out, Console.Error) { }

		public C_GrammarParser(ITokenStream input, TextWriter output, TextWriter errorOutput)
		: base(input, output, errorOutput)
	{
		Interpreter = new ParserATNSimulator(this, _ATN, decisionToDFA, sharedContextCache);
	}

	public partial class StartContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Eof() { return GetToken(C_GrammarParser.Eof, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public TranslationUnitContext translationUnit() {
			return GetRuleContext<TranslationUnitContext>(0);
		}
		public StartContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_start; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.EnterStart(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.ExitStart(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IC_GrammarVisitor<TResult> typedVisitor = visitor as IC_GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitStart(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public StartContext start() {
		StartContext _localctx = new StartContext(Context, State);
		EnterRule(_localctx, 0, RULE_start);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 137;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if ((((_la) & ~0x3f) == 0 && ((1L << _la) & 1196268919324670L) != 0) || _la==Identifier) {
				{
				State = 136;
				translationUnit(0);
				}
			}

			State = 139;
			Match(Eof);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TranslationUnitContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public HashStatementContext hashStatement() {
			return GetRuleContext<HashStatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ExternalDeclarationContext externalDeclaration() {
			return GetRuleContext<ExternalDeclarationContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public TranslationUnitContext translationUnit() {
			return GetRuleContext<TranslationUnitContext>(0);
		}
		public TranslationUnitContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_translationUnit; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.EnterTranslationUnit(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.ExitTranslationUnit(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IC_GrammarVisitor<TResult> typedVisitor = visitor as IC_GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTranslationUnit(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public TranslationUnitContext translationUnit() {
		return translationUnit(0);
	}

	private TranslationUnitContext translationUnit(int _p) {
		ParserRuleContext _parentctx = Context;
		int _parentState = State;
		TranslationUnitContext _localctx = new TranslationUnitContext(Context, _parentState);
		TranslationUnitContext _prevctx = _localctx;
		int _startState = 2;
		EnterRecursionRule(_localctx, 2, RULE_translationUnit, _p);
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 144;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case Hash_Include:
			case Hash_Define:
			case Hash_ifndef:
			case Hash_endif:
			case Hash_undef:
			case Hash_ifdef:
			case Hash_if:
			case Hash_elif:
			case Hash_else:
				{
				State = 142;
				hashStatement();
				}
				break;
			case Const:
			case Struct:
			case Typedef:
			case Auto:
			case Extern:
			case Static:
			case Register:
			case Void:
			case Char:
			case Short:
			case Int:
			case Long:
			case Float:
			case Double:
			case Signed:
			case Unsigned:
			case Bool:
			case Multiply:
			case LeftParen:
			case Identifier:
				{
				State = 143;
				externalDeclaration();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			Context.Stop = TokenStream.LT(-1);
			State = 152;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,3,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					if ( ParseListeners!=null )
						TriggerExitRuleEvent();
					_prevctx = _localctx;
					{
					State = 150;
					ErrorHandler.Sync(this);
					switch ( Interpreter.AdaptivePredict(TokenStream,2,Context) ) {
					case 1:
						{
						_localctx = new TranslationUnitContext(_parentctx, _parentState);
						PushNewRecursionContext(_localctx, _startState, RULE_translationUnit);
						State = 146;
						if (!(Precpred(Context, 2))) throw new FailedPredicateException(this, "Precpred(Context, 2)");
						State = 147;
						hashStatement();
						}
						break;
					case 2:
						{
						_localctx = new TranslationUnitContext(_parentctx, _parentState);
						PushNewRecursionContext(_localctx, _startState, RULE_translationUnit);
						State = 148;
						if (!(Precpred(Context, 1))) throw new FailedPredicateException(this, "Precpred(Context, 1)");
						State = 149;
						externalDeclaration();
						}
						break;
					}
					} 
				}
				State = 154;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,3,Context);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			UnrollRecursionContexts(_parentctx);
		}
		return _localctx;
	}

	public partial class HashStatementContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public IncludeStatementContext includeStatement() {
			return GetRuleContext<IncludeStatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public DefineStatementContext defineStatement() {
			return GetRuleContext<DefineStatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public UndefStatementContext undefStatement() {
			return GetRuleContext<UndefStatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public IfdefStatementContext ifdefStatement() {
			return GetRuleContext<IfdefStatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public IfndefStatementContext ifndefStatement() {
			return GetRuleContext<IfndefStatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public IfStatementContext ifStatement() {
			return GetRuleContext<IfStatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ElifStatementContext elifStatement() {
			return GetRuleContext<ElifStatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ElseStatementContext elseStatement() {
			return GetRuleContext<ElseStatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public EndIfStatementContext endIfStatement() {
			return GetRuleContext<EndIfStatementContext>(0);
		}
		public HashStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_hashStatement; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.EnterHashStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.ExitHashStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IC_GrammarVisitor<TResult> typedVisitor = visitor as IC_GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitHashStatement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public HashStatementContext hashStatement() {
		HashStatementContext _localctx = new HashStatementContext(Context, State);
		EnterRule(_localctx, 4, RULE_hashStatement);
		try {
			State = 164;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case Hash_Include:
				EnterOuterAlt(_localctx, 1);
				{
				State = 155;
				includeStatement();
				}
				break;
			case Hash_Define:
				EnterOuterAlt(_localctx, 2);
				{
				State = 156;
				defineStatement();
				}
				break;
			case Hash_undef:
				EnterOuterAlt(_localctx, 3);
				{
				State = 157;
				undefStatement();
				}
				break;
			case Hash_ifdef:
				EnterOuterAlt(_localctx, 4);
				{
				State = 158;
				ifdefStatement();
				}
				break;
			case Hash_ifndef:
				EnterOuterAlt(_localctx, 5);
				{
				State = 159;
				ifndefStatement();
				}
				break;
			case Hash_if:
				EnterOuterAlt(_localctx, 6);
				{
				State = 160;
				ifStatement();
				}
				break;
			case Hash_elif:
				EnterOuterAlt(_localctx, 7);
				{
				State = 161;
				elifStatement();
				}
				break;
			case Hash_else:
				EnterOuterAlt(_localctx, 8);
				{
				State = 162;
				elseStatement();
				}
				break;
			case Hash_endif:
				EnterOuterAlt(_localctx, 9);
				{
				State = 163;
				endIfStatement();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class UndefStatementContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Hash_undef() { return GetToken(C_GrammarParser.Hash_undef, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Identifier() { return GetToken(C_GrammarParser.Identifier, 0); }
		public UndefStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_undefStatement; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.EnterUndefStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.ExitUndefStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IC_GrammarVisitor<TResult> typedVisitor = visitor as IC_GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitUndefStatement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public UndefStatementContext undefStatement() {
		UndefStatementContext _localctx = new UndefStatementContext(Context, State);
		EnterRule(_localctx, 6, RULE_undefStatement);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 166;
			Match(Hash_undef);
			State = 167;
			Match(Identifier);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class IfdefStatementContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Hash_ifdef() { return GetToken(C_GrammarParser.Hash_ifdef, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Identifier() { return GetToken(C_GrammarParser.Identifier, 0); }
		public IfdefStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_ifdefStatement; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.EnterIfdefStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.ExitIfdefStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IC_GrammarVisitor<TResult> typedVisitor = visitor as IC_GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitIfdefStatement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public IfdefStatementContext ifdefStatement() {
		IfdefStatementContext _localctx = new IfdefStatementContext(Context, State);
		EnterRule(_localctx, 8, RULE_ifdefStatement);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 169;
			Match(Hash_ifdef);
			State = 170;
			Match(Identifier);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class IfStatementContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Hash_if() { return GetToken(C_GrammarParser.Hash_if, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public IfStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_ifStatement; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.EnterIfStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.ExitIfStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IC_GrammarVisitor<TResult> typedVisitor = visitor as IC_GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitIfStatement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public IfStatementContext ifStatement() {
		IfStatementContext _localctx = new IfStatementContext(Context, State);
		EnterRule(_localctx, 10, RULE_ifStatement);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 172;
			Match(Hash_if);
			State = 173;
			expression(0);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ElifStatementContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Hash_elif() { return GetToken(C_GrammarParser.Hash_elif, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public ElifStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_elifStatement; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.EnterElifStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.ExitElifStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IC_GrammarVisitor<TResult> typedVisitor = visitor as IC_GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitElifStatement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ElifStatementContext elifStatement() {
		ElifStatementContext _localctx = new ElifStatementContext(Context, State);
		EnterRule(_localctx, 12, RULE_elifStatement);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 175;
			Match(Hash_elif);
			State = 176;
			expression(0);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ElseStatementContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Hash_else() { return GetToken(C_GrammarParser.Hash_else, 0); }
		public ElseStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_elseStatement; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.EnterElseStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.ExitElseStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IC_GrammarVisitor<TResult> typedVisitor = visitor as IC_GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitElseStatement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ElseStatementContext elseStatement() {
		ElseStatementContext _localctx = new ElseStatementContext(Context, State);
		EnterRule(_localctx, 14, RULE_elseStatement);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 178;
			Match(Hash_else);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class IfndefStatementContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Hash_ifndef() { return GetToken(C_GrammarParser.Hash_ifndef, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Identifier() { return GetToken(C_GrammarParser.Identifier, 0); }
		public IfndefStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_ifndefStatement; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.EnterIfndefStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.ExitIfndefStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IC_GrammarVisitor<TResult> typedVisitor = visitor as IC_GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitIfndefStatement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public IfndefStatementContext ifndefStatement() {
		IfndefStatementContext _localctx = new IfndefStatementContext(Context, State);
		EnterRule(_localctx, 16, RULE_ifndefStatement);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 180;
			Match(Hash_ifndef);
			State = 181;
			Match(Identifier);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class EndIfStatementContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Hash_endif() { return GetToken(C_GrammarParser.Hash_endif, 0); }
		public EndIfStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_endIfStatement; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.EnterEndIfStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.ExitEndIfStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IC_GrammarVisitor<TResult> typedVisitor = visitor as IC_GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitEndIfStatement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public EndIfStatementContext endIfStatement() {
		EndIfStatementContext _localctx = new EndIfStatementContext(Context, State);
		EnterRule(_localctx, 18, RULE_endIfStatement);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 183;
			Match(Hash_endif);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class DefineStatementContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Hash_Define() { return GetToken(C_GrammarParser.Hash_Define, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Identifier() { return GetToken(C_GrammarParser.Identifier, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Constant() { return GetToken(C_GrammarParser.Constant, 0); }
		public DefineStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_defineStatement; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.EnterDefineStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.ExitDefineStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IC_GrammarVisitor<TResult> typedVisitor = visitor as IC_GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitDefineStatement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public DefineStatementContext defineStatement() {
		DefineStatementContext _localctx = new DefineStatementContext(Context, State);
		EnterRule(_localctx, 20, RULE_defineStatement);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 185;
			Match(Hash_Define);
			State = 186;
			Match(Identifier);
			State = 187;
			Match(Constant);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class IncludeStatementContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Hash_Include() { return GetToken(C_GrammarParser.Hash_Include, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Less() { return GetToken(C_GrammarParser.Less, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public LibraryNameContext libraryName() {
			return GetRuleContext<LibraryNameContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Greater() { return GetToken(C_GrammarParser.Greater, 0); }
		public IncludeStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_includeStatement; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.EnterIncludeStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.ExitIncludeStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IC_GrammarVisitor<TResult> typedVisitor = visitor as IC_GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitIncludeStatement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public IncludeStatementContext includeStatement() {
		IncludeStatementContext _localctx = new IncludeStatementContext(Context, State);
		EnterRule(_localctx, 22, RULE_includeStatement);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 189;
			Match(Hash_Include);
			State = 190;
			Match(Less);
			State = 191;
			libraryName();
			State = 192;
			Match(Greater);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class LibraryNameContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LibraryName() { return GetToken(C_GrammarParser.LibraryName, 0); }
		public LibraryNameContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_libraryName; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.EnterLibraryName(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.ExitLibraryName(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IC_GrammarVisitor<TResult> typedVisitor = visitor as IC_GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitLibraryName(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public LibraryNameContext libraryName() {
		LibraryNameContext _localctx = new LibraryNameContext(Context, State);
		EnterRule(_localctx, 24, RULE_libraryName);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 194;
			Match(LibraryName);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ExternalDeclarationContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public FunctionDefinitionContext functionDefinition() {
			return GetRuleContext<FunctionDefinitionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public DeclarationContext declaration() {
			return GetRuleContext<DeclarationContext>(0);
		}
		public ExternalDeclarationContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_externalDeclaration; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.EnterExternalDeclaration(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.ExitExternalDeclaration(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IC_GrammarVisitor<TResult> typedVisitor = visitor as IC_GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitExternalDeclaration(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ExternalDeclarationContext externalDeclaration() {
		ExternalDeclarationContext _localctx = new ExternalDeclarationContext(Context, State);
		EnterRule(_localctx, 26, RULE_externalDeclaration);
		try {
			State = 198;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,5,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 196;
				functionDefinition();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 197;
				declaration();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class FunctionDefinitionContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public DeclarationSpecifiersContext declarationSpecifiers() {
			return GetRuleContext<DeclarationSpecifiersContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public DeclaratorContext declarator() {
			return GetRuleContext<DeclaratorContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public DeclarationListContext declarationList() {
			return GetRuleContext<DeclarationListContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public CompoundStatementContext compoundStatement() {
			return GetRuleContext<CompoundStatementContext>(0);
		}
		public FunctionDefinitionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_functionDefinition; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.EnterFunctionDefinition(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.ExitFunctionDefinition(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IC_GrammarVisitor<TResult> typedVisitor = visitor as IC_GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitFunctionDefinition(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public FunctionDefinitionContext functionDefinition() {
		FunctionDefinitionContext _localctx = new FunctionDefinitionContext(Context, State);
		EnterRule(_localctx, 28, RULE_functionDefinition);
		try {
			State = 216;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,6,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 200;
				declarationSpecifiers();
				State = 201;
				declarator();
				State = 202;
				declarationList(0);
				State = 203;
				compoundStatement();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 205;
				declarationSpecifiers();
				State = 206;
				declarator();
				State = 207;
				compoundStatement();
				}
				break;
			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 209;
				declarator();
				State = 210;
				declarationList(0);
				State = 211;
				compoundStatement();
				}
				break;
			case 4:
				EnterOuterAlt(_localctx, 4);
				{
				State = 213;
				declarator();
				State = 214;
				compoundStatement();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class JumpStatementContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Continue() { return GetToken(C_GrammarParser.Continue, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Semicolon() { return GetToken(C_GrammarParser.Semicolon, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Break() { return GetToken(C_GrammarParser.Break, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Return() { return GetToken(C_GrammarParser.Return, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public JumpStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_jumpStatement; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.EnterJumpStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.ExitJumpStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IC_GrammarVisitor<TResult> typedVisitor = visitor as IC_GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitJumpStatement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public JumpStatementContext jumpStatement() {
		JumpStatementContext _localctx = new JumpStatementContext(Context, State);
		EnterRule(_localctx, 30, RULE_jumpStatement);
		try {
			State = 228;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,7,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 218;
				Match(Continue);
				State = 219;
				Match(Semicolon);
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 220;
				Match(Break);
				State = 221;
				Match(Semicolon);
				}
				break;
			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 222;
				Match(Return);
				State = 223;
				Match(Semicolon);
				}
				break;
			case 4:
				EnterOuterAlt(_localctx, 4);
				{
				State = 224;
				Match(Return);
				State = 225;
				expression(0);
				State = 226;
				Match(Semicolon);
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class IterationStatementContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode While() { return GetToken(C_GrammarParser.While, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LeftParen() { return GetToken(C_GrammarParser.LeftParen, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RightParen() { return GetToken(C_GrammarParser.RightParen, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public StatementContext statement() {
			return GetRuleContext<StatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Do() { return GetToken(C_GrammarParser.Do, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Semicolon() { return GetToken(C_GrammarParser.Semicolon, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode For() { return GetToken(C_GrammarParser.For, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionStatementContext[] expressionStatement() {
			return GetRuleContexts<ExpressionStatementContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionStatementContext expressionStatement(int i) {
			return GetRuleContext<ExpressionStatementContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public DeclarationContext declaration() {
			return GetRuleContext<DeclarationContext>(0);
		}
		public IterationStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_iterationStatement; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.EnterIterationStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.ExitIterationStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IC_GrammarVisitor<TResult> typedVisitor = visitor as IC_GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitIterationStatement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public IterationStatementContext iterationStatement() {
		IterationStatementContext _localctx = new IterationStatementContext(Context, State);
		EnterRule(_localctx, 32, RULE_iterationStatement);
		try {
			State = 265;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,10,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 230;
				Match(While);
				State = 231;
				Match(LeftParen);
				State = 232;
				expression(0);
				State = 233;
				Match(RightParen);
				State = 234;
				statement();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 236;
				Match(Do);
				State = 237;
				statement();
				State = 238;
				Match(While);
				State = 239;
				Match(LeftParen);
				State = 240;
				expression(0);
				State = 241;
				Match(RightParen);
				State = 242;
				Match(Semicolon);
				}
				break;
			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 244;
				Match(For);
				State = 245;
				Match(LeftParen);
				State = 248;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,8,Context) ) {
				case 1:
					{
					State = 246;
					expressionStatement();
					}
					break;
				case 2:
					{
					State = 247;
					declaration();
					}
					break;
				}
				State = 250;
				expressionStatement();
				State = 251;
				Match(RightParen);
				State = 252;
				statement();
				}
				break;
			case 4:
				EnterOuterAlt(_localctx, 4);
				{
				State = 254;
				Match(For);
				State = 255;
				Match(LeftParen);
				State = 258;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,9,Context) ) {
				case 1:
					{
					State = 256;
					expressionStatement();
					}
					break;
				case 2:
					{
					State = 257;
					declaration();
					}
					break;
				}
				State = 260;
				expressionStatement();
				State = 261;
				expression(0);
				State = 262;
				Match(RightParen);
				State = 263;
				statement();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SelectionStatementContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode If() { return GetToken(C_GrammarParser.If, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LeftParen() { return GetToken(C_GrammarParser.LeftParen, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RightParen() { return GetToken(C_GrammarParser.RightParen, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public StatementContext[] statement() {
			return GetRuleContexts<StatementContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public StatementContext statement(int i) {
			return GetRuleContext<StatementContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Else() { return GetToken(C_GrammarParser.Else, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Switch() { return GetToken(C_GrammarParser.Switch, 0); }
		public SelectionStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_selectionStatement; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.EnterSelectionStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.ExitSelectionStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IC_GrammarVisitor<TResult> typedVisitor = visitor as IC_GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSelectionStatement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public SelectionStatementContext selectionStatement() {
		SelectionStatementContext _localctx = new SelectionStatementContext(Context, State);
		EnterRule(_localctx, 34, RULE_selectionStatement);
		try {
			State = 287;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,11,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 267;
				Match(If);
				State = 268;
				Match(LeftParen);
				State = 269;
				expression(0);
				State = 270;
				Match(RightParen);
				State = 271;
				statement();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 273;
				Match(If);
				State = 274;
				Match(LeftParen);
				State = 275;
				expression(0);
				State = 276;
				Match(RightParen);
				State = 277;
				statement();
				State = 278;
				Match(Else);
				State = 279;
				statement();
				}
				break;
			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 281;
				Match(Switch);
				State = 282;
				Match(LeftParen);
				State = 283;
				expression(0);
				State = 284;
				Match(RightParen);
				State = 285;
				statement();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ExpressionStatementContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Semicolon() { return GetToken(C_GrammarParser.Semicolon, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public ExpressionStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_expressionStatement; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.EnterExpressionStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.ExitExpressionStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IC_GrammarVisitor<TResult> typedVisitor = visitor as IC_GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitExpressionStatement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ExpressionStatementContext expressionStatement() {
		ExpressionStatementContext _localctx = new ExpressionStatementContext(Context, State);
		EnterRule(_localctx, 36, RULE_expressionStatement);
		try {
			State = 293;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case Semicolon:
				EnterOuterAlt(_localctx, 1);
				{
				State = 289;
				Match(Semicolon);
				}
				break;
			case Sizeof:
			case Multiply:
			case Plus:
			case Minus:
			case LeftParen:
			case Ampersand:
			case Exclamation:
			case DecOp:
			case IncOp:
			case Identifier:
			case Constant:
			case StringLiteral:
				EnterOuterAlt(_localctx, 2);
				{
				State = 290;
				expression(0);
				State = 291;
				Match(Semicolon);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class StatementListContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public StatementContext statement() {
			return GetRuleContext<StatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public StatementListContext statementList() {
			return GetRuleContext<StatementListContext>(0);
		}
		public StatementListContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_statementList; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.EnterStatementList(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.ExitStatementList(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IC_GrammarVisitor<TResult> typedVisitor = visitor as IC_GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitStatementList(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public StatementListContext statementList() {
		return statementList(0);
	}

	private StatementListContext statementList(int _p) {
		ParserRuleContext _parentctx = Context;
		int _parentState = State;
		StatementListContext _localctx = new StatementListContext(Context, _parentState);
		StatementListContext _prevctx = _localctx;
		int _startState = 38;
		EnterRecursionRule(_localctx, 38, RULE_statementList, _p);
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			{
			State = 296;
			statement();
			}
			Context.Stop = TokenStream.LT(-1);
			State = 302;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,13,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					if ( ParseListeners!=null )
						TriggerExitRuleEvent();
					_prevctx = _localctx;
					{
					{
					_localctx = new StatementListContext(_parentctx, _parentState);
					PushNewRecursionContext(_localctx, _startState, RULE_statementList);
					State = 298;
					if (!(Precpred(Context, 1))) throw new FailedPredicateException(this, "Precpred(Context, 1)");
					State = 299;
					statement();
					}
					} 
				}
				State = 304;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,13,Context);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			UnrollRecursionContexts(_parentctx);
		}
		return _localctx;
	}

	public partial class DeclarationListContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public DeclarationContext declaration() {
			return GetRuleContext<DeclarationContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public DeclarationListContext declarationList() {
			return GetRuleContext<DeclarationListContext>(0);
		}
		public DeclarationListContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_declarationList; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.EnterDeclarationList(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.ExitDeclarationList(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IC_GrammarVisitor<TResult> typedVisitor = visitor as IC_GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitDeclarationList(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public DeclarationListContext declarationList() {
		return declarationList(0);
	}

	private DeclarationListContext declarationList(int _p) {
		ParserRuleContext _parentctx = Context;
		int _parentState = State;
		DeclarationListContext _localctx = new DeclarationListContext(Context, _parentState);
		DeclarationListContext _prevctx = _localctx;
		int _startState = 40;
		EnterRecursionRule(_localctx, 40, RULE_declarationList, _p);
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			{
			State = 306;
			declaration();
			}
			Context.Stop = TokenStream.LT(-1);
			State = 312;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,14,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					if ( ParseListeners!=null )
						TriggerExitRuleEvent();
					_prevctx = _localctx;
					{
					{
					_localctx = new DeclarationListContext(_parentctx, _parentState);
					PushNewRecursionContext(_localctx, _startState, RULE_declarationList);
					State = 308;
					if (!(Precpred(Context, 1))) throw new FailedPredicateException(this, "Precpred(Context, 1)");
					State = 309;
					declaration();
					}
					} 
				}
				State = 314;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,14,Context);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			UnrollRecursionContexts(_parentctx);
		}
		return _localctx;
	}

	public partial class CompoundStatementContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LeftBrace() { return GetToken(C_GrammarParser.LeftBrace, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RightBrace() { return GetToken(C_GrammarParser.RightBrace, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public BlockItemListContext blockItemList() {
			return GetRuleContext<BlockItemListContext>(0);
		}
		public CompoundStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_compoundStatement; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.EnterCompoundStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.ExitCompoundStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IC_GrammarVisitor<TResult> typedVisitor = visitor as IC_GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCompoundStatement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public CompoundStatementContext compoundStatement() {
		CompoundStatementContext _localctx = new CompoundStatementContext(Context, State);
		EnterRule(_localctx, 42, RULE_compoundStatement);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 315;
			Match(LeftBrace);
			State = 317;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if ((((_la) & ~0x3f) == 0 && ((1L << _la) & 8149055167199706112L) != 0) || ((((_la - 74)) & ~0x3f) == 0 && ((1L << (_la - 74)) & 11L) != 0)) {
				{
				State = 316;
				blockItemList(0);
				}
			}

			State = 319;
			Match(RightBrace);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class BlockItemListContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public BlockItemContext blockItem() {
			return GetRuleContext<BlockItemContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public BlockItemListContext blockItemList() {
			return GetRuleContext<BlockItemListContext>(0);
		}
		public BlockItemListContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_blockItemList; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.EnterBlockItemList(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.ExitBlockItemList(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IC_GrammarVisitor<TResult> typedVisitor = visitor as IC_GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitBlockItemList(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public BlockItemListContext blockItemList() {
		return blockItemList(0);
	}

	private BlockItemListContext blockItemList(int _p) {
		ParserRuleContext _parentctx = Context;
		int _parentState = State;
		BlockItemListContext _localctx = new BlockItemListContext(Context, _parentState);
		BlockItemListContext _prevctx = _localctx;
		int _startState = 44;
		EnterRecursionRule(_localctx, 44, RULE_blockItemList, _p);
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			{
			State = 322;
			blockItem();
			}
			Context.Stop = TokenStream.LT(-1);
			State = 328;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,16,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					if ( ParseListeners!=null )
						TriggerExitRuleEvent();
					_prevctx = _localctx;
					{
					{
					_localctx = new BlockItemListContext(_parentctx, _parentState);
					PushNewRecursionContext(_localctx, _startState, RULE_blockItemList);
					State = 324;
					if (!(Precpred(Context, 1))) throw new FailedPredicateException(this, "Precpred(Context, 1)");
					State = 325;
					blockItem();
					}
					} 
				}
				State = 330;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,16,Context);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			UnrollRecursionContexts(_parentctx);
		}
		return _localctx;
	}

	public partial class BlockItemContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public StatementListContext statementList() {
			return GetRuleContext<StatementListContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public DeclarationListContext declarationList() {
			return GetRuleContext<DeclarationListContext>(0);
		}
		public BlockItemContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_blockItem; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.EnterBlockItem(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.ExitBlockItem(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IC_GrammarVisitor<TResult> typedVisitor = visitor as IC_GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitBlockItem(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public BlockItemContext blockItem() {
		BlockItemContext _localctx = new BlockItemContext(Context, State);
		EnterRule(_localctx, 46, RULE_blockItem);
		try {
			State = 333;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,17,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 331;
				statementList(0);
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 332;
				declarationList(0);
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class LabeledStatementContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Identifier() { return GetToken(C_GrammarParser.Identifier, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Colon() { return GetToken(C_GrammarParser.Colon, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public StatementContext statement() {
			return GetRuleContext<StatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Case() { return GetToken(C_GrammarParser.Case, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ConstantExpressionContext constantExpression() {
			return GetRuleContext<ConstantExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Default() { return GetToken(C_GrammarParser.Default, 0); }
		public LabeledStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_labeledStatement; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.EnterLabeledStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.ExitLabeledStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IC_GrammarVisitor<TResult> typedVisitor = visitor as IC_GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitLabeledStatement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public LabeledStatementContext labeledStatement() {
		LabeledStatementContext _localctx = new LabeledStatementContext(Context, State);
		EnterRule(_localctx, 48, RULE_labeledStatement);
		try {
			State = 346;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case Identifier:
				EnterOuterAlt(_localctx, 1);
				{
				State = 335;
				Match(Identifier);
				State = 336;
				Match(Colon);
				State = 337;
				statement();
				}
				break;
			case Case:
				EnterOuterAlt(_localctx, 2);
				{
				State = 338;
				Match(Case);
				State = 339;
				constantExpression();
				State = 340;
				Match(Colon);
				State = 341;
				statement();
				}
				break;
			case Default:
				EnterOuterAlt(_localctx, 3);
				{
				State = 343;
				Match(Default);
				State = 344;
				Match(Colon);
				State = 345;
				statement();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class StatementContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public LabeledStatementContext labeledStatement() {
			return GetRuleContext<LabeledStatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public CompoundStatementContext compoundStatement() {
			return GetRuleContext<CompoundStatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionStatementContext expressionStatement() {
			return GetRuleContext<ExpressionStatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public SelectionStatementContext selectionStatement() {
			return GetRuleContext<SelectionStatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public IterationStatementContext iterationStatement() {
			return GetRuleContext<IterationStatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public JumpStatementContext jumpStatement() {
			return GetRuleContext<JumpStatementContext>(0);
		}
		public StatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_statement; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.EnterStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.ExitStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IC_GrammarVisitor<TResult> typedVisitor = visitor as IC_GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitStatement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public StatementContext statement() {
		StatementContext _localctx = new StatementContext(Context, State);
		EnterRule(_localctx, 50, RULE_statement);
		try {
			State = 354;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,19,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 348;
				labeledStatement();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 349;
				compoundStatement();
				}
				break;
			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 350;
				expressionStatement();
				}
				break;
			case 4:
				EnterOuterAlt(_localctx, 4);
				{
				State = 351;
				selectionStatement();
				}
				break;
			case 5:
				EnterOuterAlt(_localctx, 5);
				{
				State = 352;
				iterationStatement();
				}
				break;
			case 6:
				EnterOuterAlt(_localctx, 6);
				{
				State = 353;
				jumpStatement();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class InitializerListContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public InitializerContext initializer() {
			return GetRuleContext<InitializerContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public InitializerListContext initializerList() {
			return GetRuleContext<InitializerListContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Comma() { return GetToken(C_GrammarParser.Comma, 0); }
		public InitializerListContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_initializerList; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.EnterInitializerList(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.ExitInitializerList(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IC_GrammarVisitor<TResult> typedVisitor = visitor as IC_GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitInitializerList(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public InitializerListContext initializerList() {
		return initializerList(0);
	}

	private InitializerListContext initializerList(int _p) {
		ParserRuleContext _parentctx = Context;
		int _parentState = State;
		InitializerListContext _localctx = new InitializerListContext(Context, _parentState);
		InitializerListContext _prevctx = _localctx;
		int _startState = 52;
		EnterRecursionRule(_localctx, 52, RULE_initializerList, _p);
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			{
			State = 357;
			initializer();
			}
			Context.Stop = TokenStream.LT(-1);
			State = 364;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,20,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					if ( ParseListeners!=null )
						TriggerExitRuleEvent();
					_prevctx = _localctx;
					{
					{
					_localctx = new InitializerListContext(_parentctx, _parentState);
					PushNewRecursionContext(_localctx, _startState, RULE_initializerList);
					State = 359;
					if (!(Precpred(Context, 1))) throw new FailedPredicateException(this, "Precpred(Context, 1)");
					State = 360;
					Match(Comma);
					State = 361;
					initializer();
					}
					} 
				}
				State = 366;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,20,Context);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			UnrollRecursionContexts(_parentctx);
		}
		return _localctx;
	}

	public partial class InitializerContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public AssignmentExpressionContext assignmentExpression() {
			return GetRuleContext<AssignmentExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LeftBrace() { return GetToken(C_GrammarParser.LeftBrace, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public InitializerListContext initializerList() {
			return GetRuleContext<InitializerListContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RightBrace() { return GetToken(C_GrammarParser.RightBrace, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Comma() { return GetToken(C_GrammarParser.Comma, 0); }
		public InitializerContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_initializer; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.EnterInitializer(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.ExitInitializer(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IC_GrammarVisitor<TResult> typedVisitor = visitor as IC_GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitInitializer(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public InitializerContext initializer() {
		InitializerContext _localctx = new InitializerContext(Context, State);
		EnterRule(_localctx, 54, RULE_initializer);
		try {
			State = 377;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,21,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 367;
				assignmentExpression();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 368;
				Match(LeftBrace);
				State = 369;
				initializerList(0);
				State = 370;
				Match(RightBrace);
				}
				break;
			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 372;
				Match(LeftBrace);
				State = 373;
				initializerList(0);
				State = 374;
				Match(Comma);
				State = 375;
				Match(RightBrace);
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class DirectAbstractDeclaratorContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LeftParen() { return GetToken(C_GrammarParser.LeftParen, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public AbstractDeclaratorContext abstractDeclarator() {
			return GetRuleContext<AbstractDeclaratorContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RightParen() { return GetToken(C_GrammarParser.RightParen, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LeftBracket() { return GetToken(C_GrammarParser.LeftBracket, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RightBracket() { return GetToken(C_GrammarParser.RightBracket, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ConstantExpressionContext constantExpression() {
			return GetRuleContext<ConstantExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ParameterListContext parameterList() {
			return GetRuleContext<ParameterListContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public DirectAbstractDeclaratorContext directAbstractDeclarator() {
			return GetRuleContext<DirectAbstractDeclaratorContext>(0);
		}
		public DirectAbstractDeclaratorContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_directAbstractDeclarator; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.EnterDirectAbstractDeclarator(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.ExitDirectAbstractDeclarator(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IC_GrammarVisitor<TResult> typedVisitor = visitor as IC_GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitDirectAbstractDeclarator(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public DirectAbstractDeclaratorContext directAbstractDeclarator() {
		return directAbstractDeclarator(0);
	}

	private DirectAbstractDeclaratorContext directAbstractDeclarator(int _p) {
		ParserRuleContext _parentctx = Context;
		int _parentState = State;
		DirectAbstractDeclaratorContext _localctx = new DirectAbstractDeclaratorContext(Context, _parentState);
		DirectAbstractDeclaratorContext _prevctx = _localctx;
		int _startState = 56;
		EnterRecursionRule(_localctx, 56, RULE_directAbstractDeclarator, _p);
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 396;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,22,Context) ) {
			case 1:
				{
				State = 380;
				Match(LeftParen);
				State = 381;
				abstractDeclarator();
				State = 382;
				Match(RightParen);
				}
				break;
			case 2:
				{
				State = 384;
				Match(LeftBracket);
				State = 385;
				Match(RightBracket);
				}
				break;
			case 3:
				{
				State = 386;
				Match(LeftBracket);
				State = 387;
				constantExpression();
				State = 388;
				Match(RightBracket);
				}
				break;
			case 4:
				{
				State = 390;
				Match(LeftParen);
				State = 391;
				Match(RightParen);
				}
				break;
			case 5:
				{
				State = 392;
				Match(LeftParen);
				State = 393;
				parameterList(0);
				State = 394;
				Match(RightParen);
				}
				break;
			}
			Context.Stop = TokenStream.LT(-1);
			State = 416;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,24,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					if ( ParseListeners!=null )
						TriggerExitRuleEvent();
					_prevctx = _localctx;
					{
					State = 414;
					ErrorHandler.Sync(this);
					switch ( Interpreter.AdaptivePredict(TokenStream,23,Context) ) {
					case 1:
						{
						_localctx = new DirectAbstractDeclaratorContext(_parentctx, _parentState);
						PushNewRecursionContext(_localctx, _startState, RULE_directAbstractDeclarator);
						State = 398;
						if (!(Precpred(Context, 6))) throw new FailedPredicateException(this, "Precpred(Context, 6)");
						State = 399;
						Match(LeftBracket);
						State = 400;
						Match(RightBracket);
						}
						break;
					case 2:
						{
						_localctx = new DirectAbstractDeclaratorContext(_parentctx, _parentState);
						PushNewRecursionContext(_localctx, _startState, RULE_directAbstractDeclarator);
						State = 401;
						if (!(Precpred(Context, 5))) throw new FailedPredicateException(this, "Precpred(Context, 5)");
						State = 402;
						Match(LeftBracket);
						State = 403;
						constantExpression();
						State = 404;
						Match(RightBracket);
						}
						break;
					case 3:
						{
						_localctx = new DirectAbstractDeclaratorContext(_parentctx, _parentState);
						PushNewRecursionContext(_localctx, _startState, RULE_directAbstractDeclarator);
						State = 406;
						if (!(Precpred(Context, 2))) throw new FailedPredicateException(this, "Precpred(Context, 2)");
						State = 407;
						Match(LeftParen);
						State = 408;
						Match(RightParen);
						}
						break;
					case 4:
						{
						_localctx = new DirectAbstractDeclaratorContext(_parentctx, _parentState);
						PushNewRecursionContext(_localctx, _startState, RULE_directAbstractDeclarator);
						State = 409;
						if (!(Precpred(Context, 1))) throw new FailedPredicateException(this, "Precpred(Context, 1)");
						State = 410;
						Match(LeftParen);
						State = 411;
						parameterList(0);
						State = 412;
						Match(RightParen);
						}
						break;
					}
					} 
				}
				State = 418;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,24,Context);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			UnrollRecursionContexts(_parentctx);
		}
		return _localctx;
	}

	public partial class AbstractDeclaratorContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public PointerContext pointer() {
			return GetRuleContext<PointerContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public DirectAbstractDeclaratorContext directAbstractDeclarator() {
			return GetRuleContext<DirectAbstractDeclaratorContext>(0);
		}
		public AbstractDeclaratorContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_abstractDeclarator; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.EnterAbstractDeclarator(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.ExitAbstractDeclarator(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IC_GrammarVisitor<TResult> typedVisitor = visitor as IC_GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAbstractDeclarator(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public AbstractDeclaratorContext abstractDeclarator() {
		AbstractDeclaratorContext _localctx = new AbstractDeclaratorContext(Context, State);
		EnterRule(_localctx, 58, RULE_abstractDeclarator);
		try {
			State = 424;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,25,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 419;
				pointer();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 420;
				directAbstractDeclarator(0);
				}
				break;
			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 421;
				pointer();
				State = 422;
				directAbstractDeclarator(0);
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class IdentifierListContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Identifier() { return GetToken(C_GrammarParser.Identifier, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public IdentifierListContext identifierList() {
			return GetRuleContext<IdentifierListContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Comma() { return GetToken(C_GrammarParser.Comma, 0); }
		public IdentifierListContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_identifierList; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.EnterIdentifierList(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.ExitIdentifierList(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IC_GrammarVisitor<TResult> typedVisitor = visitor as IC_GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitIdentifierList(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public IdentifierListContext identifierList() {
		return identifierList(0);
	}

	private IdentifierListContext identifierList(int _p) {
		ParserRuleContext _parentctx = Context;
		int _parentState = State;
		IdentifierListContext _localctx = new IdentifierListContext(Context, _parentState);
		IdentifierListContext _prevctx = _localctx;
		int _startState = 60;
		EnterRecursionRule(_localctx, 60, RULE_identifierList, _p);
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			{
			State = 427;
			Match(Identifier);
			}
			Context.Stop = TokenStream.LT(-1);
			State = 434;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,26,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					if ( ParseListeners!=null )
						TriggerExitRuleEvent();
					_prevctx = _localctx;
					{
					{
					_localctx = new IdentifierListContext(_parentctx, _parentState);
					PushNewRecursionContext(_localctx, _startState, RULE_identifierList);
					State = 429;
					if (!(Precpred(Context, 1))) throw new FailedPredicateException(this, "Precpred(Context, 1)");
					State = 430;
					Match(Comma);
					State = 431;
					Match(Identifier);
					}
					} 
				}
				State = 436;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,26,Context);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			UnrollRecursionContexts(_parentctx);
		}
		return _localctx;
	}

	public partial class ParameterDeclarationContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public DeclarationSpecifiersContext declarationSpecifiers() {
			return GetRuleContext<DeclarationSpecifiersContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public DeclaratorContext declarator() {
			return GetRuleContext<DeclaratorContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public AbstractDeclaratorContext abstractDeclarator() {
			return GetRuleContext<AbstractDeclaratorContext>(0);
		}
		public ParameterDeclarationContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_parameterDeclaration; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.EnterParameterDeclaration(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.ExitParameterDeclaration(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IC_GrammarVisitor<TResult> typedVisitor = visitor as IC_GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitParameterDeclaration(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ParameterDeclarationContext parameterDeclaration() {
		ParameterDeclarationContext _localctx = new ParameterDeclarationContext(Context, State);
		EnterRule(_localctx, 62, RULE_parameterDeclaration);
		try {
			State = 444;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,27,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 437;
				declarationSpecifiers();
				State = 438;
				declarator();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 440;
				declarationSpecifiers();
				State = 441;
				abstractDeclarator();
				}
				break;
			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 443;
				declarationSpecifiers();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ParameterListContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ParameterDeclarationContext parameterDeclaration() {
			return GetRuleContext<ParameterDeclarationContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ParameterListContext parameterList() {
			return GetRuleContext<ParameterListContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Comma() { return GetToken(C_GrammarParser.Comma, 0); }
		public ParameterListContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_parameterList; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.EnterParameterList(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.ExitParameterList(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IC_GrammarVisitor<TResult> typedVisitor = visitor as IC_GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitParameterList(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ParameterListContext parameterList() {
		return parameterList(0);
	}

	private ParameterListContext parameterList(int _p) {
		ParserRuleContext _parentctx = Context;
		int _parentState = State;
		ParameterListContext _localctx = new ParameterListContext(Context, _parentState);
		ParameterListContext _prevctx = _localctx;
		int _startState = 64;
		EnterRecursionRule(_localctx, 64, RULE_parameterList, _p);
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			{
			State = 447;
			parameterDeclaration();
			}
			Context.Stop = TokenStream.LT(-1);
			State = 454;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,28,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					if ( ParseListeners!=null )
						TriggerExitRuleEvent();
					_prevctx = _localctx;
					{
					{
					_localctx = new ParameterListContext(_parentctx, _parentState);
					PushNewRecursionContext(_localctx, _startState, RULE_parameterList);
					State = 449;
					if (!(Precpred(Context, 1))) throw new FailedPredicateException(this, "Precpred(Context, 1)");
					State = 450;
					Match(Comma);
					State = 451;
					parameterDeclaration();
					}
					} 
				}
				State = 456;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,28,Context);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			UnrollRecursionContexts(_parentctx);
		}
		return _localctx;
	}

	public partial class TypeQualifierListContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Const() { return GetToken(C_GrammarParser.Const, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public TypeQualifierListContext typeQualifierList() {
			return GetRuleContext<TypeQualifierListContext>(0);
		}
		public TypeQualifierListContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_typeQualifierList; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.EnterTypeQualifierList(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.ExitTypeQualifierList(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IC_GrammarVisitor<TResult> typedVisitor = visitor as IC_GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTypeQualifierList(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public TypeQualifierListContext typeQualifierList() {
		return typeQualifierList(0);
	}

	private TypeQualifierListContext typeQualifierList(int _p) {
		ParserRuleContext _parentctx = Context;
		int _parentState = State;
		TypeQualifierListContext _localctx = new TypeQualifierListContext(Context, _parentState);
		TypeQualifierListContext _prevctx = _localctx;
		int _startState = 66;
		EnterRecursionRule(_localctx, 66, RULE_typeQualifierList, _p);
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			{
			State = 458;
			Match(Const);
			}
			Context.Stop = TokenStream.LT(-1);
			State = 464;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,29,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					if ( ParseListeners!=null )
						TriggerExitRuleEvent();
					_prevctx = _localctx;
					{
					{
					_localctx = new TypeQualifierListContext(_parentctx, _parentState);
					PushNewRecursionContext(_localctx, _startState, RULE_typeQualifierList);
					State = 460;
					if (!(Precpred(Context, 1))) throw new FailedPredicateException(this, "Precpred(Context, 1)");
					State = 461;
					Match(Const);
					}
					} 
				}
				State = 466;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,29,Context);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			UnrollRecursionContexts(_parentctx);
		}
		return _localctx;
	}

	public partial class PointerContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Multiply() { return GetToken(C_GrammarParser.Multiply, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public TypeQualifierListContext typeQualifierList() {
			return GetRuleContext<TypeQualifierListContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public PointerContext pointer() {
			return GetRuleContext<PointerContext>(0);
		}
		public PointerContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_pointer; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.EnterPointer(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.ExitPointer(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IC_GrammarVisitor<TResult> typedVisitor = visitor as IC_GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitPointer(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public PointerContext pointer() {
		PointerContext _localctx = new PointerContext(Context, State);
		EnterRule(_localctx, 68, RULE_pointer);
		try {
			State = 476;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,30,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 467;
				Match(Multiply);
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 468;
				Match(Multiply);
				State = 469;
				typeQualifierList(0);
				}
				break;
			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 470;
				Match(Multiply);
				State = 471;
				pointer();
				}
				break;
			case 4:
				EnterOuterAlt(_localctx, 4);
				{
				State = 472;
				Match(Multiply);
				State = 473;
				typeQualifierList(0);
				State = 474;
				pointer();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class DirectDeclaratorContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Identifier() { return GetToken(C_GrammarParser.Identifier, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LeftParen() { return GetToken(C_GrammarParser.LeftParen, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public DeclaratorContext declarator() {
			return GetRuleContext<DeclaratorContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RightParen() { return GetToken(C_GrammarParser.RightParen, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public DirectDeclaratorContext directDeclarator() {
			return GetRuleContext<DirectDeclaratorContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LeftBracket() { return GetToken(C_GrammarParser.LeftBracket, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ConstantExpressionContext constantExpression() {
			return GetRuleContext<ConstantExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RightBracket() { return GetToken(C_GrammarParser.RightBracket, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ParameterListContext parameterList() {
			return GetRuleContext<ParameterListContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public IdentifierListContext identifierList() {
			return GetRuleContext<IdentifierListContext>(0);
		}
		public DirectDeclaratorContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_directDeclarator; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.EnterDirectDeclarator(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.ExitDirectDeclarator(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IC_GrammarVisitor<TResult> typedVisitor = visitor as IC_GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitDirectDeclarator(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public DirectDeclaratorContext directDeclarator() {
		return directDeclarator(0);
	}

	private DirectDeclaratorContext directDeclarator(int _p) {
		ParserRuleContext _parentctx = Context;
		int _parentState = State;
		DirectDeclaratorContext _localctx = new DirectDeclaratorContext(Context, _parentState);
		DirectDeclaratorContext _prevctx = _localctx;
		int _startState = 70;
		EnterRecursionRule(_localctx, 70, RULE_directDeclarator, _p);
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 484;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case Identifier:
				{
				State = 479;
				Match(Identifier);
				}
				break;
			case LeftParen:
				{
				State = 480;
				Match(LeftParen);
				State = 481;
				declarator();
				State = 482;
				Match(RightParen);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			Context.Stop = TokenStream.LT(-1);
			State = 509;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,33,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					if ( ParseListeners!=null )
						TriggerExitRuleEvent();
					_prevctx = _localctx;
					{
					State = 507;
					ErrorHandler.Sync(this);
					switch ( Interpreter.AdaptivePredict(TokenStream,32,Context) ) {
					case 1:
						{
						_localctx = new DirectDeclaratorContext(_parentctx, _parentState);
						PushNewRecursionContext(_localctx, _startState, RULE_directDeclarator);
						State = 486;
						if (!(Precpred(Context, 5))) throw new FailedPredicateException(this, "Precpred(Context, 5)");
						State = 487;
						Match(LeftBracket);
						State = 488;
						constantExpression();
						State = 489;
						Match(RightBracket);
						}
						break;
					case 2:
						{
						_localctx = new DirectDeclaratorContext(_parentctx, _parentState);
						PushNewRecursionContext(_localctx, _startState, RULE_directDeclarator);
						State = 491;
						if (!(Precpred(Context, 4))) throw new FailedPredicateException(this, "Precpred(Context, 4)");
						State = 492;
						Match(LeftBracket);
						State = 493;
						Match(RightBracket);
						}
						break;
					case 3:
						{
						_localctx = new DirectDeclaratorContext(_parentctx, _parentState);
						PushNewRecursionContext(_localctx, _startState, RULE_directDeclarator);
						State = 494;
						if (!(Precpred(Context, 3))) throw new FailedPredicateException(this, "Precpred(Context, 3)");
						State = 495;
						Match(LeftParen);
						State = 496;
						parameterList(0);
						State = 497;
						Match(RightParen);
						}
						break;
					case 4:
						{
						_localctx = new DirectDeclaratorContext(_parentctx, _parentState);
						PushNewRecursionContext(_localctx, _startState, RULE_directDeclarator);
						State = 499;
						if (!(Precpred(Context, 2))) throw new FailedPredicateException(this, "Precpred(Context, 2)");
						State = 500;
						Match(LeftParen);
						State = 501;
						identifierList(0);
						State = 502;
						Match(RightParen);
						}
						break;
					case 5:
						{
						_localctx = new DirectDeclaratorContext(_parentctx, _parentState);
						PushNewRecursionContext(_localctx, _startState, RULE_directDeclarator);
						State = 504;
						if (!(Precpred(Context, 1))) throw new FailedPredicateException(this, "Precpred(Context, 1)");
						State = 505;
						Match(LeftParen);
						State = 506;
						Match(RightParen);
						}
						break;
					}
					} 
				}
				State = 511;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,33,Context);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			UnrollRecursionContexts(_parentctx);
		}
		return _localctx;
	}

	public partial class DeclaratorContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public PointerContext pointer() {
			return GetRuleContext<PointerContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public DirectDeclaratorContext directDeclarator() {
			return GetRuleContext<DirectDeclaratorContext>(0);
		}
		public DeclaratorContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_declarator; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.EnterDeclarator(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.ExitDeclarator(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IC_GrammarVisitor<TResult> typedVisitor = visitor as IC_GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitDeclarator(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public DeclaratorContext declarator() {
		DeclaratorContext _localctx = new DeclaratorContext(Context, State);
		EnterRule(_localctx, 72, RULE_declarator);
		try {
			State = 516;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case Multiply:
				EnterOuterAlt(_localctx, 1);
				{
				State = 512;
				pointer();
				State = 513;
				directDeclarator(0);
				}
				break;
			case LeftParen:
			case Identifier:
				EnterOuterAlt(_localctx, 2);
				{
				State = 515;
				directDeclarator(0);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SpecifierQualifierListContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public TypeSpecifierContext typeSpecifier() {
			return GetRuleContext<TypeSpecifierContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public SpecifierQualifierListContext specifierQualifierList() {
			return GetRuleContext<SpecifierQualifierListContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Const() { return GetToken(C_GrammarParser.Const, 0); }
		public SpecifierQualifierListContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_specifierQualifierList; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.EnterSpecifierQualifierList(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.ExitSpecifierQualifierList(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IC_GrammarVisitor<TResult> typedVisitor = visitor as IC_GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSpecifierQualifierList(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public SpecifierQualifierListContext specifierQualifierList() {
		SpecifierQualifierListContext _localctx = new SpecifierQualifierListContext(Context, State);
		EnterRule(_localctx, 74, RULE_specifierQualifierList);
		try {
			State = 525;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,35,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 518;
				typeSpecifier();
				State = 519;
				specifierQualifierList();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 521;
				typeSpecifier();
				}
				break;
			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 522;
				Match(Const);
				State = 523;
				specifierQualifierList();
				}
				break;
			case 4:
				EnterOuterAlt(_localctx, 4);
				{
				State = 524;
				Match(Const);
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class StructSpecifierContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Struct() { return GetToken(C_GrammarParser.Struct, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Identifier() { return GetToken(C_GrammarParser.Identifier, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LeftBrace() { return GetToken(C_GrammarParser.LeftBrace, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public StructDeclarationListContext structDeclarationList() {
			return GetRuleContext<StructDeclarationListContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RightBrace() { return GetToken(C_GrammarParser.RightBrace, 0); }
		public StructSpecifierContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_structSpecifier; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.EnterStructSpecifier(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.ExitStructSpecifier(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IC_GrammarVisitor<TResult> typedVisitor = visitor as IC_GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitStructSpecifier(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public StructSpecifierContext structSpecifier() {
		StructSpecifierContext _localctx = new StructSpecifierContext(Context, State);
		EnterRule(_localctx, 76, RULE_structSpecifier);
		try {
			State = 540;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,36,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 527;
				Match(Struct);
				State = 528;
				Match(Identifier);
				State = 529;
				Match(LeftBrace);
				State = 530;
				structDeclarationList(0);
				State = 531;
				Match(RightBrace);
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 533;
				Match(Struct);
				State = 534;
				Match(LeftBrace);
				State = 535;
				structDeclarationList(0);
				State = 536;
				Match(RightBrace);
				}
				break;
			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 538;
				Match(Struct);
				State = 539;
				Match(Identifier);
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class StructDeclarationListContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public StructDeclarationContext structDeclaration() {
			return GetRuleContext<StructDeclarationContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public StructDeclarationListContext structDeclarationList() {
			return GetRuleContext<StructDeclarationListContext>(0);
		}
		public StructDeclarationListContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_structDeclarationList; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.EnterStructDeclarationList(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.ExitStructDeclarationList(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IC_GrammarVisitor<TResult> typedVisitor = visitor as IC_GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitStructDeclarationList(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public StructDeclarationListContext structDeclarationList() {
		return structDeclarationList(0);
	}

	private StructDeclarationListContext structDeclarationList(int _p) {
		ParserRuleContext _parentctx = Context;
		int _parentState = State;
		StructDeclarationListContext _localctx = new StructDeclarationListContext(Context, _parentState);
		StructDeclarationListContext _prevctx = _localctx;
		int _startState = 78;
		EnterRecursionRule(_localctx, 78, RULE_structDeclarationList, _p);
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			{
			State = 543;
			structDeclaration();
			}
			Context.Stop = TokenStream.LT(-1);
			State = 549;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,37,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					if ( ParseListeners!=null )
						TriggerExitRuleEvent();
					_prevctx = _localctx;
					{
					{
					_localctx = new StructDeclarationListContext(_parentctx, _parentState);
					PushNewRecursionContext(_localctx, _startState, RULE_structDeclarationList);
					State = 545;
					if (!(Precpred(Context, 1))) throw new FailedPredicateException(this, "Precpred(Context, 1)");
					State = 546;
					structDeclaration();
					}
					} 
				}
				State = 551;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,37,Context);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			UnrollRecursionContexts(_parentctx);
		}
		return _localctx;
	}

	public partial class StructDeclarationContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public SpecifierQualifierListContext specifierQualifierList() {
			return GetRuleContext<SpecifierQualifierListContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public StructDeclaratorListContext structDeclaratorList() {
			return GetRuleContext<StructDeclaratorListContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Semicolon() { return GetToken(C_GrammarParser.Semicolon, 0); }
		public StructDeclarationContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_structDeclaration; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.EnterStructDeclaration(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.ExitStructDeclaration(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IC_GrammarVisitor<TResult> typedVisitor = visitor as IC_GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitStructDeclaration(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public StructDeclarationContext structDeclaration() {
		StructDeclarationContext _localctx = new StructDeclarationContext(Context, State);
		EnterRule(_localctx, 80, RULE_structDeclaration);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 552;
			specifierQualifierList();
			State = 553;
			structDeclaratorList(0);
			State = 554;
			Match(Semicolon);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class StructDeclaratorListContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public StructDeclaratorContext structDeclarator() {
			return GetRuleContext<StructDeclaratorContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public StructDeclaratorListContext structDeclaratorList() {
			return GetRuleContext<StructDeclaratorListContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Comma() { return GetToken(C_GrammarParser.Comma, 0); }
		public StructDeclaratorListContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_structDeclaratorList; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.EnterStructDeclaratorList(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.ExitStructDeclaratorList(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IC_GrammarVisitor<TResult> typedVisitor = visitor as IC_GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitStructDeclaratorList(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public StructDeclaratorListContext structDeclaratorList() {
		return structDeclaratorList(0);
	}

	private StructDeclaratorListContext structDeclaratorList(int _p) {
		ParserRuleContext _parentctx = Context;
		int _parentState = State;
		StructDeclaratorListContext _localctx = new StructDeclaratorListContext(Context, _parentState);
		StructDeclaratorListContext _prevctx = _localctx;
		int _startState = 82;
		EnterRecursionRule(_localctx, 82, RULE_structDeclaratorList, _p);
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			{
			State = 557;
			structDeclarator();
			}
			Context.Stop = TokenStream.LT(-1);
			State = 564;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,38,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					if ( ParseListeners!=null )
						TriggerExitRuleEvent();
					_prevctx = _localctx;
					{
					{
					_localctx = new StructDeclaratorListContext(_parentctx, _parentState);
					PushNewRecursionContext(_localctx, _startState, RULE_structDeclaratorList);
					State = 559;
					if (!(Precpred(Context, 1))) throw new FailedPredicateException(this, "Precpred(Context, 1)");
					State = 560;
					Match(Comma);
					State = 561;
					structDeclarator();
					}
					} 
				}
				State = 566;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,38,Context);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			UnrollRecursionContexts(_parentctx);
		}
		return _localctx;
	}

	public partial class StructDeclaratorContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public DeclaratorContext declarator() {
			return GetRuleContext<DeclaratorContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Colon() { return GetToken(C_GrammarParser.Colon, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ConstantExpressionContext constantExpression() {
			return GetRuleContext<ConstantExpressionContext>(0);
		}
		public StructDeclaratorContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_structDeclarator; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.EnterStructDeclarator(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.ExitStructDeclarator(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IC_GrammarVisitor<TResult> typedVisitor = visitor as IC_GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitStructDeclarator(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public StructDeclaratorContext structDeclarator() {
		StructDeclaratorContext _localctx = new StructDeclaratorContext(Context, State);
		EnterRule(_localctx, 84, RULE_structDeclarator);
		try {
			State = 574;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,39,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 567;
				declarator();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 568;
				Match(Colon);
				State = 569;
				constantExpression();
				}
				break;
			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 570;
				declarator();
				State = 571;
				Match(Colon);
				State = 572;
				constantExpression();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class StorageClassSpecifierContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Typedef() { return GetToken(C_GrammarParser.Typedef, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Extern() { return GetToken(C_GrammarParser.Extern, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Static() { return GetToken(C_GrammarParser.Static, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Auto() { return GetToken(C_GrammarParser.Auto, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Register() { return GetToken(C_GrammarParser.Register, 0); }
		public StorageClassSpecifierContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_storageClassSpecifier; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.EnterStorageClassSpecifier(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.ExitStorageClassSpecifier(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IC_GrammarVisitor<TResult> typedVisitor = visitor as IC_GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitStorageClassSpecifier(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public StorageClassSpecifierContext storageClassSpecifier() {
		StorageClassSpecifierContext _localctx = new StorageClassSpecifierContext(Context, State);
		EnterRule(_localctx, 86, RULE_storageClassSpecifier);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 576;
			_la = TokenStream.LA(1);
			if ( !((((_la) & ~0x3f) == 0 && ((1L << _la) & 126976L) != 0)) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TypeSpecifierContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Void() { return GetToken(C_GrammarParser.Void, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Char() { return GetToken(C_GrammarParser.Char, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Short() { return GetToken(C_GrammarParser.Short, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Int() { return GetToken(C_GrammarParser.Int, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Long() { return GetToken(C_GrammarParser.Long, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Float() { return GetToken(C_GrammarParser.Float, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Double() { return GetToken(C_GrammarParser.Double, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Signed() { return GetToken(C_GrammarParser.Signed, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Unsigned() { return GetToken(C_GrammarParser.Unsigned, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Bool() { return GetToken(C_GrammarParser.Bool, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public StructSpecifierContext structSpecifier() {
			return GetRuleContext<StructSpecifierContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public TypeNameIdentifierContext typeNameIdentifier() {
			return GetRuleContext<TypeNameIdentifierContext>(0);
		}
		public TypeSpecifierContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_typeSpecifier; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.EnterTypeSpecifier(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.ExitTypeSpecifier(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IC_GrammarVisitor<TResult> typedVisitor = visitor as IC_GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTypeSpecifier(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public TypeSpecifierContext typeSpecifier() {
		TypeSpecifierContext _localctx = new TypeSpecifierContext(Context, State);
		EnterRule(_localctx, 88, RULE_typeSpecifier);
		try {
			State = 590;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case Void:
				EnterOuterAlt(_localctx, 1);
				{
				State = 578;
				Match(Void);
				}
				break;
			case Char:
				EnterOuterAlt(_localctx, 2);
				{
				State = 579;
				Match(Char);
				}
				break;
			case Short:
				EnterOuterAlt(_localctx, 3);
				{
				State = 580;
				Match(Short);
				}
				break;
			case Int:
				EnterOuterAlt(_localctx, 4);
				{
				State = 581;
				Match(Int);
				}
				break;
			case Long:
				EnterOuterAlt(_localctx, 5);
				{
				State = 582;
				Match(Long);
				}
				break;
			case Float:
				EnterOuterAlt(_localctx, 6);
				{
				State = 583;
				Match(Float);
				}
				break;
			case Double:
				EnterOuterAlt(_localctx, 7);
				{
				State = 584;
				Match(Double);
				}
				break;
			case Signed:
				EnterOuterAlt(_localctx, 8);
				{
				State = 585;
				Match(Signed);
				}
				break;
			case Unsigned:
				EnterOuterAlt(_localctx, 9);
				{
				State = 586;
				Match(Unsigned);
				}
				break;
			case Bool:
				EnterOuterAlt(_localctx, 10);
				{
				State = 587;
				Match(Bool);
				}
				break;
			case Struct:
				EnterOuterAlt(_localctx, 11);
				{
				State = 588;
				structSpecifier();
				}
				break;
			case Identifier:
				EnterOuterAlt(_localctx, 12);
				{
				State = 589;
				typeNameIdentifier();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TypeNameIdentifierContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Identifier() { return GetToken(C_GrammarParser.Identifier, 0); }
		public TypeNameIdentifierContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_typeNameIdentifier; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.EnterTypeNameIdentifier(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.ExitTypeNameIdentifier(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IC_GrammarVisitor<TResult> typedVisitor = visitor as IC_GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTypeNameIdentifier(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public TypeNameIdentifierContext typeNameIdentifier() {
		TypeNameIdentifierContext _localctx = new TypeNameIdentifierContext(Context, State);
		EnterRule(_localctx, 90, RULE_typeNameIdentifier);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 592;
			Match(Identifier);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TypeNameContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public SpecifierQualifierListContext specifierQualifierList() {
			return GetRuleContext<SpecifierQualifierListContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public AbstractDeclaratorContext abstractDeclarator() {
			return GetRuleContext<AbstractDeclaratorContext>(0);
		}
		public TypeNameContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_typeName; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.EnterTypeName(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.ExitTypeName(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IC_GrammarVisitor<TResult> typedVisitor = visitor as IC_GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTypeName(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public TypeNameContext typeName() {
		TypeNameContext _localctx = new TypeNameContext(Context, State);
		EnterRule(_localctx, 92, RULE_typeName);
		try {
			State = 598;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,41,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 594;
				specifierQualifierList();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 595;
				specifierQualifierList();
				State = 596;
				abstractDeclarator();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class DeclarationSpecifiersContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public StorageClassSpecifierContext storageClassSpecifier() {
			return GetRuleContext<StorageClassSpecifierContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public DeclarationSpecifiersContext declarationSpecifiers() {
			return GetRuleContext<DeclarationSpecifiersContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public TypeSpecifierContext typeSpecifier() {
			return GetRuleContext<TypeSpecifierContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Const() { return GetToken(C_GrammarParser.Const, 0); }
		public DeclarationSpecifiersContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_declarationSpecifiers; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.EnterDeclarationSpecifiers(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.ExitDeclarationSpecifiers(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IC_GrammarVisitor<TResult> typedVisitor = visitor as IC_GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitDeclarationSpecifiers(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public DeclarationSpecifiersContext declarationSpecifiers() {
		DeclarationSpecifiersContext _localctx = new DeclarationSpecifiersContext(Context, State);
		EnterRule(_localctx, 94, RULE_declarationSpecifiers);
		try {
			State = 611;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,42,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 600;
				storageClassSpecifier();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 601;
				storageClassSpecifier();
				State = 602;
				declarationSpecifiers();
				}
				break;
			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 604;
				typeSpecifier();
				}
				break;
			case 4:
				EnterOuterAlt(_localctx, 4);
				{
				State = 605;
				typeSpecifier();
				State = 606;
				declarationSpecifiers();
				}
				break;
			case 5:
				EnterOuterAlt(_localctx, 5);
				{
				State = 608;
				Match(Const);
				}
				break;
			case 6:
				EnterOuterAlt(_localctx, 6);
				{
				State = 609;
				Match(Const);
				State = 610;
				declarationSpecifiers();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class InitDeclaratorListContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public InitDeclaratorContext initDeclarator() {
			return GetRuleContext<InitDeclaratorContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public InitDeclaratorListContext initDeclaratorList() {
			return GetRuleContext<InitDeclaratorListContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Comma() { return GetToken(C_GrammarParser.Comma, 0); }
		public InitDeclaratorListContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_initDeclaratorList; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.EnterInitDeclaratorList(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.ExitInitDeclaratorList(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IC_GrammarVisitor<TResult> typedVisitor = visitor as IC_GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitInitDeclaratorList(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public InitDeclaratorListContext initDeclaratorList() {
		return initDeclaratorList(0);
	}

	private InitDeclaratorListContext initDeclaratorList(int _p) {
		ParserRuleContext _parentctx = Context;
		int _parentState = State;
		InitDeclaratorListContext _localctx = new InitDeclaratorListContext(Context, _parentState);
		InitDeclaratorListContext _prevctx = _localctx;
		int _startState = 96;
		EnterRecursionRule(_localctx, 96, RULE_initDeclaratorList, _p);
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			{
			State = 614;
			initDeclarator();
			}
			Context.Stop = TokenStream.LT(-1);
			State = 621;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,43,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					if ( ParseListeners!=null )
						TriggerExitRuleEvent();
					_prevctx = _localctx;
					{
					{
					_localctx = new InitDeclaratorListContext(_parentctx, _parentState);
					PushNewRecursionContext(_localctx, _startState, RULE_initDeclaratorList);
					State = 616;
					if (!(Precpred(Context, 1))) throw new FailedPredicateException(this, "Precpred(Context, 1)");
					State = 617;
					Match(Comma);
					State = 618;
					initDeclarator();
					}
					} 
				}
				State = 623;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,43,Context);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			UnrollRecursionContexts(_parentctx);
		}
		return _localctx;
	}

	public partial class InitDeclaratorContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public DeclaratorContext declarator() {
			return GetRuleContext<DeclaratorContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Assign() { return GetToken(C_GrammarParser.Assign, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public InitializerContext initializer() {
			return GetRuleContext<InitializerContext>(0);
		}
		public InitDeclaratorContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_initDeclarator; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.EnterInitDeclarator(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.ExitInitDeclarator(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IC_GrammarVisitor<TResult> typedVisitor = visitor as IC_GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitInitDeclarator(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public InitDeclaratorContext initDeclarator() {
		InitDeclaratorContext _localctx = new InitDeclaratorContext(Context, State);
		EnterRule(_localctx, 98, RULE_initDeclarator);
		try {
			State = 629;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,44,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 624;
				declarator();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 625;
				declarator();
				State = 626;
				Match(Assign);
				State = 627;
				initializer();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class DeclarationContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public DeclarationSpecifiersContext declarationSpecifiers() {
			return GetRuleContext<DeclarationSpecifiersContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Semicolon() { return GetToken(C_GrammarParser.Semicolon, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public InitDeclaratorListContext initDeclaratorList() {
			return GetRuleContext<InitDeclaratorListContext>(0);
		}
		public DeclarationContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_declaration; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.EnterDeclaration(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.ExitDeclaration(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IC_GrammarVisitor<TResult> typedVisitor = visitor as IC_GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitDeclaration(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public DeclarationContext declaration() {
		DeclarationContext _localctx = new DeclarationContext(Context, State);
		EnterRule(_localctx, 100, RULE_declaration);
		try {
			State = 638;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,45,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 631;
				declarationSpecifiers();
				State = 632;
				Match(Semicolon);
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 634;
				declarationSpecifiers();
				State = 635;
				initDeclaratorList(0);
				State = 636;
				Match(Semicolon);
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ConstantExpressionContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ConditionalExpressionContext conditionalExpression() {
			return GetRuleContext<ConditionalExpressionContext>(0);
		}
		public ConstantExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_constantExpression; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.EnterConstantExpression(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.ExitConstantExpression(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IC_GrammarVisitor<TResult> typedVisitor = visitor as IC_GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitConstantExpression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ConstantExpressionContext constantExpression() {
		ConstantExpressionContext _localctx = new ConstantExpressionContext(Context, State);
		EnterRule(_localctx, 102, RULE_constantExpression);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 640;
			conditionalExpression();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ExpressionContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public AssignmentExpressionContext assignmentExpression() {
			return GetRuleContext<AssignmentExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Comma() { return GetToken(C_GrammarParser.Comma, 0); }
		public ExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_expression; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.EnterExpression(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.ExitExpression(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IC_GrammarVisitor<TResult> typedVisitor = visitor as IC_GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitExpression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ExpressionContext expression() {
		return expression(0);
	}

	private ExpressionContext expression(int _p) {
		ParserRuleContext _parentctx = Context;
		int _parentState = State;
		ExpressionContext _localctx = new ExpressionContext(Context, _parentState);
		ExpressionContext _prevctx = _localctx;
		int _startState = 104;
		EnterRecursionRule(_localctx, 104, RULE_expression, _p);
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			{
			State = 643;
			assignmentExpression();
			}
			Context.Stop = TokenStream.LT(-1);
			State = 650;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,46,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					if ( ParseListeners!=null )
						TriggerExitRuleEvent();
					_prevctx = _localctx;
					{
					{
					_localctx = new ExpressionContext(_parentctx, _parentState);
					PushNewRecursionContext(_localctx, _startState, RULE_expression);
					State = 645;
					if (!(Precpred(Context, 1))) throw new FailedPredicateException(this, "Precpred(Context, 1)");
					State = 646;
					Match(Comma);
					State = 647;
					assignmentExpression();
					}
					} 
				}
				State = 652;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,46,Context);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			UnrollRecursionContexts(_parentctx);
		}
		return _localctx;
	}

	public partial class AssignmentOperatorContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Assign() { return GetToken(C_GrammarParser.Assign, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode MulAssign() { return GetToken(C_GrammarParser.MulAssign, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DivAssign() { return GetToken(C_GrammarParser.DivAssign, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ModAssign() { return GetToken(C_GrammarParser.ModAssign, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode AddAssign() { return GetToken(C_GrammarParser.AddAssign, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SubAssign() { return GetToken(C_GrammarParser.SubAssign, 0); }
		public AssignmentOperatorContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_assignmentOperator; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.EnterAssignmentOperator(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.ExitAssignmentOperator(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IC_GrammarVisitor<TResult> typedVisitor = visitor as IC_GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAssignmentOperator(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public AssignmentOperatorContext assignmentOperator() {
		AssignmentOperatorContext _localctx = new AssignmentOperatorContext(Context, State);
		EnterRule(_localctx, 106, RULE_assignmentOperator);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 653;
			_la = TokenStream.LA(1);
			if ( !(((((_la - 43)) & ~0x3f) == 0 && ((1L << (_la - 43)) & 2080374785L) != 0)) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class AssignmentExpressionContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ConditionalExpressionContext conditionalExpression() {
			return GetRuleContext<ConditionalExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public UnaryExpressionContext unaryExpression() {
			return GetRuleContext<UnaryExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public AssignmentOperatorContext assignmentOperator() {
			return GetRuleContext<AssignmentOperatorContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public AssignmentExpressionContext assignmentExpression() {
			return GetRuleContext<AssignmentExpressionContext>(0);
		}
		public AssignmentExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_assignmentExpression; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.EnterAssignmentExpression(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.ExitAssignmentExpression(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IC_GrammarVisitor<TResult> typedVisitor = visitor as IC_GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAssignmentExpression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public AssignmentExpressionContext assignmentExpression() {
		AssignmentExpressionContext _localctx = new AssignmentExpressionContext(Context, State);
		EnterRule(_localctx, 108, RULE_assignmentExpression);
		try {
			State = 660;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,47,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 655;
				conditionalExpression();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 656;
				unaryExpression();
				State = 657;
				assignmentOperator();
				State = 658;
				assignmentExpression();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ConditionalExpressionContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public LogicalOrExpressionContext logicalOrExpression() {
			return GetRuleContext<LogicalOrExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode QuestionMark() { return GetToken(C_GrammarParser.QuestionMark, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Colon() { return GetToken(C_GrammarParser.Colon, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ConditionalExpressionContext conditionalExpression() {
			return GetRuleContext<ConditionalExpressionContext>(0);
		}
		public ConditionalExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_conditionalExpression; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.EnterConditionalExpression(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.ExitConditionalExpression(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IC_GrammarVisitor<TResult> typedVisitor = visitor as IC_GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitConditionalExpression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ConditionalExpressionContext conditionalExpression() {
		ConditionalExpressionContext _localctx = new ConditionalExpressionContext(Context, State);
		EnterRule(_localctx, 110, RULE_conditionalExpression);
		try {
			State = 669;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,48,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 662;
				logicalOrExpression(0);
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 663;
				logicalOrExpression(0);
				State = 664;
				Match(QuestionMark);
				State = 665;
				expression(0);
				State = 666;
				Match(Colon);
				State = 667;
				conditionalExpression();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class LogicalOrExpressionContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public LogicalAndExpressionContext logicalAndExpression() {
			return GetRuleContext<LogicalAndExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public LogicalOrExpressionContext logicalOrExpression() {
			return GetRuleContext<LogicalOrExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode OrOp() { return GetToken(C_GrammarParser.OrOp, 0); }
		public LogicalOrExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_logicalOrExpression; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.EnterLogicalOrExpression(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.ExitLogicalOrExpression(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IC_GrammarVisitor<TResult> typedVisitor = visitor as IC_GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitLogicalOrExpression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public LogicalOrExpressionContext logicalOrExpression() {
		return logicalOrExpression(0);
	}

	private LogicalOrExpressionContext logicalOrExpression(int _p) {
		ParserRuleContext _parentctx = Context;
		int _parentState = State;
		LogicalOrExpressionContext _localctx = new LogicalOrExpressionContext(Context, _parentState);
		LogicalOrExpressionContext _prevctx = _localctx;
		int _startState = 112;
		EnterRecursionRule(_localctx, 112, RULE_logicalOrExpression, _p);
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			{
			State = 672;
			logicalAndExpression(0);
			}
			Context.Stop = TokenStream.LT(-1);
			State = 679;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,49,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					if ( ParseListeners!=null )
						TriggerExitRuleEvent();
					_prevctx = _localctx;
					{
					{
					_localctx = new LogicalOrExpressionContext(_parentctx, _parentState);
					PushNewRecursionContext(_localctx, _startState, RULE_logicalOrExpression);
					State = 674;
					if (!(Precpred(Context, 1))) throw new FailedPredicateException(this, "Precpred(Context, 1)");
					State = 675;
					Match(OrOp);
					State = 676;
					logicalAndExpression(0);
					}
					} 
				}
				State = 681;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,49,Context);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			UnrollRecursionContexts(_parentctx);
		}
		return _localctx;
	}

	public partial class LogicalAndExpressionContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public EqualityExpressionContext equalityExpression() {
			return GetRuleContext<EqualityExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public LogicalAndExpressionContext logicalAndExpression() {
			return GetRuleContext<LogicalAndExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode AndOp() { return GetToken(C_GrammarParser.AndOp, 0); }
		public LogicalAndExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_logicalAndExpression; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.EnterLogicalAndExpression(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.ExitLogicalAndExpression(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IC_GrammarVisitor<TResult> typedVisitor = visitor as IC_GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitLogicalAndExpression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public LogicalAndExpressionContext logicalAndExpression() {
		return logicalAndExpression(0);
	}

	private LogicalAndExpressionContext logicalAndExpression(int _p) {
		ParserRuleContext _parentctx = Context;
		int _parentState = State;
		LogicalAndExpressionContext _localctx = new LogicalAndExpressionContext(Context, _parentState);
		LogicalAndExpressionContext _prevctx = _localctx;
		int _startState = 114;
		EnterRecursionRule(_localctx, 114, RULE_logicalAndExpression, _p);
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			{
			State = 683;
			equalityExpression(0);
			}
			Context.Stop = TokenStream.LT(-1);
			State = 690;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,50,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					if ( ParseListeners!=null )
						TriggerExitRuleEvent();
					_prevctx = _localctx;
					{
					{
					_localctx = new LogicalAndExpressionContext(_parentctx, _parentState);
					PushNewRecursionContext(_localctx, _startState, RULE_logicalAndExpression);
					State = 685;
					if (!(Precpred(Context, 1))) throw new FailedPredicateException(this, "Precpred(Context, 1)");
					State = 686;
					Match(AndOp);
					State = 687;
					equalityExpression(0);
					}
					} 
				}
				State = 692;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,50,Context);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			UnrollRecursionContexts(_parentctx);
		}
		return _localctx;
	}

	public partial class EqualityExpressionContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public RelationalExpressionContext relationalExpression() {
			return GetRuleContext<RelationalExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public EqualityExpressionContext equalityExpression() {
			return GetRuleContext<EqualityExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode EqOp() { return GetToken(C_GrammarParser.EqOp, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NeOp() { return GetToken(C_GrammarParser.NeOp, 0); }
		public EqualityExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_equalityExpression; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.EnterEqualityExpression(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.ExitEqualityExpression(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IC_GrammarVisitor<TResult> typedVisitor = visitor as IC_GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitEqualityExpression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public EqualityExpressionContext equalityExpression() {
		return equalityExpression(0);
	}

	private EqualityExpressionContext equalityExpression(int _p) {
		ParserRuleContext _parentctx = Context;
		int _parentState = State;
		EqualityExpressionContext _localctx = new EqualityExpressionContext(Context, _parentState);
		EqualityExpressionContext _prevctx = _localctx;
		int _startState = 116;
		EnterRecursionRule(_localctx, 116, RULE_equalityExpression, _p);
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			{
			State = 694;
			relationalExpression(0);
			}
			Context.Stop = TokenStream.LT(-1);
			State = 704;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,52,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					if ( ParseListeners!=null )
						TriggerExitRuleEvent();
					_prevctx = _localctx;
					{
					State = 702;
					ErrorHandler.Sync(this);
					switch ( Interpreter.AdaptivePredict(TokenStream,51,Context) ) {
					case 1:
						{
						_localctx = new EqualityExpressionContext(_parentctx, _parentState);
						PushNewRecursionContext(_localctx, _startState, RULE_equalityExpression);
						State = 696;
						if (!(Precpred(Context, 2))) throw new FailedPredicateException(this, "Precpred(Context, 2)");
						State = 697;
						Match(EqOp);
						State = 698;
						relationalExpression(0);
						}
						break;
					case 2:
						{
						_localctx = new EqualityExpressionContext(_parentctx, _parentState);
						PushNewRecursionContext(_localctx, _startState, RULE_equalityExpression);
						State = 699;
						if (!(Precpred(Context, 1))) throw new FailedPredicateException(this, "Precpred(Context, 1)");
						State = 700;
						Match(NeOp);
						State = 701;
						relationalExpression(0);
						}
						break;
					}
					} 
				}
				State = 706;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,52,Context);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			UnrollRecursionContexts(_parentctx);
		}
		return _localctx;
	}

	public partial class RelationalExpressionContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public AdditiveExpressionContext additiveExpression() {
			return GetRuleContext<AdditiveExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public RelationalExpressionContext relationalExpression() {
			return GetRuleContext<RelationalExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Less() { return GetToken(C_GrammarParser.Less, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Greater() { return GetToken(C_GrammarParser.Greater, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LeOp() { return GetToken(C_GrammarParser.LeOp, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode GeOp() { return GetToken(C_GrammarParser.GeOp, 0); }
		public RelationalExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_relationalExpression; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.EnterRelationalExpression(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.ExitRelationalExpression(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IC_GrammarVisitor<TResult> typedVisitor = visitor as IC_GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitRelationalExpression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public RelationalExpressionContext relationalExpression() {
		return relationalExpression(0);
	}

	private RelationalExpressionContext relationalExpression(int _p) {
		ParserRuleContext _parentctx = Context;
		int _parentState = State;
		RelationalExpressionContext _localctx = new RelationalExpressionContext(Context, _parentState);
		RelationalExpressionContext _prevctx = _localctx;
		int _startState = 118;
		EnterRecursionRule(_localctx, 118, RULE_relationalExpression, _p);
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			{
			State = 708;
			additiveExpression(0);
			}
			Context.Stop = TokenStream.LT(-1);
			State = 724;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,54,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					if ( ParseListeners!=null )
						TriggerExitRuleEvent();
					_prevctx = _localctx;
					{
					State = 722;
					ErrorHandler.Sync(this);
					switch ( Interpreter.AdaptivePredict(TokenStream,53,Context) ) {
					case 1:
						{
						_localctx = new RelationalExpressionContext(_parentctx, _parentState);
						PushNewRecursionContext(_localctx, _startState, RULE_relationalExpression);
						State = 710;
						if (!(Precpred(Context, 4))) throw new FailedPredicateException(this, "Precpred(Context, 4)");
						State = 711;
						Match(Less);
						State = 712;
						additiveExpression(0);
						}
						break;
					case 2:
						{
						_localctx = new RelationalExpressionContext(_parentctx, _parentState);
						PushNewRecursionContext(_localctx, _startState, RULE_relationalExpression);
						State = 713;
						if (!(Precpred(Context, 3))) throw new FailedPredicateException(this, "Precpred(Context, 3)");
						State = 714;
						Match(Greater);
						State = 715;
						additiveExpression(0);
						}
						break;
					case 3:
						{
						_localctx = new RelationalExpressionContext(_parentctx, _parentState);
						PushNewRecursionContext(_localctx, _startState, RULE_relationalExpression);
						State = 716;
						if (!(Precpred(Context, 2))) throw new FailedPredicateException(this, "Precpred(Context, 2)");
						State = 717;
						Match(LeOp);
						State = 718;
						additiveExpression(0);
						}
						break;
					case 4:
						{
						_localctx = new RelationalExpressionContext(_parentctx, _parentState);
						PushNewRecursionContext(_localctx, _startState, RULE_relationalExpression);
						State = 719;
						if (!(Precpred(Context, 1))) throw new FailedPredicateException(this, "Precpred(Context, 1)");
						State = 720;
						Match(GeOp);
						State = 721;
						additiveExpression(0);
						}
						break;
					}
					} 
				}
				State = 726;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,54,Context);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			UnrollRecursionContexts(_parentctx);
		}
		return _localctx;
	}

	public partial class AdditiveExpressionContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public MultiplicativeExpressionContext multiplicativeExpression() {
			return GetRuleContext<MultiplicativeExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public AdditiveExpressionContext additiveExpression() {
			return GetRuleContext<AdditiveExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Plus() { return GetToken(C_GrammarParser.Plus, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Minus() { return GetToken(C_GrammarParser.Minus, 0); }
		public AdditiveExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_additiveExpression; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.EnterAdditiveExpression(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.ExitAdditiveExpression(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IC_GrammarVisitor<TResult> typedVisitor = visitor as IC_GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAdditiveExpression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public AdditiveExpressionContext additiveExpression() {
		return additiveExpression(0);
	}

	private AdditiveExpressionContext additiveExpression(int _p) {
		ParserRuleContext _parentctx = Context;
		int _parentState = State;
		AdditiveExpressionContext _localctx = new AdditiveExpressionContext(Context, _parentState);
		AdditiveExpressionContext _prevctx = _localctx;
		int _startState = 120;
		EnterRecursionRule(_localctx, 120, RULE_additiveExpression, _p);
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			{
			State = 728;
			multiplicativeExpression(0);
			}
			Context.Stop = TokenStream.LT(-1);
			State = 738;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,56,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					if ( ParseListeners!=null )
						TriggerExitRuleEvent();
					_prevctx = _localctx;
					{
					State = 736;
					ErrorHandler.Sync(this);
					switch ( Interpreter.AdaptivePredict(TokenStream,55,Context) ) {
					case 1:
						{
						_localctx = new AdditiveExpressionContext(_parentctx, _parentState);
						PushNewRecursionContext(_localctx, _startState, RULE_additiveExpression);
						State = 730;
						if (!(Precpred(Context, 2))) throw new FailedPredicateException(this, "Precpred(Context, 2)");
						State = 731;
						Match(Plus);
						State = 732;
						multiplicativeExpression(0);
						}
						break;
					case 2:
						{
						_localctx = new AdditiveExpressionContext(_parentctx, _parentState);
						PushNewRecursionContext(_localctx, _startState, RULE_additiveExpression);
						State = 733;
						if (!(Precpred(Context, 1))) throw new FailedPredicateException(this, "Precpred(Context, 1)");
						State = 734;
						Match(Minus);
						State = 735;
						multiplicativeExpression(0);
						}
						break;
					}
					} 
				}
				State = 740;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,56,Context);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			UnrollRecursionContexts(_parentctx);
		}
		return _localctx;
	}

	public partial class MultiplicativeExpressionContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public CastExpressionContext castExpression() {
			return GetRuleContext<CastExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public MultiplicativeExpressionContext multiplicativeExpression() {
			return GetRuleContext<MultiplicativeExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Multiply() { return GetToken(C_GrammarParser.Multiply, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Divide() { return GetToken(C_GrammarParser.Divide, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Mod() { return GetToken(C_GrammarParser.Mod, 0); }
		public MultiplicativeExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_multiplicativeExpression; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.EnterMultiplicativeExpression(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.ExitMultiplicativeExpression(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IC_GrammarVisitor<TResult> typedVisitor = visitor as IC_GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitMultiplicativeExpression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public MultiplicativeExpressionContext multiplicativeExpression() {
		return multiplicativeExpression(0);
	}

	private MultiplicativeExpressionContext multiplicativeExpression(int _p) {
		ParserRuleContext _parentctx = Context;
		int _parentState = State;
		MultiplicativeExpressionContext _localctx = new MultiplicativeExpressionContext(Context, _parentState);
		MultiplicativeExpressionContext _prevctx = _localctx;
		int _startState = 122;
		EnterRecursionRule(_localctx, 122, RULE_multiplicativeExpression, _p);
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			{
			State = 742;
			castExpression();
			}
			Context.Stop = TokenStream.LT(-1);
			State = 755;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,58,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					if ( ParseListeners!=null )
						TriggerExitRuleEvent();
					_prevctx = _localctx;
					{
					State = 753;
					ErrorHandler.Sync(this);
					switch ( Interpreter.AdaptivePredict(TokenStream,57,Context) ) {
					case 1:
						{
						_localctx = new MultiplicativeExpressionContext(_parentctx, _parentState);
						PushNewRecursionContext(_localctx, _startState, RULE_multiplicativeExpression);
						State = 744;
						if (!(Precpred(Context, 3))) throw new FailedPredicateException(this, "Precpred(Context, 3)");
						State = 745;
						Match(Multiply);
						State = 746;
						castExpression();
						}
						break;
					case 2:
						{
						_localctx = new MultiplicativeExpressionContext(_parentctx, _parentState);
						PushNewRecursionContext(_localctx, _startState, RULE_multiplicativeExpression);
						State = 747;
						if (!(Precpred(Context, 2))) throw new FailedPredicateException(this, "Precpred(Context, 2)");
						State = 748;
						Match(Divide);
						State = 749;
						castExpression();
						}
						break;
					case 3:
						{
						_localctx = new MultiplicativeExpressionContext(_parentctx, _parentState);
						PushNewRecursionContext(_localctx, _startState, RULE_multiplicativeExpression);
						State = 750;
						if (!(Precpred(Context, 1))) throw new FailedPredicateException(this, "Precpred(Context, 1)");
						State = 751;
						Match(Mod);
						State = 752;
						castExpression();
						}
						break;
					}
					} 
				}
				State = 757;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,58,Context);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			UnrollRecursionContexts(_parentctx);
		}
		return _localctx;
	}

	public partial class CastExpressionContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public UnaryExpressionContext unaryExpression() {
			return GetRuleContext<UnaryExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LeftParen() { return GetToken(C_GrammarParser.LeftParen, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public TypeNameContext typeName() {
			return GetRuleContext<TypeNameContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RightParen() { return GetToken(C_GrammarParser.RightParen, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public CastExpressionContext castExpression() {
			return GetRuleContext<CastExpressionContext>(0);
		}
		public CastExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_castExpression; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.EnterCastExpression(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.ExitCastExpression(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IC_GrammarVisitor<TResult> typedVisitor = visitor as IC_GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCastExpression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public CastExpressionContext castExpression() {
		CastExpressionContext _localctx = new CastExpressionContext(Context, State);
		EnterRule(_localctx, 124, RULE_castExpression);
		try {
			State = 764;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,59,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 758;
				unaryExpression();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 759;
				Match(LeftParen);
				State = 760;
				typeName();
				State = 761;
				Match(RightParen);
				State = 762;
				castExpression();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class UnaryOperatorContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Ampersand() { return GetToken(C_GrammarParser.Ampersand, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Multiply() { return GetToken(C_GrammarParser.Multiply, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Plus() { return GetToken(C_GrammarParser.Plus, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Minus() { return GetToken(C_GrammarParser.Minus, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Exclamation() { return GetToken(C_GrammarParser.Exclamation, 0); }
		public UnaryOperatorContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_unaryOperator; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.EnterUnaryOperator(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.ExitUnaryOperator(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IC_GrammarVisitor<TResult> typedVisitor = visitor as IC_GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitUnaryOperator(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public UnaryOperatorContext unaryOperator() {
		UnaryOperatorContext _localctx = new UnaryOperatorContext(Context, State);
		EnterRule(_localctx, 126, RULE_unaryOperator);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 766;
			_la = TokenStream.LA(1);
			if ( !((((_la) & ~0x3f) == 0 && ((1L << _la) & 1225893892319084544L) != 0)) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class UnaryExpressionContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public PostfixExpressionContext postfixExpression() {
			return GetRuleContext<PostfixExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode IncOp() { return GetToken(C_GrammarParser.IncOp, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public UnaryExpressionContext unaryExpression() {
			return GetRuleContext<UnaryExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DecOp() { return GetToken(C_GrammarParser.DecOp, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public UnaryOperatorContext unaryOperator() {
			return GetRuleContext<UnaryOperatorContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public CastExpressionContext castExpression() {
			return GetRuleContext<CastExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Sizeof() { return GetToken(C_GrammarParser.Sizeof, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LeftParen() { return GetToken(C_GrammarParser.LeftParen, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public TypeNameContext typeName() {
			return GetRuleContext<TypeNameContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RightParen() { return GetToken(C_GrammarParser.RightParen, 0); }
		public UnaryExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_unaryExpression; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.EnterUnaryExpression(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.ExitUnaryExpression(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IC_GrammarVisitor<TResult> typedVisitor = visitor as IC_GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitUnaryExpression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public UnaryExpressionContext unaryExpression() {
		UnaryExpressionContext _localctx = new UnaryExpressionContext(Context, State);
		EnterRule(_localctx, 128, RULE_unaryExpression);
		try {
			State = 783;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,60,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 768;
				postfixExpression(0);
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 769;
				Match(IncOp);
				State = 770;
				unaryExpression();
				}
				break;
			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 771;
				Match(DecOp);
				State = 772;
				unaryExpression();
				}
				break;
			case 4:
				EnterOuterAlt(_localctx, 4);
				{
				State = 773;
				unaryOperator();
				State = 774;
				castExpression();
				}
				break;
			case 5:
				EnterOuterAlt(_localctx, 5);
				{
				State = 776;
				Match(Sizeof);
				State = 777;
				unaryExpression();
				}
				break;
			case 6:
				EnterOuterAlt(_localctx, 6);
				{
				State = 778;
				Match(Sizeof);
				State = 779;
				Match(LeftParen);
				State = 780;
				typeName();
				State = 781;
				Match(RightParen);
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ArgumentExpressionListContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public AssignmentExpressionContext assignmentExpression() {
			return GetRuleContext<AssignmentExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ArgumentExpressionListContext argumentExpressionList() {
			return GetRuleContext<ArgumentExpressionListContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Comma() { return GetToken(C_GrammarParser.Comma, 0); }
		public ArgumentExpressionListContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_argumentExpressionList; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.EnterArgumentExpressionList(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.ExitArgumentExpressionList(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IC_GrammarVisitor<TResult> typedVisitor = visitor as IC_GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitArgumentExpressionList(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ArgumentExpressionListContext argumentExpressionList() {
		return argumentExpressionList(0);
	}

	private ArgumentExpressionListContext argumentExpressionList(int _p) {
		ParserRuleContext _parentctx = Context;
		int _parentState = State;
		ArgumentExpressionListContext _localctx = new ArgumentExpressionListContext(Context, _parentState);
		ArgumentExpressionListContext _prevctx = _localctx;
		int _startState = 130;
		EnterRecursionRule(_localctx, 130, RULE_argumentExpressionList, _p);
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			{
			State = 786;
			assignmentExpression();
			}
			Context.Stop = TokenStream.LT(-1);
			State = 793;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,61,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					if ( ParseListeners!=null )
						TriggerExitRuleEvent();
					_prevctx = _localctx;
					{
					{
					_localctx = new ArgumentExpressionListContext(_parentctx, _parentState);
					PushNewRecursionContext(_localctx, _startState, RULE_argumentExpressionList);
					State = 788;
					if (!(Precpred(Context, 1))) throw new FailedPredicateException(this, "Precpred(Context, 1)");
					State = 789;
					Match(Comma);
					State = 790;
					assignmentExpression();
					}
					} 
				}
				State = 795;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,61,Context);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			UnrollRecursionContexts(_parentctx);
		}
		return _localctx;
	}

	public partial class PostfixExpressionContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public PrimaryExpressionContext primaryExpression() {
			return GetRuleContext<PrimaryExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public PostfixExpressionContext postfixExpression() {
			return GetRuleContext<PostfixExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LeftBracket() { return GetToken(C_GrammarParser.LeftBracket, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RightBracket() { return GetToken(C_GrammarParser.RightBracket, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LeftParen() { return GetToken(C_GrammarParser.LeftParen, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RightParen() { return GetToken(C_GrammarParser.RightParen, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ArgumentExpressionListContext argumentExpressionList() {
			return GetRuleContext<ArgumentExpressionListContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Dot() { return GetToken(C_GrammarParser.Dot, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Identifier() { return GetToken(C_GrammarParser.Identifier, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Arrow() { return GetToken(C_GrammarParser.Arrow, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode IncOp() { return GetToken(C_GrammarParser.IncOp, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DecOp() { return GetToken(C_GrammarParser.DecOp, 0); }
		public PostfixExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_postfixExpression; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.EnterPostfixExpression(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.ExitPostfixExpression(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IC_GrammarVisitor<TResult> typedVisitor = visitor as IC_GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitPostfixExpression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public PostfixExpressionContext postfixExpression() {
		return postfixExpression(0);
	}

	private PostfixExpressionContext postfixExpression(int _p) {
		ParserRuleContext _parentctx = Context;
		int _parentState = State;
		PostfixExpressionContext _localctx = new PostfixExpressionContext(Context, _parentState);
		PostfixExpressionContext _prevctx = _localctx;
		int _startState = 132;
		EnterRecursionRule(_localctx, 132, RULE_postfixExpression, _p);
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			{
			State = 797;
			primaryExpression();
			}
			Context.Stop = TokenStream.LT(-1);
			State = 824;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,63,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					if ( ParseListeners!=null )
						TriggerExitRuleEvent();
					_prevctx = _localctx;
					{
					State = 822;
					ErrorHandler.Sync(this);
					switch ( Interpreter.AdaptivePredict(TokenStream,62,Context) ) {
					case 1:
						{
						_localctx = new PostfixExpressionContext(_parentctx, _parentState);
						PushNewRecursionContext(_localctx, _startState, RULE_postfixExpression);
						State = 799;
						if (!(Precpred(Context, 7))) throw new FailedPredicateException(this, "Precpred(Context, 7)");
						State = 800;
						Match(LeftBracket);
						State = 801;
						expression(0);
						State = 802;
						Match(RightBracket);
						}
						break;
					case 2:
						{
						_localctx = new PostfixExpressionContext(_parentctx, _parentState);
						PushNewRecursionContext(_localctx, _startState, RULE_postfixExpression);
						State = 804;
						if (!(Precpred(Context, 6))) throw new FailedPredicateException(this, "Precpred(Context, 6)");
						State = 805;
						Match(LeftParen);
						State = 806;
						Match(RightParen);
						}
						break;
					case 3:
						{
						_localctx = new PostfixExpressionContext(_parentctx, _parentState);
						PushNewRecursionContext(_localctx, _startState, RULE_postfixExpression);
						State = 807;
						if (!(Precpred(Context, 5))) throw new FailedPredicateException(this, "Precpred(Context, 5)");
						State = 808;
						Match(LeftParen);
						State = 809;
						argumentExpressionList(0);
						State = 810;
						Match(RightParen);
						}
						break;
					case 4:
						{
						_localctx = new PostfixExpressionContext(_parentctx, _parentState);
						PushNewRecursionContext(_localctx, _startState, RULE_postfixExpression);
						State = 812;
						if (!(Precpred(Context, 4))) throw new FailedPredicateException(this, "Precpred(Context, 4)");
						State = 813;
						Match(Dot);
						State = 814;
						Match(Identifier);
						}
						break;
					case 5:
						{
						_localctx = new PostfixExpressionContext(_parentctx, _parentState);
						PushNewRecursionContext(_localctx, _startState, RULE_postfixExpression);
						State = 815;
						if (!(Precpred(Context, 3))) throw new FailedPredicateException(this, "Precpred(Context, 3)");
						State = 816;
						Match(Arrow);
						State = 817;
						Match(Identifier);
						}
						break;
					case 6:
						{
						_localctx = new PostfixExpressionContext(_parentctx, _parentState);
						PushNewRecursionContext(_localctx, _startState, RULE_postfixExpression);
						State = 818;
						if (!(Precpred(Context, 2))) throw new FailedPredicateException(this, "Precpred(Context, 2)");
						State = 819;
						Match(IncOp);
						}
						break;
					case 7:
						{
						_localctx = new PostfixExpressionContext(_parentctx, _parentState);
						PushNewRecursionContext(_localctx, _startState, RULE_postfixExpression);
						State = 820;
						if (!(Precpred(Context, 1))) throw new FailedPredicateException(this, "Precpred(Context, 1)");
						State = 821;
						Match(DecOp);
						}
						break;
					}
					} 
				}
				State = 826;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,63,Context);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			UnrollRecursionContexts(_parentctx);
		}
		return _localctx;
	}

	public partial class PrimaryExpressionContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Identifier() { return GetToken(C_GrammarParser.Identifier, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Constant() { return GetToken(C_GrammarParser.Constant, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode StringLiteral() { return GetToken(C_GrammarParser.StringLiteral, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LeftParen() { return GetToken(C_GrammarParser.LeftParen, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RightParen() { return GetToken(C_GrammarParser.RightParen, 0); }
		public PrimaryExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_primaryExpression; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.EnterPrimaryExpression(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.ExitPrimaryExpression(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IC_GrammarVisitor<TResult> typedVisitor = visitor as IC_GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitPrimaryExpression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public PrimaryExpressionContext primaryExpression() {
		PrimaryExpressionContext _localctx = new PrimaryExpressionContext(Context, State);
		EnterRule(_localctx, 134, RULE_primaryExpression);
		try {
			State = 834;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case Identifier:
				EnterOuterAlt(_localctx, 1);
				{
				State = 827;
				Match(Identifier);
				}
				break;
			case Constant:
				EnterOuterAlt(_localctx, 2);
				{
				State = 828;
				Match(Constant);
				}
				break;
			case StringLiteral:
				EnterOuterAlt(_localctx, 3);
				{
				State = 829;
				Match(StringLiteral);
				}
				break;
			case LeftParen:
				EnterOuterAlt(_localctx, 4);
				{
				State = 830;
				Match(LeftParen);
				State = 831;
				expression(0);
				State = 832;
				Match(RightParen);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public override bool Sempred(RuleContext _localctx, int ruleIndex, int predIndex) {
		switch (ruleIndex) {
		case 1: return translationUnit_sempred((TranslationUnitContext)_localctx, predIndex);
		case 19: return statementList_sempred((StatementListContext)_localctx, predIndex);
		case 20: return declarationList_sempred((DeclarationListContext)_localctx, predIndex);
		case 22: return blockItemList_sempred((BlockItemListContext)_localctx, predIndex);
		case 26: return initializerList_sempred((InitializerListContext)_localctx, predIndex);
		case 28: return directAbstractDeclarator_sempred((DirectAbstractDeclaratorContext)_localctx, predIndex);
		case 30: return identifierList_sempred((IdentifierListContext)_localctx, predIndex);
		case 32: return parameterList_sempred((ParameterListContext)_localctx, predIndex);
		case 33: return typeQualifierList_sempred((TypeQualifierListContext)_localctx, predIndex);
		case 35: return directDeclarator_sempred((DirectDeclaratorContext)_localctx, predIndex);
		case 39: return structDeclarationList_sempred((StructDeclarationListContext)_localctx, predIndex);
		case 41: return structDeclaratorList_sempred((StructDeclaratorListContext)_localctx, predIndex);
		case 48: return initDeclaratorList_sempred((InitDeclaratorListContext)_localctx, predIndex);
		case 52: return expression_sempred((ExpressionContext)_localctx, predIndex);
		case 56: return logicalOrExpression_sempred((LogicalOrExpressionContext)_localctx, predIndex);
		case 57: return logicalAndExpression_sempred((LogicalAndExpressionContext)_localctx, predIndex);
		case 58: return equalityExpression_sempred((EqualityExpressionContext)_localctx, predIndex);
		case 59: return relationalExpression_sempred((RelationalExpressionContext)_localctx, predIndex);
		case 60: return additiveExpression_sempred((AdditiveExpressionContext)_localctx, predIndex);
		case 61: return multiplicativeExpression_sempred((MultiplicativeExpressionContext)_localctx, predIndex);
		case 65: return argumentExpressionList_sempred((ArgumentExpressionListContext)_localctx, predIndex);
		case 66: return postfixExpression_sempred((PostfixExpressionContext)_localctx, predIndex);
		}
		return true;
	}
	private bool translationUnit_sempred(TranslationUnitContext _localctx, int predIndex) {
		switch (predIndex) {
		case 0: return Precpred(Context, 2);
		case 1: return Precpred(Context, 1);
		}
		return true;
	}
	private bool statementList_sempred(StatementListContext _localctx, int predIndex) {
		switch (predIndex) {
		case 2: return Precpred(Context, 1);
		}
		return true;
	}
	private bool declarationList_sempred(DeclarationListContext _localctx, int predIndex) {
		switch (predIndex) {
		case 3: return Precpred(Context, 1);
		}
		return true;
	}
	private bool blockItemList_sempred(BlockItemListContext _localctx, int predIndex) {
		switch (predIndex) {
		case 4: return Precpred(Context, 1);
		}
		return true;
	}
	private bool initializerList_sempred(InitializerListContext _localctx, int predIndex) {
		switch (predIndex) {
		case 5: return Precpred(Context, 1);
		}
		return true;
	}
	private bool directAbstractDeclarator_sempred(DirectAbstractDeclaratorContext _localctx, int predIndex) {
		switch (predIndex) {
		case 6: return Precpred(Context, 6);
		case 7: return Precpred(Context, 5);
		case 8: return Precpred(Context, 2);
		case 9: return Precpred(Context, 1);
		}
		return true;
	}
	private bool identifierList_sempred(IdentifierListContext _localctx, int predIndex) {
		switch (predIndex) {
		case 10: return Precpred(Context, 1);
		}
		return true;
	}
	private bool parameterList_sempred(ParameterListContext _localctx, int predIndex) {
		switch (predIndex) {
		case 11: return Precpred(Context, 1);
		}
		return true;
	}
	private bool typeQualifierList_sempred(TypeQualifierListContext _localctx, int predIndex) {
		switch (predIndex) {
		case 12: return Precpred(Context, 1);
		}
		return true;
	}
	private bool directDeclarator_sempred(DirectDeclaratorContext _localctx, int predIndex) {
		switch (predIndex) {
		case 13: return Precpred(Context, 5);
		case 14: return Precpred(Context, 4);
		case 15: return Precpred(Context, 3);
		case 16: return Precpred(Context, 2);
		case 17: return Precpred(Context, 1);
		}
		return true;
	}
	private bool structDeclarationList_sempred(StructDeclarationListContext _localctx, int predIndex) {
		switch (predIndex) {
		case 18: return Precpred(Context, 1);
		}
		return true;
	}
	private bool structDeclaratorList_sempred(StructDeclaratorListContext _localctx, int predIndex) {
		switch (predIndex) {
		case 19: return Precpred(Context, 1);
		}
		return true;
	}
	private bool initDeclaratorList_sempred(InitDeclaratorListContext _localctx, int predIndex) {
		switch (predIndex) {
		case 20: return Precpred(Context, 1);
		}
		return true;
	}
	private bool expression_sempred(ExpressionContext _localctx, int predIndex) {
		switch (predIndex) {
		case 21: return Precpred(Context, 1);
		}
		return true;
	}
	private bool logicalOrExpression_sempred(LogicalOrExpressionContext _localctx, int predIndex) {
		switch (predIndex) {
		case 22: return Precpred(Context, 1);
		}
		return true;
	}
	private bool logicalAndExpression_sempred(LogicalAndExpressionContext _localctx, int predIndex) {
		switch (predIndex) {
		case 23: return Precpred(Context, 1);
		}
		return true;
	}
	private bool equalityExpression_sempred(EqualityExpressionContext _localctx, int predIndex) {
		switch (predIndex) {
		case 24: return Precpred(Context, 2);
		case 25: return Precpred(Context, 1);
		}
		return true;
	}
	private bool relationalExpression_sempred(RelationalExpressionContext _localctx, int predIndex) {
		switch (predIndex) {
		case 26: return Precpred(Context, 4);
		case 27: return Precpred(Context, 3);
		case 28: return Precpred(Context, 2);
		case 29: return Precpred(Context, 1);
		}
		return true;
	}
	private bool additiveExpression_sempred(AdditiveExpressionContext _localctx, int predIndex) {
		switch (predIndex) {
		case 30: return Precpred(Context, 2);
		case 31: return Precpred(Context, 1);
		}
		return true;
	}
	private bool multiplicativeExpression_sempred(MultiplicativeExpressionContext _localctx, int predIndex) {
		switch (predIndex) {
		case 32: return Precpred(Context, 3);
		case 33: return Precpred(Context, 2);
		case 34: return Precpred(Context, 1);
		}
		return true;
	}
	private bool argumentExpressionList_sempred(ArgumentExpressionListContext _localctx, int predIndex) {
		switch (predIndex) {
		case 35: return Precpred(Context, 1);
		}
		return true;
	}
	private bool postfixExpression_sempred(PostfixExpressionContext _localctx, int predIndex) {
		switch (predIndex) {
		case 36: return Precpred(Context, 7);
		case 37: return Precpred(Context, 6);
		case 38: return Precpred(Context, 5);
		case 39: return Precpred(Context, 4);
		case 40: return Precpred(Context, 3);
		case 41: return Precpred(Context, 2);
		case 42: return Precpred(Context, 1);
		}
		return true;
	}

	private static int[] _serializedATN = {
		4,1,82,837,2,0,7,0,2,1,7,1,2,2,7,2,2,3,7,3,2,4,7,4,2,5,7,5,2,6,7,6,2,7,
		7,7,2,8,7,8,2,9,7,9,2,10,7,10,2,11,7,11,2,12,7,12,2,13,7,13,2,14,7,14,
		2,15,7,15,2,16,7,16,2,17,7,17,2,18,7,18,2,19,7,19,2,20,7,20,2,21,7,21,
		2,22,7,22,2,23,7,23,2,24,7,24,2,25,7,25,2,26,7,26,2,27,7,27,2,28,7,28,
		2,29,7,29,2,30,7,30,2,31,7,31,2,32,7,32,2,33,7,33,2,34,7,34,2,35,7,35,
		2,36,7,36,2,37,7,37,2,38,7,38,2,39,7,39,2,40,7,40,2,41,7,41,2,42,7,42,
		2,43,7,43,2,44,7,44,2,45,7,45,2,46,7,46,2,47,7,47,2,48,7,48,2,49,7,49,
		2,50,7,50,2,51,7,51,2,52,7,52,2,53,7,53,2,54,7,54,2,55,7,55,2,56,7,56,
		2,57,7,57,2,58,7,58,2,59,7,59,2,60,7,60,2,61,7,61,2,62,7,62,2,63,7,63,
		2,64,7,64,2,65,7,65,2,66,7,66,2,67,7,67,1,0,3,0,138,8,0,1,0,1,0,1,1,1,
		1,1,1,3,1,145,8,1,1,1,1,1,1,1,1,1,5,1,151,8,1,10,1,12,1,154,9,1,1,2,1,
		2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,3,2,165,8,2,1,3,1,3,1,3,1,4,1,4,1,4,1,5,
		1,5,1,5,1,6,1,6,1,6,1,7,1,7,1,8,1,8,1,8,1,9,1,9,1,10,1,10,1,10,1,10,1,
		11,1,11,1,11,1,11,1,11,1,12,1,12,1,13,1,13,3,13,199,8,13,1,14,1,14,1,14,
		1,14,1,14,1,14,1,14,1,14,1,14,1,14,1,14,1,14,1,14,1,14,1,14,1,14,3,14,
		217,8,14,1,15,1,15,1,15,1,15,1,15,1,15,1,15,1,15,1,15,1,15,3,15,229,8,
		15,1,16,1,16,1,16,1,16,1,16,1,16,1,16,1,16,1,16,1,16,1,16,1,16,1,16,1,
		16,1,16,1,16,1,16,1,16,3,16,249,8,16,1,16,1,16,1,16,1,16,1,16,1,16,1,16,
		1,16,3,16,259,8,16,1,16,1,16,1,16,1,16,1,16,3,16,266,8,16,1,17,1,17,1,
		17,1,17,1,17,1,17,1,17,1,17,1,17,1,17,1,17,1,17,1,17,1,17,1,17,1,17,1,
		17,1,17,1,17,1,17,3,17,288,8,17,1,18,1,18,1,18,1,18,3,18,294,8,18,1,19,
		1,19,1,19,1,19,1,19,5,19,301,8,19,10,19,12,19,304,9,19,1,20,1,20,1,20,
		1,20,1,20,5,20,311,8,20,10,20,12,20,314,9,20,1,21,1,21,3,21,318,8,21,1,
		21,1,21,1,22,1,22,1,22,1,22,1,22,5,22,327,8,22,10,22,12,22,330,9,22,1,
		23,1,23,3,23,334,8,23,1,24,1,24,1,24,1,24,1,24,1,24,1,24,1,24,1,24,1,24,
		1,24,3,24,347,8,24,1,25,1,25,1,25,1,25,1,25,1,25,3,25,355,8,25,1,26,1,
		26,1,26,1,26,1,26,1,26,5,26,363,8,26,10,26,12,26,366,9,26,1,27,1,27,1,
		27,1,27,1,27,1,27,1,27,1,27,1,27,1,27,3,27,378,8,27,1,28,1,28,1,28,1,28,
		1,28,1,28,1,28,1,28,1,28,1,28,1,28,1,28,1,28,1,28,1,28,1,28,1,28,3,28,
		397,8,28,1,28,1,28,1,28,1,28,1,28,1,28,1,28,1,28,1,28,1,28,1,28,1,28,1,
		28,1,28,1,28,1,28,5,28,415,8,28,10,28,12,28,418,9,28,1,29,1,29,1,29,1,
		29,1,29,3,29,425,8,29,1,30,1,30,1,30,1,30,1,30,1,30,5,30,433,8,30,10,30,
		12,30,436,9,30,1,31,1,31,1,31,1,31,1,31,1,31,1,31,3,31,445,8,31,1,32,1,
		32,1,32,1,32,1,32,1,32,5,32,453,8,32,10,32,12,32,456,9,32,1,33,1,33,1,
		33,1,33,1,33,5,33,463,8,33,10,33,12,33,466,9,33,1,34,1,34,1,34,1,34,1,
		34,1,34,1,34,1,34,1,34,3,34,477,8,34,1,35,1,35,1,35,1,35,1,35,1,35,3,35,
		485,8,35,1,35,1,35,1,35,1,35,1,35,1,35,1,35,1,35,1,35,1,35,1,35,1,35,1,
		35,1,35,1,35,1,35,1,35,1,35,1,35,1,35,1,35,5,35,508,8,35,10,35,12,35,511,
		9,35,1,36,1,36,1,36,1,36,3,36,517,8,36,1,37,1,37,1,37,1,37,1,37,1,37,1,
		37,3,37,526,8,37,1,38,1,38,1,38,1,38,1,38,1,38,1,38,1,38,1,38,1,38,1,38,
		1,38,1,38,3,38,541,8,38,1,39,1,39,1,39,1,39,1,39,5,39,548,8,39,10,39,12,
		39,551,9,39,1,40,1,40,1,40,1,40,1,41,1,41,1,41,1,41,1,41,1,41,5,41,563,
		8,41,10,41,12,41,566,9,41,1,42,1,42,1,42,1,42,1,42,1,42,1,42,3,42,575,
		8,42,1,43,1,43,1,44,1,44,1,44,1,44,1,44,1,44,1,44,1,44,1,44,1,44,1,44,
		1,44,3,44,591,8,44,1,45,1,45,1,46,1,46,1,46,1,46,3,46,599,8,46,1,47,1,
		47,1,47,1,47,1,47,1,47,1,47,1,47,1,47,1,47,1,47,3,47,612,8,47,1,48,1,48,
		1,48,1,48,1,48,1,48,5,48,620,8,48,10,48,12,48,623,9,48,1,49,1,49,1,49,
		1,49,1,49,3,49,630,8,49,1,50,1,50,1,50,1,50,1,50,1,50,1,50,3,50,639,8,
		50,1,51,1,51,1,52,1,52,1,52,1,52,1,52,1,52,5,52,649,8,52,10,52,12,52,652,
		9,52,1,53,1,53,1,54,1,54,1,54,1,54,1,54,3,54,661,8,54,1,55,1,55,1,55,1,
		55,1,55,1,55,1,55,3,55,670,8,55,1,56,1,56,1,56,1,56,1,56,1,56,5,56,678,
		8,56,10,56,12,56,681,9,56,1,57,1,57,1,57,1,57,1,57,1,57,5,57,689,8,57,
		10,57,12,57,692,9,57,1,58,1,58,1,58,1,58,1,58,1,58,1,58,1,58,1,58,5,58,
		703,8,58,10,58,12,58,706,9,58,1,59,1,59,1,59,1,59,1,59,1,59,1,59,1,59,
		1,59,1,59,1,59,1,59,1,59,1,59,1,59,5,59,723,8,59,10,59,12,59,726,9,59,
		1,60,1,60,1,60,1,60,1,60,1,60,1,60,1,60,1,60,5,60,737,8,60,10,60,12,60,
		740,9,60,1,61,1,61,1,61,1,61,1,61,1,61,1,61,1,61,1,61,1,61,1,61,1,61,5,
		61,754,8,61,10,61,12,61,757,9,61,1,62,1,62,1,62,1,62,1,62,1,62,3,62,765,
		8,62,1,63,1,63,1,64,1,64,1,64,1,64,1,64,1,64,1,64,1,64,1,64,1,64,1,64,
		1,64,1,64,1,64,1,64,3,64,784,8,64,1,65,1,65,1,65,1,65,1,65,1,65,5,65,792,
		8,65,10,65,12,65,795,9,65,1,66,1,66,1,66,1,66,1,66,1,66,1,66,1,66,1,66,
		1,66,1,66,1,66,1,66,1,66,1,66,1,66,1,66,1,66,1,66,1,66,1,66,1,66,1,66,
		1,66,1,66,1,66,5,66,823,8,66,10,66,12,66,826,9,66,1,67,1,67,1,67,1,67,
		1,67,1,67,1,67,3,67,835,8,67,1,67,0,22,2,38,40,44,52,56,60,64,66,70,78,
		82,96,104,112,114,116,118,120,122,130,132,68,0,2,4,6,8,10,12,14,16,18,
		20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52,54,56,58,60,62,64,66,
		68,70,72,74,76,78,80,82,84,86,88,90,92,94,96,98,100,102,104,106,108,110,
		112,114,116,118,120,122,124,126,128,130,132,134,0,3,1,0,12,16,2,0,43,43,
		69,73,4,0,46,46,48,49,56,56,60,60,897,0,137,1,0,0,0,2,144,1,0,0,0,4,164,
		1,0,0,0,6,166,1,0,0,0,8,169,1,0,0,0,10,172,1,0,0,0,12,175,1,0,0,0,14,178,
		1,0,0,0,16,180,1,0,0,0,18,183,1,0,0,0,20,185,1,0,0,0,22,189,1,0,0,0,24,
		194,1,0,0,0,26,198,1,0,0,0,28,216,1,0,0,0,30,228,1,0,0,0,32,265,1,0,0,
		0,34,287,1,0,0,0,36,293,1,0,0,0,38,295,1,0,0,0,40,305,1,0,0,0,42,315,1,
		0,0,0,44,321,1,0,0,0,46,333,1,0,0,0,48,346,1,0,0,0,50,354,1,0,0,0,52,356,
		1,0,0,0,54,377,1,0,0,0,56,396,1,0,0,0,58,424,1,0,0,0,60,426,1,0,0,0,62,
		444,1,0,0,0,64,446,1,0,0,0,66,457,1,0,0,0,68,476,1,0,0,0,70,484,1,0,0,
		0,72,516,1,0,0,0,74,525,1,0,0,0,76,540,1,0,0,0,78,542,1,0,0,0,80,552,1,
		0,0,0,82,556,1,0,0,0,84,574,1,0,0,0,86,576,1,0,0,0,88,590,1,0,0,0,90,592,
		1,0,0,0,92,598,1,0,0,0,94,611,1,0,0,0,96,613,1,0,0,0,98,629,1,0,0,0,100,
		638,1,0,0,0,102,640,1,0,0,0,104,642,1,0,0,0,106,653,1,0,0,0,108,660,1,
		0,0,0,110,669,1,0,0,0,112,671,1,0,0,0,114,682,1,0,0,0,116,693,1,0,0,0,
		118,707,1,0,0,0,120,727,1,0,0,0,122,741,1,0,0,0,124,764,1,0,0,0,126,766,
		1,0,0,0,128,783,1,0,0,0,130,785,1,0,0,0,132,796,1,0,0,0,134,834,1,0,0,
		0,136,138,3,2,1,0,137,136,1,0,0,0,137,138,1,0,0,0,138,139,1,0,0,0,139,
		140,5,0,0,1,140,1,1,0,0,0,141,142,6,1,-1,0,142,145,3,4,2,0,143,145,3,26,
		13,0,144,141,1,0,0,0,144,143,1,0,0,0,145,152,1,0,0,0,146,147,10,2,0,0,
		147,151,3,4,2,0,148,149,10,1,0,0,149,151,3,26,13,0,150,146,1,0,0,0,150,
		148,1,0,0,0,151,154,1,0,0,0,152,150,1,0,0,0,152,153,1,0,0,0,153,3,1,0,
		0,0,154,152,1,0,0,0,155,165,3,22,11,0,156,165,3,20,10,0,157,165,3,6,3,
		0,158,165,3,8,4,0,159,165,3,16,8,0,160,165,3,10,5,0,161,165,3,12,6,0,162,
		165,3,14,7,0,163,165,3,18,9,0,164,155,1,0,0,0,164,156,1,0,0,0,164,157,
		1,0,0,0,164,158,1,0,0,0,164,159,1,0,0,0,164,160,1,0,0,0,164,161,1,0,0,
		0,164,162,1,0,0,0,164,163,1,0,0,0,165,5,1,0,0,0,166,167,5,5,0,0,167,168,
		5,74,0,0,168,7,1,0,0,0,169,170,5,6,0,0,170,171,5,74,0,0,171,9,1,0,0,0,
		172,173,5,7,0,0,173,174,3,104,52,0,174,11,1,0,0,0,175,176,5,8,0,0,176,
		177,3,104,52,0,177,13,1,0,0,0,178,179,5,9,0,0,179,15,1,0,0,0,180,181,5,
		3,0,0,181,182,5,74,0,0,182,17,1,0,0,0,183,184,5,4,0,0,184,19,1,0,0,0,185,
		186,5,2,0,0,186,187,5,74,0,0,187,188,5,75,0,0,188,21,1,0,0,0,189,190,5,
		1,0,0,190,191,5,39,0,0,191,192,3,24,12,0,192,193,5,40,0,0,193,23,1,0,0,
		0,194,195,5,78,0,0,195,25,1,0,0,0,196,199,3,28,14,0,197,199,3,100,50,0,
		198,196,1,0,0,0,198,197,1,0,0,0,199,27,1,0,0,0,200,201,3,94,47,0,201,202,
		3,72,36,0,202,203,3,40,20,0,203,204,3,42,21,0,204,217,1,0,0,0,205,206,
		3,94,47,0,206,207,3,72,36,0,207,208,3,42,21,0,208,217,1,0,0,0,209,210,
		3,72,36,0,210,211,3,40,20,0,211,212,3,42,21,0,212,217,1,0,0,0,213,214,
		3,72,36,0,214,215,3,42,21,0,215,217,1,0,0,0,216,200,1,0,0,0,216,205,1,
		0,0,0,216,209,1,0,0,0,216,213,1,0,0,0,217,29,1,0,0,0,218,219,5,36,0,0,
		219,229,5,41,0,0,220,221,5,37,0,0,221,229,5,41,0,0,222,223,5,28,0,0,223,
		229,5,41,0,0,224,225,5,28,0,0,225,226,3,104,52,0,226,227,5,41,0,0,227,
		229,1,0,0,0,228,218,1,0,0,0,228,220,1,0,0,0,228,222,1,0,0,0,228,224,1,
		0,0,0,229,31,1,0,0,0,230,231,5,33,0,0,231,232,5,50,0,0,232,233,3,104,52,
		0,233,234,5,51,0,0,234,235,3,50,25,0,235,266,1,0,0,0,236,237,5,38,0,0,
		237,238,3,50,25,0,238,239,5,33,0,0,239,240,5,50,0,0,240,241,3,104,52,0,
		241,242,5,51,0,0,242,243,5,41,0,0,243,266,1,0,0,0,244,245,5,32,0,0,245,
		248,5,50,0,0,246,249,3,36,18,0,247,249,3,100,50,0,248,246,1,0,0,0,248,
		247,1,0,0,0,249,250,1,0,0,0,250,251,3,36,18,0,251,252,5,51,0,0,252,253,
		3,50,25,0,253,266,1,0,0,0,254,255,5,32,0,0,255,258,5,50,0,0,256,259,3,
		36,18,0,257,259,3,100,50,0,258,256,1,0,0,0,258,257,1,0,0,0,259,260,1,0,
		0,0,260,261,3,36,18,0,261,262,3,104,52,0,262,263,5,51,0,0,263,264,3,50,
		25,0,264,266,1,0,0,0,265,230,1,0,0,0,265,236,1,0,0,0,265,244,1,0,0,0,265,
		254,1,0,0,0,266,33,1,0,0,0,267,268,5,29,0,0,268,269,5,50,0,0,269,270,3,
		104,52,0,270,271,5,51,0,0,271,272,3,50,25,0,272,288,1,0,0,0,273,274,5,
		29,0,0,274,275,5,50,0,0,275,276,3,104,52,0,276,277,5,51,0,0,277,278,3,
		50,25,0,278,279,5,30,0,0,279,280,3,50,25,0,280,288,1,0,0,0,281,282,5,31,
		0,0,282,283,5,50,0,0,283,284,3,104,52,0,284,285,5,51,0,0,285,286,3,50,
		25,0,286,288,1,0,0,0,287,267,1,0,0,0,287,273,1,0,0,0,287,281,1,0,0,0,288,
		35,1,0,0,0,289,294,5,41,0,0,290,291,3,104,52,0,291,292,5,41,0,0,292,294,
		1,0,0,0,293,289,1,0,0,0,293,290,1,0,0,0,294,37,1,0,0,0,295,296,6,19,-1,
		0,296,297,3,50,25,0,297,302,1,0,0,0,298,299,10,1,0,0,299,301,3,50,25,0,
		300,298,1,0,0,0,301,304,1,0,0,0,302,300,1,0,0,0,302,303,1,0,0,0,303,39,
		1,0,0,0,304,302,1,0,0,0,305,306,6,20,-1,0,306,307,3,100,50,0,307,312,1,
		0,0,0,308,309,10,1,0,0,309,311,3,100,50,0,310,308,1,0,0,0,311,314,1,0,
		0,0,312,310,1,0,0,0,312,313,1,0,0,0,313,41,1,0,0,0,314,312,1,0,0,0,315,
		317,5,52,0,0,316,318,3,44,22,0,317,316,1,0,0,0,317,318,1,0,0,0,318,319,
		1,0,0,0,319,320,5,53,0,0,320,43,1,0,0,0,321,322,6,22,-1,0,322,323,3,46,
		23,0,323,328,1,0,0,0,324,325,10,1,0,0,325,327,3,46,23,0,326,324,1,0,0,
		0,327,330,1,0,0,0,328,326,1,0,0,0,328,329,1,0,0,0,329,45,1,0,0,0,330,328,
		1,0,0,0,331,334,3,38,19,0,332,334,3,40,20,0,333,331,1,0,0,0,333,332,1,
		0,0,0,334,47,1,0,0,0,335,336,5,74,0,0,336,337,5,45,0,0,337,347,3,50,25,
		0,338,339,5,34,0,0,339,340,3,102,51,0,340,341,5,45,0,0,341,342,3,50,25,
		0,342,347,1,0,0,0,343,344,5,35,0,0,344,345,5,45,0,0,345,347,3,50,25,0,
		346,335,1,0,0,0,346,338,1,0,0,0,346,343,1,0,0,0,347,49,1,0,0,0,348,355,
		3,48,24,0,349,355,3,42,21,0,350,355,3,36,18,0,351,355,3,34,17,0,352,355,
		3,32,16,0,353,355,3,30,15,0,354,348,1,0,0,0,354,349,1,0,0,0,354,350,1,
		0,0,0,354,351,1,0,0,0,354,352,1,0,0,0,354,353,1,0,0,0,355,51,1,0,0,0,356,
		357,6,26,-1,0,357,358,3,54,27,0,358,364,1,0,0,0,359,360,10,1,0,0,360,361,
		5,42,0,0,361,363,3,54,27,0,362,359,1,0,0,0,363,366,1,0,0,0,364,362,1,0,
		0,0,364,365,1,0,0,0,365,53,1,0,0,0,366,364,1,0,0,0,367,378,3,108,54,0,
		368,369,5,52,0,0,369,370,3,52,26,0,370,371,5,53,0,0,371,378,1,0,0,0,372,
		373,5,52,0,0,373,374,3,52,26,0,374,375,5,42,0,0,375,376,5,53,0,0,376,378,
		1,0,0,0,377,367,1,0,0,0,377,368,1,0,0,0,377,372,1,0,0,0,378,55,1,0,0,0,
		379,380,6,28,-1,0,380,381,5,50,0,0,381,382,3,58,29,0,382,383,5,51,0,0,
		383,397,1,0,0,0,384,385,5,54,0,0,385,397,5,55,0,0,386,387,5,54,0,0,387,
		388,3,102,51,0,388,389,5,55,0,0,389,397,1,0,0,0,390,391,5,50,0,0,391,397,
		5,51,0,0,392,393,5,50,0,0,393,394,3,64,32,0,394,395,5,51,0,0,395,397,1,
		0,0,0,396,379,1,0,0,0,396,384,1,0,0,0,396,386,1,0,0,0,396,390,1,0,0,0,
		396,392,1,0,0,0,397,416,1,0,0,0,398,399,10,6,0,0,399,400,5,54,0,0,400,
		415,5,55,0,0,401,402,10,5,0,0,402,403,5,54,0,0,403,404,3,102,51,0,404,
		405,5,55,0,0,405,415,1,0,0,0,406,407,10,2,0,0,407,408,5,50,0,0,408,415,
		5,51,0,0,409,410,10,1,0,0,410,411,5,50,0,0,411,412,3,64,32,0,412,413,5,
		51,0,0,413,415,1,0,0,0,414,398,1,0,0,0,414,401,1,0,0,0,414,406,1,0,0,0,
		414,409,1,0,0,0,415,418,1,0,0,0,416,414,1,0,0,0,416,417,1,0,0,0,417,57,
		1,0,0,0,418,416,1,0,0,0,419,425,3,68,34,0,420,425,3,56,28,0,421,422,3,
		68,34,0,422,423,3,56,28,0,423,425,1,0,0,0,424,419,1,0,0,0,424,420,1,0,
		0,0,424,421,1,0,0,0,425,59,1,0,0,0,426,427,6,30,-1,0,427,428,5,74,0,0,
		428,434,1,0,0,0,429,430,10,1,0,0,430,431,5,42,0,0,431,433,5,74,0,0,432,
		429,1,0,0,0,433,436,1,0,0,0,434,432,1,0,0,0,434,435,1,0,0,0,435,61,1,0,
		0,0,436,434,1,0,0,0,437,438,3,94,47,0,438,439,3,72,36,0,439,445,1,0,0,
		0,440,441,3,94,47,0,441,442,3,58,29,0,442,445,1,0,0,0,443,445,3,94,47,
		0,444,437,1,0,0,0,444,440,1,0,0,0,444,443,1,0,0,0,445,63,1,0,0,0,446,447,
		6,32,-1,0,447,448,3,62,31,0,448,454,1,0,0,0,449,450,10,1,0,0,450,451,5,
		42,0,0,451,453,3,62,31,0,452,449,1,0,0,0,453,456,1,0,0,0,454,452,1,0,0,
		0,454,455,1,0,0,0,455,65,1,0,0,0,456,454,1,0,0,0,457,458,6,33,-1,0,458,
		459,5,10,0,0,459,464,1,0,0,0,460,461,10,1,0,0,461,463,5,10,0,0,462,460,
		1,0,0,0,463,466,1,0,0,0,464,462,1,0,0,0,464,465,1,0,0,0,465,67,1,0,0,0,
		466,464,1,0,0,0,467,477,5,46,0,0,468,469,5,46,0,0,469,477,3,66,33,0,470,
		471,5,46,0,0,471,477,3,68,34,0,472,473,5,46,0,0,473,474,3,66,33,0,474,
		475,3,68,34,0,475,477,1,0,0,0,476,467,1,0,0,0,476,468,1,0,0,0,476,470,
		1,0,0,0,476,472,1,0,0,0,477,69,1,0,0,0,478,479,6,35,-1,0,479,485,5,74,
		0,0,480,481,5,50,0,0,481,482,3,72,36,0,482,483,5,51,0,0,483,485,1,0,0,
		0,484,478,1,0,0,0,484,480,1,0,0,0,485,509,1,0,0,0,486,487,10,5,0,0,487,
		488,5,54,0,0,488,489,3,102,51,0,489,490,5,55,0,0,490,508,1,0,0,0,491,492,
		10,4,0,0,492,493,5,54,0,0,493,508,5,55,0,0,494,495,10,3,0,0,495,496,5,
		50,0,0,496,497,3,64,32,0,497,498,5,51,0,0,498,508,1,0,0,0,499,500,10,2,
		0,0,500,501,5,50,0,0,501,502,3,60,30,0,502,503,5,51,0,0,503,508,1,0,0,
		0,504,505,10,1,0,0,505,506,5,50,0,0,506,508,5,51,0,0,507,486,1,0,0,0,507,
		491,1,0,0,0,507,494,1,0,0,0,507,499,1,0,0,0,507,504,1,0,0,0,508,511,1,
		0,0,0,509,507,1,0,0,0,509,510,1,0,0,0,510,71,1,0,0,0,511,509,1,0,0,0,512,
		513,3,68,34,0,513,514,3,70,35,0,514,517,1,0,0,0,515,517,3,70,35,0,516,
		512,1,0,0,0,516,515,1,0,0,0,517,73,1,0,0,0,518,519,3,88,44,0,519,520,3,
		74,37,0,520,526,1,0,0,0,521,526,3,88,44,0,522,523,5,10,0,0,523,526,3,74,
		37,0,524,526,5,10,0,0,525,518,1,0,0,0,525,521,1,0,0,0,525,522,1,0,0,0,
		525,524,1,0,0,0,526,75,1,0,0,0,527,528,5,11,0,0,528,529,5,74,0,0,529,530,
		5,52,0,0,530,531,3,78,39,0,531,532,5,53,0,0,532,541,1,0,0,0,533,534,5,
		11,0,0,534,535,5,52,0,0,535,536,3,78,39,0,536,537,5,53,0,0,537,541,1,0,
		0,0,538,539,5,11,0,0,539,541,5,74,0,0,540,527,1,0,0,0,540,533,1,0,0,0,
		540,538,1,0,0,0,541,77,1,0,0,0,542,543,6,39,-1,0,543,544,3,80,40,0,544,
		549,1,0,0,0,545,546,10,1,0,0,546,548,3,80,40,0,547,545,1,0,0,0,548,551,
		1,0,0,0,549,547,1,0,0,0,549,550,1,0,0,0,550,79,1,0,0,0,551,549,1,0,0,0,
		552,553,3,74,37,0,553,554,3,82,41,0,554,555,5,41,0,0,555,81,1,0,0,0,556,
		557,6,41,-1,0,557,558,3,84,42,0,558,564,1,0,0,0,559,560,10,1,0,0,560,561,
		5,42,0,0,561,563,3,84,42,0,562,559,1,0,0,0,563,566,1,0,0,0,564,562,1,0,
		0,0,564,565,1,0,0,0,565,83,1,0,0,0,566,564,1,0,0,0,567,575,3,72,36,0,568,
		569,5,45,0,0,569,575,3,102,51,0,570,571,3,72,36,0,571,572,5,45,0,0,572,
		573,3,102,51,0,573,575,1,0,0,0,574,567,1,0,0,0,574,568,1,0,0,0,574,570,
		1,0,0,0,575,85,1,0,0,0,576,577,7,0,0,0,577,87,1,0,0,0,578,591,5,18,0,0,
		579,591,5,19,0,0,580,591,5,20,0,0,581,591,5,21,0,0,582,591,5,22,0,0,583,
		591,5,23,0,0,584,591,5,24,0,0,585,591,5,25,0,0,586,591,5,26,0,0,587,591,
		5,27,0,0,588,591,3,76,38,0,589,591,3,90,45,0,590,578,1,0,0,0,590,579,1,
		0,0,0,590,580,1,0,0,0,590,581,1,0,0,0,590,582,1,0,0,0,590,583,1,0,0,0,
		590,584,1,0,0,0,590,585,1,0,0,0,590,586,1,0,0,0,590,587,1,0,0,0,590,588,
		1,0,0,0,590,589,1,0,0,0,591,89,1,0,0,0,592,593,5,74,0,0,593,91,1,0,0,0,
		594,599,3,74,37,0,595,596,3,74,37,0,596,597,3,58,29,0,597,599,1,0,0,0,
		598,594,1,0,0,0,598,595,1,0,0,0,599,93,1,0,0,0,600,612,3,86,43,0,601,602,
		3,86,43,0,602,603,3,94,47,0,603,612,1,0,0,0,604,612,3,88,44,0,605,606,
		3,88,44,0,606,607,3,94,47,0,607,612,1,0,0,0,608,612,5,10,0,0,609,610,5,
		10,0,0,610,612,3,94,47,0,611,600,1,0,0,0,611,601,1,0,0,0,611,604,1,0,0,
		0,611,605,1,0,0,0,611,608,1,0,0,0,611,609,1,0,0,0,612,95,1,0,0,0,613,614,
		6,48,-1,0,614,615,3,98,49,0,615,621,1,0,0,0,616,617,10,1,0,0,617,618,5,
		42,0,0,618,620,3,98,49,0,619,616,1,0,0,0,620,623,1,0,0,0,621,619,1,0,0,
		0,621,622,1,0,0,0,622,97,1,0,0,0,623,621,1,0,0,0,624,630,3,72,36,0,625,
		626,3,72,36,0,626,627,5,43,0,0,627,628,3,54,27,0,628,630,1,0,0,0,629,624,
		1,0,0,0,629,625,1,0,0,0,630,99,1,0,0,0,631,632,3,94,47,0,632,633,5,41,
		0,0,633,639,1,0,0,0,634,635,3,94,47,0,635,636,3,96,48,0,636,637,5,41,0,
		0,637,639,1,0,0,0,638,631,1,0,0,0,638,634,1,0,0,0,639,101,1,0,0,0,640,
		641,3,110,55,0,641,103,1,0,0,0,642,643,6,52,-1,0,643,644,3,108,54,0,644,
		650,1,0,0,0,645,646,10,1,0,0,646,647,5,42,0,0,647,649,3,108,54,0,648,645,
		1,0,0,0,649,652,1,0,0,0,650,648,1,0,0,0,650,651,1,0,0,0,651,105,1,0,0,
		0,652,650,1,0,0,0,653,654,7,1,0,0,654,107,1,0,0,0,655,661,3,110,55,0,656,
		657,3,128,64,0,657,658,3,106,53,0,658,659,3,108,54,0,659,661,1,0,0,0,660,
		655,1,0,0,0,660,656,1,0,0,0,661,109,1,0,0,0,662,670,3,112,56,0,663,664,
		3,112,56,0,664,665,5,44,0,0,665,666,3,104,52,0,666,667,5,45,0,0,667,668,
		3,110,55,0,668,670,1,0,0,0,669,662,1,0,0,0,669,663,1,0,0,0,670,111,1,0,
		0,0,671,672,6,56,-1,0,672,673,3,114,57,0,673,679,1,0,0,0,674,675,10,1,
		0,0,675,676,5,63,0,0,676,678,3,114,57,0,677,674,1,0,0,0,678,681,1,0,0,
		0,679,677,1,0,0,0,679,680,1,0,0,0,680,113,1,0,0,0,681,679,1,0,0,0,682,
		683,6,57,-1,0,683,684,3,116,58,0,684,690,1,0,0,0,685,686,10,1,0,0,686,
		687,5,64,0,0,687,689,3,116,58,0,688,685,1,0,0,0,689,692,1,0,0,0,690,688,
		1,0,0,0,690,691,1,0,0,0,691,115,1,0,0,0,692,690,1,0,0,0,693,694,6,58,-1,
		0,694,695,3,118,59,0,695,704,1,0,0,0,696,697,10,2,0,0,697,698,5,66,0,0,
		698,703,3,118,59,0,699,700,10,1,0,0,700,701,5,65,0,0,701,703,3,118,59,
		0,702,696,1,0,0,0,702,699,1,0,0,0,703,706,1,0,0,0,704,702,1,0,0,0,704,
		705,1,0,0,0,705,117,1,0,0,0,706,704,1,0,0,0,707,708,6,59,-1,0,708,709,
		3,120,60,0,709,724,1,0,0,0,710,711,10,4,0,0,711,712,5,39,0,0,712,723,3,
		120,60,0,713,714,10,3,0,0,714,715,5,40,0,0,715,723,3,120,60,0,716,717,
		10,2,0,0,717,718,5,68,0,0,718,723,3,120,60,0,719,720,10,1,0,0,720,721,
		5,67,0,0,721,723,3,120,60,0,722,710,1,0,0,0,722,713,1,0,0,0,722,716,1,
		0,0,0,722,719,1,0,0,0,723,726,1,0,0,0,724,722,1,0,0,0,724,725,1,0,0,0,
		725,119,1,0,0,0,726,724,1,0,0,0,727,728,6,60,-1,0,728,729,3,122,61,0,729,
		738,1,0,0,0,730,731,10,2,0,0,731,732,5,48,0,0,732,737,3,122,61,0,733,734,
		10,1,0,0,734,735,5,49,0,0,735,737,3,122,61,0,736,730,1,0,0,0,736,733,1,
		0,0,0,737,740,1,0,0,0,738,736,1,0,0,0,738,739,1,0,0,0,739,121,1,0,0,0,
		740,738,1,0,0,0,741,742,6,61,-1,0,742,743,3,124,62,0,743,755,1,0,0,0,744,
		745,10,3,0,0,745,746,5,46,0,0,746,754,3,124,62,0,747,748,10,2,0,0,748,
		749,5,47,0,0,749,754,3,124,62,0,750,751,10,1,0,0,751,752,5,57,0,0,752,
		754,3,124,62,0,753,744,1,0,0,0,753,747,1,0,0,0,753,750,1,0,0,0,754,757,
		1,0,0,0,755,753,1,0,0,0,755,756,1,0,0,0,756,123,1,0,0,0,757,755,1,0,0,
		0,758,765,3,128,64,0,759,760,5,50,0,0,760,761,3,92,46,0,761,762,5,51,0,
		0,762,763,3,124,62,0,763,765,1,0,0,0,764,758,1,0,0,0,764,759,1,0,0,0,765,
		125,1,0,0,0,766,767,7,2,0,0,767,127,1,0,0,0,768,784,3,132,66,0,769,770,
		5,62,0,0,770,784,3,128,64,0,771,772,5,61,0,0,772,784,3,128,64,0,773,774,
		3,126,63,0,774,775,3,124,62,0,775,784,1,0,0,0,776,777,5,17,0,0,777,784,
		3,128,64,0,778,779,5,17,0,0,779,780,5,50,0,0,780,781,3,92,46,0,781,782,
		5,51,0,0,782,784,1,0,0,0,783,768,1,0,0,0,783,769,1,0,0,0,783,771,1,0,0,
		0,783,773,1,0,0,0,783,776,1,0,0,0,783,778,1,0,0,0,784,129,1,0,0,0,785,
		786,6,65,-1,0,786,787,3,108,54,0,787,793,1,0,0,0,788,789,10,1,0,0,789,
		790,5,42,0,0,790,792,3,108,54,0,791,788,1,0,0,0,792,795,1,0,0,0,793,791,
		1,0,0,0,793,794,1,0,0,0,794,131,1,0,0,0,795,793,1,0,0,0,796,797,6,66,-1,
		0,797,798,3,134,67,0,798,824,1,0,0,0,799,800,10,7,0,0,800,801,5,54,0,0,
		801,802,3,104,52,0,802,803,5,55,0,0,803,823,1,0,0,0,804,805,10,6,0,0,805,
		806,5,50,0,0,806,823,5,51,0,0,807,808,10,5,0,0,808,809,5,50,0,0,809,810,
		3,130,65,0,810,811,5,51,0,0,811,823,1,0,0,0,812,813,10,4,0,0,813,814,5,
		59,0,0,814,823,5,74,0,0,815,816,10,3,0,0,816,817,5,58,0,0,817,823,5,74,
		0,0,818,819,10,2,0,0,819,823,5,62,0,0,820,821,10,1,0,0,821,823,5,61,0,
		0,822,799,1,0,0,0,822,804,1,0,0,0,822,807,1,0,0,0,822,812,1,0,0,0,822,
		815,1,0,0,0,822,818,1,0,0,0,822,820,1,0,0,0,823,826,1,0,0,0,824,822,1,
		0,0,0,824,825,1,0,0,0,825,133,1,0,0,0,826,824,1,0,0,0,827,835,5,74,0,0,
		828,835,5,75,0,0,829,835,5,77,0,0,830,831,5,50,0,0,831,832,3,104,52,0,
		832,833,5,51,0,0,833,835,1,0,0,0,834,827,1,0,0,0,834,828,1,0,0,0,834,829,
		1,0,0,0,834,830,1,0,0,0,835,135,1,0,0,0,65,137,144,150,152,164,198,216,
		228,248,258,265,287,293,302,312,317,328,333,346,354,364,377,396,414,416,
		424,434,444,454,464,476,484,507,509,516,525,540,549,564,574,590,598,611,
		621,629,638,650,660,669,679,690,702,704,722,724,736,738,753,755,764,783,
		793,822,824,834
	};

	public static readonly ATN _ATN =
		new ATNDeserializer().Deserialize(_serializedATN);


}
} // namespace CGrammar
