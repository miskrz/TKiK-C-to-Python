//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ANTLR Version: 4.13.1
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// Generated from C:/Users/miskr/TKiK/TKiK_repozytorium/Grammars/C_Grammar.g4 by ANTLR 4.13.1

// Unreachable code detected
#pragma warning disable 0162
// The variable '...' is assigned but its value is never used
#pragma warning disable 0219
// Missing XML comment for publicly visible type or member '...'
#pragma warning disable 1591
// Ambiguous reference in cref attribute
#pragma warning disable 419

namespace CGrammar {
using System;
using System.IO;
using System.Text;
using System.Diagnostics;
using System.Collections.Generic;
using Antlr4.Runtime;
using Antlr4.Runtime.Atn;
using Antlr4.Runtime.Misc;
using Antlr4.Runtime.Tree;
using DFA = Antlr4.Runtime.Dfa.DFA;

[System.CodeDom.Compiler.GeneratedCode("ANTLR", "4.13.1")]
[System.CLSCompliant(false)]
public partial class C_GrammarParser : Parser {
	protected static DFA[] decisionToDFA;
	protected static PredictionContextCache sharedContextCache = new PredictionContextCache();
	public const int
		Hash_Include=1, Hash_Define=2, Hash_ifndef=3, Hash_endif=4, Hash_undef=5, 
		Hash_ifdef=6, Hash_if=7, Hash_elif=8, Hash_else=9, Const=10, Struct=11, 
		Typedef=12, Auto=13, Extern=14, Static=15, Register=16, Sizeof=17, Void=18, 
		Char=19, Short=20, Int=21, Long=22, Float=23, Double=24, Signed=25, Unsigned=26, 
		Bool=27, Return=28, If=29, Else=30, Switch=31, For=32, While=33, Case=34, 
		Default=35, Continue=36, Break=37, Do=38, Less=39, Greater=40, Semicolon=41, 
		Comma=42, Assign=43, QuestionMark=44, Colon=45, Multiply=46, Divide=47, 
		Plus=48, Minus=49, LeftParen=50, RightParen=51, LeftBrace=52, RightBrace=53, 
		LeftBracket=54, RightBracket=55, Ampersand=56, Mod=57, Arrow=58, Dot=59, 
		Exclamation=60, DecOp=61, IncOp=62, OrOp=63, AndOp=64, NeOp=65, EqOp=66, 
		GeOp=67, LeOp=68, AddAssign=69, SubAssign=70, MulAssign=71, DivAssign=72, 
		ModAssign=73, Identifier=74, Constant=75, DigitSequence=76, StringLiteral=77, 
		LibraryName=78, Whitespace=79, Newline=80, BlockComment=81, LineComment=82;
	public const int
		RULE_start = 0, RULE_translationUnit = 1, RULE_hashStatement = 2, RULE_conditionalStatement = 3, 
		RULE_ifStatement = 4, RULE_ifElseStatement = 5, RULE_elseIfBlock = 6, 
		RULE_elifStatement = 7, RULE_elseStatement = 8, RULE_defineStatement = 9, 
		RULE_undefStatement = 10, RULE_ifdefStatement = 11, RULE_ifndefStatement = 12, 
		RULE_includeStatement = 13, RULE_libraryName = 14, RULE_externalDeclaration = 15, 
		RULE_functionDefinition = 16, RULE_jumpStatement = 17, RULE_iterationStatement = 18, 
		RULE_selectionStatement = 19, RULE_expressionStatement = 20, RULE_statementList = 21, 
		RULE_declarationList = 22, RULE_compoundStatement = 23, RULE_blockItemList = 24, 
		RULE_blockItem = 25, RULE_labeledStatement = 26, RULE_statement = 27, 
		RULE_initializerList = 28, RULE_initializer = 29, RULE_directAbstractDeclarator = 30, 
		RULE_abstractDeclarator = 31, RULE_identifierList = 32, RULE_parameterDeclaration = 33, 
		RULE_parameterList = 34, RULE_typeQualifierList = 35, RULE_pointer = 36, 
		RULE_directDeclarator = 37, RULE_declarator = 38, RULE_specifierQualifierList = 39, 
		RULE_structSpecifier = 40, RULE_structDeclarationList = 41, RULE_structDeclaration = 42, 
		RULE_structDeclaratorList = 43, RULE_structDeclarator = 44, RULE_storageClassSpecifier = 45, 
		RULE_typeSpecifier = 46, RULE_typeNameIdentifier = 47, RULE_typeName = 48, 
		RULE_declarationSpecifiers = 49, RULE_initDeclaratorList = 50, RULE_initDeclarator = 51, 
		RULE_declaration = 52, RULE_constantExpression = 53, RULE_expression = 54, 
		RULE_assignmentOperator = 55, RULE_assignmentExpression = 56, RULE_conditionalExpression = 57, 
		RULE_logicalOrExpression = 58, RULE_logicalAndExpression = 59, RULE_equalityExpression = 60, 
		RULE_relationalExpression = 61, RULE_additiveExpression = 62, RULE_multiplicativeExpression = 63, 
		RULE_castExpression = 64, RULE_unaryOperator = 65, RULE_unaryExpression = 66, 
		RULE_argumentExpressionList = 67, RULE_postfixExpression = 68, RULE_primaryExpression = 69;
	public static readonly string[] ruleNames = {
		"start", "translationUnit", "hashStatement", "conditionalStatement", "ifStatement", 
		"ifElseStatement", "elseIfBlock", "elifStatement", "elseStatement", "defineStatement", 
		"undefStatement", "ifdefStatement", "ifndefStatement", "includeStatement", 
		"libraryName", "externalDeclaration", "functionDefinition", "jumpStatement", 
		"iterationStatement", "selectionStatement", "expressionStatement", "statementList", 
		"declarationList", "compoundStatement", "blockItemList", "blockItem", 
		"labeledStatement", "statement", "initializerList", "initializer", "directAbstractDeclarator", 
		"abstractDeclarator", "identifierList", "parameterDeclaration", "parameterList", 
		"typeQualifierList", "pointer", "directDeclarator", "declarator", "specifierQualifierList", 
		"structSpecifier", "structDeclarationList", "structDeclaration", "structDeclaratorList", 
		"structDeclarator", "storageClassSpecifier", "typeSpecifier", "typeNameIdentifier", 
		"typeName", "declarationSpecifiers", "initDeclaratorList", "initDeclarator", 
		"declaration", "constantExpression", "expression", "assignmentOperator", 
		"assignmentExpression", "conditionalExpression", "logicalOrExpression", 
		"logicalAndExpression", "equalityExpression", "relationalExpression", 
		"additiveExpression", "multiplicativeExpression", "castExpression", "unaryOperator", 
		"unaryExpression", "argumentExpressionList", "postfixExpression", "primaryExpression"
	};

	private static readonly string[] _LiteralNames = {
		null, "'#include'", null, "'#ifndef'", "'#endif'", "'#undef'", "'#ifdef'", 
		"'#if'", "'#elif'", "'#else'", "'const'", "'struct'", "'typedef'", "'auto'", 
		"'extern'", "'static'", "'register'", "'sizeof'", "'void'", "'char'", 
		"'short'", "'int'", "'long'", "'float'", "'double'", "'signed'", "'unsigned'", 
		"'bool'", "'return'", "'if'", "'else'", "'switch'", "'for'", "'while'", 
		"'case'", "'default'", "'continue'", "'break'", "'do'", "'<'", "'>'", 
		"';'", "','", "'='", "'?'", "':'", "'*'", "'/'", "'+'", "'-'", "'('", 
		"')'", "'{'", "'}'", "'['", "']'", "'&'", "'%'", "'->'", "'.'", "'!'", 
		"'--'", "'++'", "'||'", "'&&'", "'!='", "'=='", "'>='", "'<='", "'+='", 
		"'-='", "'*='", "'/='", "'%='"
	};
	private static readonly string[] _SymbolicNames = {
		null, "Hash_Include", "Hash_Define", "Hash_ifndef", "Hash_endif", "Hash_undef", 
		"Hash_ifdef", "Hash_if", "Hash_elif", "Hash_else", "Const", "Struct", 
		"Typedef", "Auto", "Extern", "Static", "Register", "Sizeof", "Void", "Char", 
		"Short", "Int", "Long", "Float", "Double", "Signed", "Unsigned", "Bool", 
		"Return", "If", "Else", "Switch", "For", "While", "Case", "Default", "Continue", 
		"Break", "Do", "Less", "Greater", "Semicolon", "Comma", "Assign", "QuestionMark", 
		"Colon", "Multiply", "Divide", "Plus", "Minus", "LeftParen", "RightParen", 
		"LeftBrace", "RightBrace", "LeftBracket", "RightBracket", "Ampersand", 
		"Mod", "Arrow", "Dot", "Exclamation", "DecOp", "IncOp", "OrOp", "AndOp", 
		"NeOp", "EqOp", "GeOp", "LeOp", "AddAssign", "SubAssign", "MulAssign", 
		"DivAssign", "ModAssign", "Identifier", "Constant", "DigitSequence", "StringLiteral", 
		"LibraryName", "Whitespace", "Newline", "BlockComment", "LineComment"
	};
	public static readonly IVocabulary DefaultVocabulary = new Vocabulary(_LiteralNames, _SymbolicNames);

	[NotNull]
	public override IVocabulary Vocabulary
	{
		get
		{
			return DefaultVocabulary;
		}
	}

	public override string GrammarFileName { get { return "C_Grammar.g4"; } }

	public override string[] RuleNames { get { return ruleNames; } }

	public override int[] SerializedAtn { get { return _serializedATN; } }

	static C_GrammarParser() {
		decisionToDFA = new DFA[_ATN.NumberOfDecisions];
		for (int i = 0; i < _ATN.NumberOfDecisions; i++) {
			decisionToDFA[i] = new DFA(_ATN.GetDecisionState(i), i);
		}
	}

		public C_GrammarParser(ITokenStream input) : this(input, Console.Out, Console.Error) { }

		public C_GrammarParser(ITokenStream input, TextWriter output, TextWriter errorOutput)
		: base(input, output, errorOutput)
	{
		Interpreter = new ParserATNSimulator(this, _ATN, decisionToDFA, sharedContextCache);
	}

	public partial class StartContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Eof() { return GetToken(C_GrammarParser.Eof, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public TranslationUnitContext translationUnit() {
			return GetRuleContext<TranslationUnitContext>(0);
		}
		public StartContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_start; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.EnterStart(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.ExitStart(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IC_GrammarVisitor<TResult> typedVisitor = visitor as IC_GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitStart(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public StartContext start() {
		StartContext _localctx = new StartContext(Context, State);
		EnterRule(_localctx, 0, RULE_start);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 141;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if ((((_la) & ~0x3f) == 0 && ((1L << _la) & 1196268919323886L) != 0) || _la==Identifier) {
				{
				State = 140;
				translationUnit(0);
				}
			}

			State = 143;
			Match(Eof);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TranslationUnitContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public HashStatementContext hashStatement() {
			return GetRuleContext<HashStatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ExternalDeclarationContext externalDeclaration() {
			return GetRuleContext<ExternalDeclarationContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public TranslationUnitContext translationUnit() {
			return GetRuleContext<TranslationUnitContext>(0);
		}
		public TranslationUnitContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_translationUnit; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.EnterTranslationUnit(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.ExitTranslationUnit(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IC_GrammarVisitor<TResult> typedVisitor = visitor as IC_GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTranslationUnit(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public TranslationUnitContext translationUnit() {
		return translationUnit(0);
	}

	private TranslationUnitContext translationUnit(int _p) {
		ParserRuleContext _parentctx = Context;
		int _parentState = State;
		TranslationUnitContext _localctx = new TranslationUnitContext(Context, _parentState);
		TranslationUnitContext _prevctx = _localctx;
		int _startState = 2;
		EnterRecursionRule(_localctx, 2, RULE_translationUnit, _p);
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 148;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case Hash_Include:
			case Hash_Define:
			case Hash_ifndef:
			case Hash_undef:
			case Hash_ifdef:
			case Hash_if:
				{
				State = 146;
				hashStatement();
				}
				break;
			case Const:
			case Struct:
			case Typedef:
			case Auto:
			case Extern:
			case Static:
			case Register:
			case Void:
			case Char:
			case Short:
			case Int:
			case Long:
			case Float:
			case Double:
			case Signed:
			case Unsigned:
			case Bool:
			case Multiply:
			case LeftParen:
			case Identifier:
				{
				State = 147;
				externalDeclaration();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			Context.Stop = TokenStream.LT(-1);
			State = 156;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,3,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					if ( ParseListeners!=null )
						TriggerExitRuleEvent();
					_prevctx = _localctx;
					{
					State = 154;
					ErrorHandler.Sync(this);
					switch ( Interpreter.AdaptivePredict(TokenStream,2,Context) ) {
					case 1:
						{
						_localctx = new TranslationUnitContext(_parentctx, _parentState);
						PushNewRecursionContext(_localctx, _startState, RULE_translationUnit);
						State = 150;
						if (!(Precpred(Context, 2))) throw new FailedPredicateException(this, "Precpred(Context, 2)");
						State = 151;
						hashStatement();
						}
						break;
					case 2:
						{
						_localctx = new TranslationUnitContext(_parentctx, _parentState);
						PushNewRecursionContext(_localctx, _startState, RULE_translationUnit);
						State = 152;
						if (!(Precpred(Context, 1))) throw new FailedPredicateException(this, "Precpred(Context, 1)");
						State = 153;
						externalDeclaration();
						}
						break;
					}
					} 
				}
				State = 158;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,3,Context);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			UnrollRecursionContexts(_parentctx);
		}
		return _localctx;
	}

	public partial class HashStatementContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public IncludeStatementContext includeStatement() {
			return GetRuleContext<IncludeStatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public DefineStatementContext defineStatement() {
			return GetRuleContext<DefineStatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public UndefStatementContext undefStatement() {
			return GetRuleContext<UndefStatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ConditionalStatementContext conditionalStatement() {
			return GetRuleContext<ConditionalStatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public IfdefStatementContext ifdefStatement() {
			return GetRuleContext<IfdefStatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public IfndefStatementContext ifndefStatement() {
			return GetRuleContext<IfndefStatementContext>(0);
		}
		public HashStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_hashStatement; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.EnterHashStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.ExitHashStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IC_GrammarVisitor<TResult> typedVisitor = visitor as IC_GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitHashStatement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public HashStatementContext hashStatement() {
		HashStatementContext _localctx = new HashStatementContext(Context, State);
		EnterRule(_localctx, 4, RULE_hashStatement);
		try {
			State = 165;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case Hash_Include:
				EnterOuterAlt(_localctx, 1);
				{
				State = 159;
				includeStatement();
				}
				break;
			case Hash_Define:
				EnterOuterAlt(_localctx, 2);
				{
				State = 160;
				defineStatement();
				}
				break;
			case Hash_undef:
				EnterOuterAlt(_localctx, 3);
				{
				State = 161;
				undefStatement();
				}
				break;
			case Hash_if:
				EnterOuterAlt(_localctx, 4);
				{
				State = 162;
				conditionalStatement();
				}
				break;
			case Hash_ifdef:
				EnterOuterAlt(_localctx, 5);
				{
				State = 163;
				ifdefStatement();
				}
				break;
			case Hash_ifndef:
				EnterOuterAlt(_localctx, 6);
				{
				State = 164;
				ifndefStatement();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ConditionalStatementContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public IfStatementContext ifStatement() {
			return GetRuleContext<IfStatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Hash_endif() { return GetToken(C_GrammarParser.Hash_endif, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public IfElseStatementContext ifElseStatement() {
			return GetRuleContext<IfElseStatementContext>(0);
		}
		public ConditionalStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_conditionalStatement; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.EnterConditionalStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.ExitConditionalStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IC_GrammarVisitor<TResult> typedVisitor = visitor as IC_GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitConditionalStatement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ConditionalStatementContext conditionalStatement() {
		ConditionalStatementContext _localctx = new ConditionalStatementContext(Context, State);
		EnterRule(_localctx, 6, RULE_conditionalStatement);
		try {
			State = 173;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,5,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 167;
				ifStatement();
				State = 168;
				Match(Hash_endif);
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 170;
				ifElseStatement();
				State = 171;
				Match(Hash_endif);
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class IfStatementContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Hash_if() { return GetToken(C_GrammarParser.Hash_if, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ExternalDeclarationContext externalDeclaration() {
			return GetRuleContext<ExternalDeclarationContext>(0);
		}
		public IfStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_ifStatement; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.EnterIfStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.ExitIfStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IC_GrammarVisitor<TResult> typedVisitor = visitor as IC_GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitIfStatement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public IfStatementContext ifStatement() {
		IfStatementContext _localctx = new IfStatementContext(Context, State);
		EnterRule(_localctx, 8, RULE_ifStatement);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 175;
			Match(Hash_if);
			State = 176;
			expression(0);
			State = 177;
			externalDeclaration();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class IfElseStatementContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public IfStatementContext ifStatement() {
			return GetRuleContext<IfStatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ElseIfBlockContext elseIfBlock() {
			return GetRuleContext<ElseIfBlockContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ElseStatementContext elseStatement() {
			return GetRuleContext<ElseStatementContext>(0);
		}
		public IfElseStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_ifElseStatement; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.EnterIfElseStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.ExitIfElseStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IC_GrammarVisitor<TResult> typedVisitor = visitor as IC_GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitIfElseStatement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public IfElseStatementContext ifElseStatement() {
		IfElseStatementContext _localctx = new IfElseStatementContext(Context, State);
		EnterRule(_localctx, 10, RULE_ifElseStatement);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 179;
			ifStatement();
			State = 181;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==Hash_elif) {
				{
				State = 180;
				elseIfBlock(0);
				}
			}

			State = 184;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==Hash_else) {
				{
				State = 183;
				elseStatement();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ElseIfBlockContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ElifStatementContext elifStatement() {
			return GetRuleContext<ElifStatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ElseIfBlockContext elseIfBlock() {
			return GetRuleContext<ElseIfBlockContext>(0);
		}
		public ElseIfBlockContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_elseIfBlock; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.EnterElseIfBlock(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.ExitElseIfBlock(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IC_GrammarVisitor<TResult> typedVisitor = visitor as IC_GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitElseIfBlock(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ElseIfBlockContext elseIfBlock() {
		return elseIfBlock(0);
	}

	private ElseIfBlockContext elseIfBlock(int _p) {
		ParserRuleContext _parentctx = Context;
		int _parentState = State;
		ElseIfBlockContext _localctx = new ElseIfBlockContext(Context, _parentState);
		ElseIfBlockContext _prevctx = _localctx;
		int _startState = 12;
		EnterRecursionRule(_localctx, 12, RULE_elseIfBlock, _p);
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			{
			State = 187;
			elifStatement();
			}
			Context.Stop = TokenStream.LT(-1);
			State = 193;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,8,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					if ( ParseListeners!=null )
						TriggerExitRuleEvent();
					_prevctx = _localctx;
					{
					{
					_localctx = new ElseIfBlockContext(_parentctx, _parentState);
					PushNewRecursionContext(_localctx, _startState, RULE_elseIfBlock);
					State = 189;
					if (!(Precpred(Context, 1))) throw new FailedPredicateException(this, "Precpred(Context, 1)");
					State = 190;
					elifStatement();
					}
					} 
				}
				State = 195;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,8,Context);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			UnrollRecursionContexts(_parentctx);
		}
		return _localctx;
	}

	public partial class ElifStatementContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Hash_elif() { return GetToken(C_GrammarParser.Hash_elif, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ExternalDeclarationContext externalDeclaration() {
			return GetRuleContext<ExternalDeclarationContext>(0);
		}
		public ElifStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_elifStatement; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.EnterElifStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.ExitElifStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IC_GrammarVisitor<TResult> typedVisitor = visitor as IC_GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitElifStatement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ElifStatementContext elifStatement() {
		ElifStatementContext _localctx = new ElifStatementContext(Context, State);
		EnterRule(_localctx, 14, RULE_elifStatement);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 196;
			Match(Hash_elif);
			State = 197;
			expression(0);
			State = 198;
			externalDeclaration();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ElseStatementContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Hash_else() { return GetToken(C_GrammarParser.Hash_else, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ExternalDeclarationContext externalDeclaration() {
			return GetRuleContext<ExternalDeclarationContext>(0);
		}
		public ElseStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_elseStatement; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.EnterElseStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.ExitElseStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IC_GrammarVisitor<TResult> typedVisitor = visitor as IC_GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitElseStatement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ElseStatementContext elseStatement() {
		ElseStatementContext _localctx = new ElseStatementContext(Context, State);
		EnterRule(_localctx, 16, RULE_elseStatement);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 200;
			Match(Hash_else);
			State = 201;
			externalDeclaration();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class DefineStatementContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Hash_Define() { return GetToken(C_GrammarParser.Hash_Define, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Identifier() { return GetToken(C_GrammarParser.Identifier, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Constant() { return GetToken(C_GrammarParser.Constant, 0); }
		public DefineStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_defineStatement; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.EnterDefineStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.ExitDefineStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IC_GrammarVisitor<TResult> typedVisitor = visitor as IC_GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitDefineStatement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public DefineStatementContext defineStatement() {
		DefineStatementContext _localctx = new DefineStatementContext(Context, State);
		EnterRule(_localctx, 18, RULE_defineStatement);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 203;
			Match(Hash_Define);
			State = 204;
			Match(Identifier);
			State = 205;
			Match(Constant);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class UndefStatementContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Hash_undef() { return GetToken(C_GrammarParser.Hash_undef, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Identifier() { return GetToken(C_GrammarParser.Identifier, 0); }
		public UndefStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_undefStatement; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.EnterUndefStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.ExitUndefStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IC_GrammarVisitor<TResult> typedVisitor = visitor as IC_GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitUndefStatement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public UndefStatementContext undefStatement() {
		UndefStatementContext _localctx = new UndefStatementContext(Context, State);
		EnterRule(_localctx, 20, RULE_undefStatement);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 207;
			Match(Hash_undef);
			State = 208;
			Match(Identifier);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class IfdefStatementContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Hash_ifdef() { return GetToken(C_GrammarParser.Hash_ifdef, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Identifier() { return GetToken(C_GrammarParser.Identifier, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ExternalDeclarationContext externalDeclaration() {
			return GetRuleContext<ExternalDeclarationContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Hash_endif() { return GetToken(C_GrammarParser.Hash_endif, 0); }
		public IfdefStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_ifdefStatement; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.EnterIfdefStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.ExitIfdefStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IC_GrammarVisitor<TResult> typedVisitor = visitor as IC_GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitIfdefStatement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public IfdefStatementContext ifdefStatement() {
		IfdefStatementContext _localctx = new IfdefStatementContext(Context, State);
		EnterRule(_localctx, 22, RULE_ifdefStatement);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 210;
			Match(Hash_ifdef);
			State = 211;
			Match(Identifier);
			State = 212;
			externalDeclaration();
			State = 213;
			Match(Hash_endif);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class IfndefStatementContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Hash_ifndef() { return GetToken(C_GrammarParser.Hash_ifndef, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Identifier() { return GetToken(C_GrammarParser.Identifier, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ExternalDeclarationContext externalDeclaration() {
			return GetRuleContext<ExternalDeclarationContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Hash_endif() { return GetToken(C_GrammarParser.Hash_endif, 0); }
		public IfndefStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_ifndefStatement; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.EnterIfndefStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.ExitIfndefStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IC_GrammarVisitor<TResult> typedVisitor = visitor as IC_GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitIfndefStatement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public IfndefStatementContext ifndefStatement() {
		IfndefStatementContext _localctx = new IfndefStatementContext(Context, State);
		EnterRule(_localctx, 24, RULE_ifndefStatement);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 215;
			Match(Hash_ifndef);
			State = 216;
			Match(Identifier);
			State = 217;
			externalDeclaration();
			State = 218;
			Match(Hash_endif);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class IncludeStatementContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Hash_Include() { return GetToken(C_GrammarParser.Hash_Include, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Less() { return GetToken(C_GrammarParser.Less, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public LibraryNameContext libraryName() {
			return GetRuleContext<LibraryNameContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Greater() { return GetToken(C_GrammarParser.Greater, 0); }
		public IncludeStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_includeStatement; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.EnterIncludeStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.ExitIncludeStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IC_GrammarVisitor<TResult> typedVisitor = visitor as IC_GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitIncludeStatement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public IncludeStatementContext includeStatement() {
		IncludeStatementContext _localctx = new IncludeStatementContext(Context, State);
		EnterRule(_localctx, 26, RULE_includeStatement);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 220;
			Match(Hash_Include);
			State = 221;
			Match(Less);
			State = 222;
			libraryName();
			State = 223;
			Match(Greater);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class LibraryNameContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LibraryName() { return GetToken(C_GrammarParser.LibraryName, 0); }
		public LibraryNameContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_libraryName; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.EnterLibraryName(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.ExitLibraryName(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IC_GrammarVisitor<TResult> typedVisitor = visitor as IC_GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitLibraryName(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public LibraryNameContext libraryName() {
		LibraryNameContext _localctx = new LibraryNameContext(Context, State);
		EnterRule(_localctx, 28, RULE_libraryName);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 225;
			Match(LibraryName);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ExternalDeclarationContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public FunctionDefinitionContext functionDefinition() {
			return GetRuleContext<FunctionDefinitionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public DeclarationContext declaration() {
			return GetRuleContext<DeclarationContext>(0);
		}
		public ExternalDeclarationContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_externalDeclaration; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.EnterExternalDeclaration(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.ExitExternalDeclaration(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IC_GrammarVisitor<TResult> typedVisitor = visitor as IC_GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitExternalDeclaration(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ExternalDeclarationContext externalDeclaration() {
		ExternalDeclarationContext _localctx = new ExternalDeclarationContext(Context, State);
		EnterRule(_localctx, 30, RULE_externalDeclaration);
		try {
			State = 229;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,9,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 227;
				functionDefinition();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 228;
				declaration();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class FunctionDefinitionContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public DeclarationSpecifiersContext declarationSpecifiers() {
			return GetRuleContext<DeclarationSpecifiersContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public DeclaratorContext declarator() {
			return GetRuleContext<DeclaratorContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public DeclarationListContext declarationList() {
			return GetRuleContext<DeclarationListContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public CompoundStatementContext compoundStatement() {
			return GetRuleContext<CompoundStatementContext>(0);
		}
		public FunctionDefinitionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_functionDefinition; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.EnterFunctionDefinition(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.ExitFunctionDefinition(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IC_GrammarVisitor<TResult> typedVisitor = visitor as IC_GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitFunctionDefinition(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public FunctionDefinitionContext functionDefinition() {
		FunctionDefinitionContext _localctx = new FunctionDefinitionContext(Context, State);
		EnterRule(_localctx, 32, RULE_functionDefinition);
		try {
			State = 247;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,10,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 231;
				declarationSpecifiers();
				State = 232;
				declarator();
				State = 233;
				declarationList(0);
				State = 234;
				compoundStatement();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 236;
				declarationSpecifiers();
				State = 237;
				declarator();
				State = 238;
				compoundStatement();
				}
				break;
			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 240;
				declarator();
				State = 241;
				declarationList(0);
				State = 242;
				compoundStatement();
				}
				break;
			case 4:
				EnterOuterAlt(_localctx, 4);
				{
				State = 244;
				declarator();
				State = 245;
				compoundStatement();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class JumpStatementContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Continue() { return GetToken(C_GrammarParser.Continue, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Semicolon() { return GetToken(C_GrammarParser.Semicolon, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Break() { return GetToken(C_GrammarParser.Break, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Return() { return GetToken(C_GrammarParser.Return, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public JumpStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_jumpStatement; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.EnterJumpStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.ExitJumpStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IC_GrammarVisitor<TResult> typedVisitor = visitor as IC_GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitJumpStatement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public JumpStatementContext jumpStatement() {
		JumpStatementContext _localctx = new JumpStatementContext(Context, State);
		EnterRule(_localctx, 34, RULE_jumpStatement);
		try {
			State = 259;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,11,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 249;
				Match(Continue);
				State = 250;
				Match(Semicolon);
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 251;
				Match(Break);
				State = 252;
				Match(Semicolon);
				}
				break;
			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 253;
				Match(Return);
				State = 254;
				Match(Semicolon);
				}
				break;
			case 4:
				EnterOuterAlt(_localctx, 4);
				{
				State = 255;
				Match(Return);
				State = 256;
				expression(0);
				State = 257;
				Match(Semicolon);
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class IterationStatementContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode While() { return GetToken(C_GrammarParser.While, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LeftParen() { return GetToken(C_GrammarParser.LeftParen, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RightParen() { return GetToken(C_GrammarParser.RightParen, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public StatementContext statement() {
			return GetRuleContext<StatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Do() { return GetToken(C_GrammarParser.Do, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Semicolon() { return GetToken(C_GrammarParser.Semicolon, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode For() { return GetToken(C_GrammarParser.For, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionStatementContext[] expressionStatement() {
			return GetRuleContexts<ExpressionStatementContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionStatementContext expressionStatement(int i) {
			return GetRuleContext<ExpressionStatementContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public DeclarationContext declaration() {
			return GetRuleContext<DeclarationContext>(0);
		}
		public IterationStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_iterationStatement; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.EnterIterationStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.ExitIterationStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IC_GrammarVisitor<TResult> typedVisitor = visitor as IC_GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitIterationStatement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public IterationStatementContext iterationStatement() {
		IterationStatementContext _localctx = new IterationStatementContext(Context, State);
		EnterRule(_localctx, 36, RULE_iterationStatement);
		try {
			State = 296;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,14,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 261;
				Match(While);
				State = 262;
				Match(LeftParen);
				State = 263;
				expression(0);
				State = 264;
				Match(RightParen);
				State = 265;
				statement();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 267;
				Match(Do);
				State = 268;
				statement();
				State = 269;
				Match(While);
				State = 270;
				Match(LeftParen);
				State = 271;
				expression(0);
				State = 272;
				Match(RightParen);
				State = 273;
				Match(Semicolon);
				}
				break;
			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 275;
				Match(For);
				State = 276;
				Match(LeftParen);
				State = 279;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,12,Context) ) {
				case 1:
					{
					State = 277;
					expressionStatement();
					}
					break;
				case 2:
					{
					State = 278;
					declaration();
					}
					break;
				}
				State = 281;
				expressionStatement();
				State = 282;
				Match(RightParen);
				State = 283;
				statement();
				}
				break;
			case 4:
				EnterOuterAlt(_localctx, 4);
				{
				State = 285;
				Match(For);
				State = 286;
				Match(LeftParen);
				State = 289;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,13,Context) ) {
				case 1:
					{
					State = 287;
					expressionStatement();
					}
					break;
				case 2:
					{
					State = 288;
					declaration();
					}
					break;
				}
				State = 291;
				expressionStatement();
				State = 292;
				expression(0);
				State = 293;
				Match(RightParen);
				State = 294;
				statement();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SelectionStatementContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode If() { return GetToken(C_GrammarParser.If, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LeftParen() { return GetToken(C_GrammarParser.LeftParen, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RightParen() { return GetToken(C_GrammarParser.RightParen, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public StatementContext[] statement() {
			return GetRuleContexts<StatementContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public StatementContext statement(int i) {
			return GetRuleContext<StatementContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Else() { return GetToken(C_GrammarParser.Else, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Switch() { return GetToken(C_GrammarParser.Switch, 0); }
		public SelectionStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_selectionStatement; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.EnterSelectionStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.ExitSelectionStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IC_GrammarVisitor<TResult> typedVisitor = visitor as IC_GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSelectionStatement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public SelectionStatementContext selectionStatement() {
		SelectionStatementContext _localctx = new SelectionStatementContext(Context, State);
		EnterRule(_localctx, 38, RULE_selectionStatement);
		try {
			State = 318;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,15,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 298;
				Match(If);
				State = 299;
				Match(LeftParen);
				State = 300;
				expression(0);
				State = 301;
				Match(RightParen);
				State = 302;
				statement();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 304;
				Match(If);
				State = 305;
				Match(LeftParen);
				State = 306;
				expression(0);
				State = 307;
				Match(RightParen);
				State = 308;
				statement();
				State = 309;
				Match(Else);
				State = 310;
				statement();
				}
				break;
			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 312;
				Match(Switch);
				State = 313;
				Match(LeftParen);
				State = 314;
				expression(0);
				State = 315;
				Match(RightParen);
				State = 316;
				statement();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ExpressionStatementContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Semicolon() { return GetToken(C_GrammarParser.Semicolon, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public ExpressionStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_expressionStatement; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.EnterExpressionStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.ExitExpressionStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IC_GrammarVisitor<TResult> typedVisitor = visitor as IC_GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitExpressionStatement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ExpressionStatementContext expressionStatement() {
		ExpressionStatementContext _localctx = new ExpressionStatementContext(Context, State);
		EnterRule(_localctx, 40, RULE_expressionStatement);
		try {
			State = 324;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case Semicolon:
				EnterOuterAlt(_localctx, 1);
				{
				State = 320;
				Match(Semicolon);
				}
				break;
			case Sizeof:
			case Multiply:
			case Plus:
			case Minus:
			case LeftParen:
			case Ampersand:
			case Exclamation:
			case DecOp:
			case IncOp:
			case Identifier:
			case Constant:
			case StringLiteral:
				EnterOuterAlt(_localctx, 2);
				{
				State = 321;
				expression(0);
				State = 322;
				Match(Semicolon);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class StatementListContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public StatementContext statement() {
			return GetRuleContext<StatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public StatementListContext statementList() {
			return GetRuleContext<StatementListContext>(0);
		}
		public StatementListContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_statementList; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.EnterStatementList(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.ExitStatementList(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IC_GrammarVisitor<TResult> typedVisitor = visitor as IC_GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitStatementList(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public StatementListContext statementList() {
		return statementList(0);
	}

	private StatementListContext statementList(int _p) {
		ParserRuleContext _parentctx = Context;
		int _parentState = State;
		StatementListContext _localctx = new StatementListContext(Context, _parentState);
		StatementListContext _prevctx = _localctx;
		int _startState = 42;
		EnterRecursionRule(_localctx, 42, RULE_statementList, _p);
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			{
			State = 327;
			statement();
			}
			Context.Stop = TokenStream.LT(-1);
			State = 333;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,17,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					if ( ParseListeners!=null )
						TriggerExitRuleEvent();
					_prevctx = _localctx;
					{
					{
					_localctx = new StatementListContext(_parentctx, _parentState);
					PushNewRecursionContext(_localctx, _startState, RULE_statementList);
					State = 329;
					if (!(Precpred(Context, 1))) throw new FailedPredicateException(this, "Precpred(Context, 1)");
					State = 330;
					statement();
					}
					} 
				}
				State = 335;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,17,Context);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			UnrollRecursionContexts(_parentctx);
		}
		return _localctx;
	}

	public partial class DeclarationListContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public DeclarationContext declaration() {
			return GetRuleContext<DeclarationContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public DeclarationListContext declarationList() {
			return GetRuleContext<DeclarationListContext>(0);
		}
		public DeclarationListContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_declarationList; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.EnterDeclarationList(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.ExitDeclarationList(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IC_GrammarVisitor<TResult> typedVisitor = visitor as IC_GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitDeclarationList(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public DeclarationListContext declarationList() {
		return declarationList(0);
	}

	private DeclarationListContext declarationList(int _p) {
		ParserRuleContext _parentctx = Context;
		int _parentState = State;
		DeclarationListContext _localctx = new DeclarationListContext(Context, _parentState);
		DeclarationListContext _prevctx = _localctx;
		int _startState = 44;
		EnterRecursionRule(_localctx, 44, RULE_declarationList, _p);
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			{
			State = 337;
			declaration();
			}
			Context.Stop = TokenStream.LT(-1);
			State = 343;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,18,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					if ( ParseListeners!=null )
						TriggerExitRuleEvent();
					_prevctx = _localctx;
					{
					{
					_localctx = new DeclarationListContext(_parentctx, _parentState);
					PushNewRecursionContext(_localctx, _startState, RULE_declarationList);
					State = 339;
					if (!(Precpred(Context, 1))) throw new FailedPredicateException(this, "Precpred(Context, 1)");
					State = 340;
					declaration();
					}
					} 
				}
				State = 345;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,18,Context);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			UnrollRecursionContexts(_parentctx);
		}
		return _localctx;
	}

	public partial class CompoundStatementContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LeftBrace() { return GetToken(C_GrammarParser.LeftBrace, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RightBrace() { return GetToken(C_GrammarParser.RightBrace, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public BlockItemListContext blockItemList() {
			return GetRuleContext<BlockItemListContext>(0);
		}
		public CompoundStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_compoundStatement; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.EnterCompoundStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.ExitCompoundStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IC_GrammarVisitor<TResult> typedVisitor = visitor as IC_GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCompoundStatement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public CompoundStatementContext compoundStatement() {
		CompoundStatementContext _localctx = new CompoundStatementContext(Context, State);
		EnterRule(_localctx, 46, RULE_compoundStatement);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 346;
			Match(LeftBrace);
			State = 348;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if ((((_la) & ~0x3f) == 0 && ((1L << _la) & 8149055167199706350L) != 0) || ((((_la - 74)) & ~0x3f) == 0 && ((1L << (_la - 74)) & 11L) != 0)) {
				{
				State = 347;
				blockItemList(0);
				}
			}

			State = 350;
			Match(RightBrace);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class BlockItemListContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public BlockItemContext blockItem() {
			return GetRuleContext<BlockItemContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public BlockItemListContext blockItemList() {
			return GetRuleContext<BlockItemListContext>(0);
		}
		public BlockItemListContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_blockItemList; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.EnterBlockItemList(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.ExitBlockItemList(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IC_GrammarVisitor<TResult> typedVisitor = visitor as IC_GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitBlockItemList(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public BlockItemListContext blockItemList() {
		return blockItemList(0);
	}

	private BlockItemListContext blockItemList(int _p) {
		ParserRuleContext _parentctx = Context;
		int _parentState = State;
		BlockItemListContext _localctx = new BlockItemListContext(Context, _parentState);
		BlockItemListContext _prevctx = _localctx;
		int _startState = 48;
		EnterRecursionRule(_localctx, 48, RULE_blockItemList, _p);
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			{
			State = 353;
			blockItem();
			}
			Context.Stop = TokenStream.LT(-1);
			State = 359;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,20,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					if ( ParseListeners!=null )
						TriggerExitRuleEvent();
					_prevctx = _localctx;
					{
					{
					_localctx = new BlockItemListContext(_parentctx, _parentState);
					PushNewRecursionContext(_localctx, _startState, RULE_blockItemList);
					State = 355;
					if (!(Precpred(Context, 1))) throw new FailedPredicateException(this, "Precpred(Context, 1)");
					State = 356;
					blockItem();
					}
					} 
				}
				State = 361;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,20,Context);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			UnrollRecursionContexts(_parentctx);
		}
		return _localctx;
	}

	public partial class BlockItemContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public StatementListContext statementList() {
			return GetRuleContext<StatementListContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public DeclarationListContext declarationList() {
			return GetRuleContext<DeclarationListContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public HashStatementContext hashStatement() {
			return GetRuleContext<HashStatementContext>(0);
		}
		public BlockItemContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_blockItem; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.EnterBlockItem(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.ExitBlockItem(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IC_GrammarVisitor<TResult> typedVisitor = visitor as IC_GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitBlockItem(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public BlockItemContext blockItem() {
		BlockItemContext _localctx = new BlockItemContext(Context, State);
		EnterRule(_localctx, 50, RULE_blockItem);
		try {
			State = 365;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,21,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 362;
				statementList(0);
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 363;
				declarationList(0);
				}
				break;
			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 364;
				hashStatement();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class LabeledStatementContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Identifier() { return GetToken(C_GrammarParser.Identifier, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Colon() { return GetToken(C_GrammarParser.Colon, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public StatementContext statement() {
			return GetRuleContext<StatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Case() { return GetToken(C_GrammarParser.Case, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ConstantExpressionContext constantExpression() {
			return GetRuleContext<ConstantExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Default() { return GetToken(C_GrammarParser.Default, 0); }
		public LabeledStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_labeledStatement; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.EnterLabeledStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.ExitLabeledStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IC_GrammarVisitor<TResult> typedVisitor = visitor as IC_GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitLabeledStatement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public LabeledStatementContext labeledStatement() {
		LabeledStatementContext _localctx = new LabeledStatementContext(Context, State);
		EnterRule(_localctx, 52, RULE_labeledStatement);
		try {
			State = 378;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case Identifier:
				EnterOuterAlt(_localctx, 1);
				{
				State = 367;
				Match(Identifier);
				State = 368;
				Match(Colon);
				State = 369;
				statement();
				}
				break;
			case Case:
				EnterOuterAlt(_localctx, 2);
				{
				State = 370;
				Match(Case);
				State = 371;
				constantExpression();
				State = 372;
				Match(Colon);
				State = 373;
				statement();
				}
				break;
			case Default:
				EnterOuterAlt(_localctx, 3);
				{
				State = 375;
				Match(Default);
				State = 376;
				Match(Colon);
				State = 377;
				statement();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class StatementContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public LabeledStatementContext labeledStatement() {
			return GetRuleContext<LabeledStatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public CompoundStatementContext compoundStatement() {
			return GetRuleContext<CompoundStatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionStatementContext expressionStatement() {
			return GetRuleContext<ExpressionStatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public SelectionStatementContext selectionStatement() {
			return GetRuleContext<SelectionStatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public IterationStatementContext iterationStatement() {
			return GetRuleContext<IterationStatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public JumpStatementContext jumpStatement() {
			return GetRuleContext<JumpStatementContext>(0);
		}
		public StatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_statement; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.EnterStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.ExitStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IC_GrammarVisitor<TResult> typedVisitor = visitor as IC_GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitStatement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public StatementContext statement() {
		StatementContext _localctx = new StatementContext(Context, State);
		EnterRule(_localctx, 54, RULE_statement);
		try {
			State = 386;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,23,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 380;
				labeledStatement();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 381;
				compoundStatement();
				}
				break;
			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 382;
				expressionStatement();
				}
				break;
			case 4:
				EnterOuterAlt(_localctx, 4);
				{
				State = 383;
				selectionStatement();
				}
				break;
			case 5:
				EnterOuterAlt(_localctx, 5);
				{
				State = 384;
				iterationStatement();
				}
				break;
			case 6:
				EnterOuterAlt(_localctx, 6);
				{
				State = 385;
				jumpStatement();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class InitializerListContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public InitializerContext initializer() {
			return GetRuleContext<InitializerContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public InitializerListContext initializerList() {
			return GetRuleContext<InitializerListContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Comma() { return GetToken(C_GrammarParser.Comma, 0); }
		public InitializerListContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_initializerList; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.EnterInitializerList(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.ExitInitializerList(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IC_GrammarVisitor<TResult> typedVisitor = visitor as IC_GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitInitializerList(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public InitializerListContext initializerList() {
		return initializerList(0);
	}

	private InitializerListContext initializerList(int _p) {
		ParserRuleContext _parentctx = Context;
		int _parentState = State;
		InitializerListContext _localctx = new InitializerListContext(Context, _parentState);
		InitializerListContext _prevctx = _localctx;
		int _startState = 56;
		EnterRecursionRule(_localctx, 56, RULE_initializerList, _p);
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			{
			State = 389;
			initializer();
			}
			Context.Stop = TokenStream.LT(-1);
			State = 396;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,24,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					if ( ParseListeners!=null )
						TriggerExitRuleEvent();
					_prevctx = _localctx;
					{
					{
					_localctx = new InitializerListContext(_parentctx, _parentState);
					PushNewRecursionContext(_localctx, _startState, RULE_initializerList);
					State = 391;
					if (!(Precpred(Context, 1))) throw new FailedPredicateException(this, "Precpred(Context, 1)");
					State = 392;
					Match(Comma);
					State = 393;
					initializer();
					}
					} 
				}
				State = 398;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,24,Context);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			UnrollRecursionContexts(_parentctx);
		}
		return _localctx;
	}

	public partial class InitializerContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public AssignmentExpressionContext assignmentExpression() {
			return GetRuleContext<AssignmentExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LeftBrace() { return GetToken(C_GrammarParser.LeftBrace, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public InitializerListContext initializerList() {
			return GetRuleContext<InitializerListContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RightBrace() { return GetToken(C_GrammarParser.RightBrace, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Comma() { return GetToken(C_GrammarParser.Comma, 0); }
		public InitializerContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_initializer; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.EnterInitializer(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.ExitInitializer(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IC_GrammarVisitor<TResult> typedVisitor = visitor as IC_GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitInitializer(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public InitializerContext initializer() {
		InitializerContext _localctx = new InitializerContext(Context, State);
		EnterRule(_localctx, 58, RULE_initializer);
		try {
			State = 409;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,25,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 399;
				assignmentExpression();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 400;
				Match(LeftBrace);
				State = 401;
				initializerList(0);
				State = 402;
				Match(RightBrace);
				}
				break;
			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 404;
				Match(LeftBrace);
				State = 405;
				initializerList(0);
				State = 406;
				Match(Comma);
				State = 407;
				Match(RightBrace);
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class DirectAbstractDeclaratorContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LeftParen() { return GetToken(C_GrammarParser.LeftParen, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public AbstractDeclaratorContext abstractDeclarator() {
			return GetRuleContext<AbstractDeclaratorContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RightParen() { return GetToken(C_GrammarParser.RightParen, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LeftBracket() { return GetToken(C_GrammarParser.LeftBracket, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RightBracket() { return GetToken(C_GrammarParser.RightBracket, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ConstantExpressionContext constantExpression() {
			return GetRuleContext<ConstantExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ParameterListContext parameterList() {
			return GetRuleContext<ParameterListContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public DirectAbstractDeclaratorContext directAbstractDeclarator() {
			return GetRuleContext<DirectAbstractDeclaratorContext>(0);
		}
		public DirectAbstractDeclaratorContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_directAbstractDeclarator; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.EnterDirectAbstractDeclarator(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.ExitDirectAbstractDeclarator(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IC_GrammarVisitor<TResult> typedVisitor = visitor as IC_GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitDirectAbstractDeclarator(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public DirectAbstractDeclaratorContext directAbstractDeclarator() {
		return directAbstractDeclarator(0);
	}

	private DirectAbstractDeclaratorContext directAbstractDeclarator(int _p) {
		ParserRuleContext _parentctx = Context;
		int _parentState = State;
		DirectAbstractDeclaratorContext _localctx = new DirectAbstractDeclaratorContext(Context, _parentState);
		DirectAbstractDeclaratorContext _prevctx = _localctx;
		int _startState = 60;
		EnterRecursionRule(_localctx, 60, RULE_directAbstractDeclarator, _p);
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 428;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,26,Context) ) {
			case 1:
				{
				State = 412;
				Match(LeftParen);
				State = 413;
				abstractDeclarator();
				State = 414;
				Match(RightParen);
				}
				break;
			case 2:
				{
				State = 416;
				Match(LeftBracket);
				State = 417;
				Match(RightBracket);
				}
				break;
			case 3:
				{
				State = 418;
				Match(LeftBracket);
				State = 419;
				constantExpression();
				State = 420;
				Match(RightBracket);
				}
				break;
			case 4:
				{
				State = 422;
				Match(LeftParen);
				State = 423;
				Match(RightParen);
				}
				break;
			case 5:
				{
				State = 424;
				Match(LeftParen);
				State = 425;
				parameterList(0);
				State = 426;
				Match(RightParen);
				}
				break;
			}
			Context.Stop = TokenStream.LT(-1);
			State = 448;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,28,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					if ( ParseListeners!=null )
						TriggerExitRuleEvent();
					_prevctx = _localctx;
					{
					State = 446;
					ErrorHandler.Sync(this);
					switch ( Interpreter.AdaptivePredict(TokenStream,27,Context) ) {
					case 1:
						{
						_localctx = new DirectAbstractDeclaratorContext(_parentctx, _parentState);
						PushNewRecursionContext(_localctx, _startState, RULE_directAbstractDeclarator);
						State = 430;
						if (!(Precpred(Context, 6))) throw new FailedPredicateException(this, "Precpred(Context, 6)");
						State = 431;
						Match(LeftBracket);
						State = 432;
						Match(RightBracket);
						}
						break;
					case 2:
						{
						_localctx = new DirectAbstractDeclaratorContext(_parentctx, _parentState);
						PushNewRecursionContext(_localctx, _startState, RULE_directAbstractDeclarator);
						State = 433;
						if (!(Precpred(Context, 5))) throw new FailedPredicateException(this, "Precpred(Context, 5)");
						State = 434;
						Match(LeftBracket);
						State = 435;
						constantExpression();
						State = 436;
						Match(RightBracket);
						}
						break;
					case 3:
						{
						_localctx = new DirectAbstractDeclaratorContext(_parentctx, _parentState);
						PushNewRecursionContext(_localctx, _startState, RULE_directAbstractDeclarator);
						State = 438;
						if (!(Precpred(Context, 2))) throw new FailedPredicateException(this, "Precpred(Context, 2)");
						State = 439;
						Match(LeftParen);
						State = 440;
						Match(RightParen);
						}
						break;
					case 4:
						{
						_localctx = new DirectAbstractDeclaratorContext(_parentctx, _parentState);
						PushNewRecursionContext(_localctx, _startState, RULE_directAbstractDeclarator);
						State = 441;
						if (!(Precpred(Context, 1))) throw new FailedPredicateException(this, "Precpred(Context, 1)");
						State = 442;
						Match(LeftParen);
						State = 443;
						parameterList(0);
						State = 444;
						Match(RightParen);
						}
						break;
					}
					} 
				}
				State = 450;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,28,Context);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			UnrollRecursionContexts(_parentctx);
		}
		return _localctx;
	}

	public partial class AbstractDeclaratorContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public PointerContext pointer() {
			return GetRuleContext<PointerContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public DirectAbstractDeclaratorContext directAbstractDeclarator() {
			return GetRuleContext<DirectAbstractDeclaratorContext>(0);
		}
		public AbstractDeclaratorContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_abstractDeclarator; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.EnterAbstractDeclarator(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.ExitAbstractDeclarator(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IC_GrammarVisitor<TResult> typedVisitor = visitor as IC_GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAbstractDeclarator(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public AbstractDeclaratorContext abstractDeclarator() {
		AbstractDeclaratorContext _localctx = new AbstractDeclaratorContext(Context, State);
		EnterRule(_localctx, 62, RULE_abstractDeclarator);
		try {
			State = 456;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,29,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 451;
				pointer();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 452;
				directAbstractDeclarator(0);
				}
				break;
			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 453;
				pointer();
				State = 454;
				directAbstractDeclarator(0);
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class IdentifierListContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Identifier() { return GetToken(C_GrammarParser.Identifier, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public IdentifierListContext identifierList() {
			return GetRuleContext<IdentifierListContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Comma() { return GetToken(C_GrammarParser.Comma, 0); }
		public IdentifierListContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_identifierList; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.EnterIdentifierList(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.ExitIdentifierList(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IC_GrammarVisitor<TResult> typedVisitor = visitor as IC_GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitIdentifierList(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public IdentifierListContext identifierList() {
		return identifierList(0);
	}

	private IdentifierListContext identifierList(int _p) {
		ParserRuleContext _parentctx = Context;
		int _parentState = State;
		IdentifierListContext _localctx = new IdentifierListContext(Context, _parentState);
		IdentifierListContext _prevctx = _localctx;
		int _startState = 64;
		EnterRecursionRule(_localctx, 64, RULE_identifierList, _p);
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			{
			State = 459;
			Match(Identifier);
			}
			Context.Stop = TokenStream.LT(-1);
			State = 466;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,30,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					if ( ParseListeners!=null )
						TriggerExitRuleEvent();
					_prevctx = _localctx;
					{
					{
					_localctx = new IdentifierListContext(_parentctx, _parentState);
					PushNewRecursionContext(_localctx, _startState, RULE_identifierList);
					State = 461;
					if (!(Precpred(Context, 1))) throw new FailedPredicateException(this, "Precpred(Context, 1)");
					State = 462;
					Match(Comma);
					State = 463;
					Match(Identifier);
					}
					} 
				}
				State = 468;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,30,Context);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			UnrollRecursionContexts(_parentctx);
		}
		return _localctx;
	}

	public partial class ParameterDeclarationContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public DeclarationSpecifiersContext declarationSpecifiers() {
			return GetRuleContext<DeclarationSpecifiersContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public DeclaratorContext declarator() {
			return GetRuleContext<DeclaratorContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public AbstractDeclaratorContext abstractDeclarator() {
			return GetRuleContext<AbstractDeclaratorContext>(0);
		}
		public ParameterDeclarationContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_parameterDeclaration; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.EnterParameterDeclaration(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.ExitParameterDeclaration(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IC_GrammarVisitor<TResult> typedVisitor = visitor as IC_GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitParameterDeclaration(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ParameterDeclarationContext parameterDeclaration() {
		ParameterDeclarationContext _localctx = new ParameterDeclarationContext(Context, State);
		EnterRule(_localctx, 66, RULE_parameterDeclaration);
		try {
			State = 476;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,31,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 469;
				declarationSpecifiers();
				State = 470;
				declarator();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 472;
				declarationSpecifiers();
				State = 473;
				abstractDeclarator();
				}
				break;
			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 475;
				declarationSpecifiers();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ParameterListContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ParameterDeclarationContext parameterDeclaration() {
			return GetRuleContext<ParameterDeclarationContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ParameterListContext parameterList() {
			return GetRuleContext<ParameterListContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Comma() { return GetToken(C_GrammarParser.Comma, 0); }
		public ParameterListContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_parameterList; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.EnterParameterList(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.ExitParameterList(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IC_GrammarVisitor<TResult> typedVisitor = visitor as IC_GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitParameterList(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ParameterListContext parameterList() {
		return parameterList(0);
	}

	private ParameterListContext parameterList(int _p) {
		ParserRuleContext _parentctx = Context;
		int _parentState = State;
		ParameterListContext _localctx = new ParameterListContext(Context, _parentState);
		ParameterListContext _prevctx = _localctx;
		int _startState = 68;
		EnterRecursionRule(_localctx, 68, RULE_parameterList, _p);
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			{
			State = 479;
			parameterDeclaration();
			}
			Context.Stop = TokenStream.LT(-1);
			State = 486;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,32,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					if ( ParseListeners!=null )
						TriggerExitRuleEvent();
					_prevctx = _localctx;
					{
					{
					_localctx = new ParameterListContext(_parentctx, _parentState);
					PushNewRecursionContext(_localctx, _startState, RULE_parameterList);
					State = 481;
					if (!(Precpred(Context, 1))) throw new FailedPredicateException(this, "Precpred(Context, 1)");
					State = 482;
					Match(Comma);
					State = 483;
					parameterDeclaration();
					}
					} 
				}
				State = 488;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,32,Context);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			UnrollRecursionContexts(_parentctx);
		}
		return _localctx;
	}

	public partial class TypeQualifierListContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Const() { return GetToken(C_GrammarParser.Const, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public TypeQualifierListContext typeQualifierList() {
			return GetRuleContext<TypeQualifierListContext>(0);
		}
		public TypeQualifierListContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_typeQualifierList; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.EnterTypeQualifierList(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.ExitTypeQualifierList(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IC_GrammarVisitor<TResult> typedVisitor = visitor as IC_GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTypeQualifierList(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public TypeQualifierListContext typeQualifierList() {
		return typeQualifierList(0);
	}

	private TypeQualifierListContext typeQualifierList(int _p) {
		ParserRuleContext _parentctx = Context;
		int _parentState = State;
		TypeQualifierListContext _localctx = new TypeQualifierListContext(Context, _parentState);
		TypeQualifierListContext _prevctx = _localctx;
		int _startState = 70;
		EnterRecursionRule(_localctx, 70, RULE_typeQualifierList, _p);
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			{
			State = 490;
			Match(Const);
			}
			Context.Stop = TokenStream.LT(-1);
			State = 496;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,33,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					if ( ParseListeners!=null )
						TriggerExitRuleEvent();
					_prevctx = _localctx;
					{
					{
					_localctx = new TypeQualifierListContext(_parentctx, _parentState);
					PushNewRecursionContext(_localctx, _startState, RULE_typeQualifierList);
					State = 492;
					if (!(Precpred(Context, 1))) throw new FailedPredicateException(this, "Precpred(Context, 1)");
					State = 493;
					Match(Const);
					}
					} 
				}
				State = 498;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,33,Context);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			UnrollRecursionContexts(_parentctx);
		}
		return _localctx;
	}

	public partial class PointerContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Multiply() { return GetToken(C_GrammarParser.Multiply, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public TypeQualifierListContext typeQualifierList() {
			return GetRuleContext<TypeQualifierListContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public PointerContext pointer() {
			return GetRuleContext<PointerContext>(0);
		}
		public PointerContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_pointer; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.EnterPointer(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.ExitPointer(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IC_GrammarVisitor<TResult> typedVisitor = visitor as IC_GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitPointer(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public PointerContext pointer() {
		PointerContext _localctx = new PointerContext(Context, State);
		EnterRule(_localctx, 72, RULE_pointer);
		try {
			State = 508;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,34,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 499;
				Match(Multiply);
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 500;
				Match(Multiply);
				State = 501;
				typeQualifierList(0);
				}
				break;
			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 502;
				Match(Multiply);
				State = 503;
				pointer();
				}
				break;
			case 4:
				EnterOuterAlt(_localctx, 4);
				{
				State = 504;
				Match(Multiply);
				State = 505;
				typeQualifierList(0);
				State = 506;
				pointer();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class DirectDeclaratorContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Identifier() { return GetToken(C_GrammarParser.Identifier, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LeftParen() { return GetToken(C_GrammarParser.LeftParen, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public DeclaratorContext declarator() {
			return GetRuleContext<DeclaratorContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RightParen() { return GetToken(C_GrammarParser.RightParen, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public DirectDeclaratorContext directDeclarator() {
			return GetRuleContext<DirectDeclaratorContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LeftBracket() { return GetToken(C_GrammarParser.LeftBracket, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ConstantExpressionContext constantExpression() {
			return GetRuleContext<ConstantExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RightBracket() { return GetToken(C_GrammarParser.RightBracket, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ParameterListContext parameterList() {
			return GetRuleContext<ParameterListContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public IdentifierListContext identifierList() {
			return GetRuleContext<IdentifierListContext>(0);
		}
		public DirectDeclaratorContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_directDeclarator; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.EnterDirectDeclarator(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.ExitDirectDeclarator(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IC_GrammarVisitor<TResult> typedVisitor = visitor as IC_GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitDirectDeclarator(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public DirectDeclaratorContext directDeclarator() {
		return directDeclarator(0);
	}

	private DirectDeclaratorContext directDeclarator(int _p) {
		ParserRuleContext _parentctx = Context;
		int _parentState = State;
		DirectDeclaratorContext _localctx = new DirectDeclaratorContext(Context, _parentState);
		DirectDeclaratorContext _prevctx = _localctx;
		int _startState = 74;
		EnterRecursionRule(_localctx, 74, RULE_directDeclarator, _p);
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 516;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case Identifier:
				{
				State = 511;
				Match(Identifier);
				}
				break;
			case LeftParen:
				{
				State = 512;
				Match(LeftParen);
				State = 513;
				declarator();
				State = 514;
				Match(RightParen);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			Context.Stop = TokenStream.LT(-1);
			State = 541;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,37,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					if ( ParseListeners!=null )
						TriggerExitRuleEvent();
					_prevctx = _localctx;
					{
					State = 539;
					ErrorHandler.Sync(this);
					switch ( Interpreter.AdaptivePredict(TokenStream,36,Context) ) {
					case 1:
						{
						_localctx = new DirectDeclaratorContext(_parentctx, _parentState);
						PushNewRecursionContext(_localctx, _startState, RULE_directDeclarator);
						State = 518;
						if (!(Precpred(Context, 5))) throw new FailedPredicateException(this, "Precpred(Context, 5)");
						State = 519;
						Match(LeftBracket);
						State = 520;
						constantExpression();
						State = 521;
						Match(RightBracket);
						}
						break;
					case 2:
						{
						_localctx = new DirectDeclaratorContext(_parentctx, _parentState);
						PushNewRecursionContext(_localctx, _startState, RULE_directDeclarator);
						State = 523;
						if (!(Precpred(Context, 4))) throw new FailedPredicateException(this, "Precpred(Context, 4)");
						State = 524;
						Match(LeftBracket);
						State = 525;
						Match(RightBracket);
						}
						break;
					case 3:
						{
						_localctx = new DirectDeclaratorContext(_parentctx, _parentState);
						PushNewRecursionContext(_localctx, _startState, RULE_directDeclarator);
						State = 526;
						if (!(Precpred(Context, 3))) throw new FailedPredicateException(this, "Precpred(Context, 3)");
						State = 527;
						Match(LeftParen);
						State = 528;
						parameterList(0);
						State = 529;
						Match(RightParen);
						}
						break;
					case 4:
						{
						_localctx = new DirectDeclaratorContext(_parentctx, _parentState);
						PushNewRecursionContext(_localctx, _startState, RULE_directDeclarator);
						State = 531;
						if (!(Precpred(Context, 2))) throw new FailedPredicateException(this, "Precpred(Context, 2)");
						State = 532;
						Match(LeftParen);
						State = 533;
						identifierList(0);
						State = 534;
						Match(RightParen);
						}
						break;
					case 5:
						{
						_localctx = new DirectDeclaratorContext(_parentctx, _parentState);
						PushNewRecursionContext(_localctx, _startState, RULE_directDeclarator);
						State = 536;
						if (!(Precpred(Context, 1))) throw new FailedPredicateException(this, "Precpred(Context, 1)");
						State = 537;
						Match(LeftParen);
						State = 538;
						Match(RightParen);
						}
						break;
					}
					} 
				}
				State = 543;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,37,Context);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			UnrollRecursionContexts(_parentctx);
		}
		return _localctx;
	}

	public partial class DeclaratorContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public PointerContext pointer() {
			return GetRuleContext<PointerContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public DirectDeclaratorContext directDeclarator() {
			return GetRuleContext<DirectDeclaratorContext>(0);
		}
		public DeclaratorContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_declarator; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.EnterDeclarator(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.ExitDeclarator(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IC_GrammarVisitor<TResult> typedVisitor = visitor as IC_GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitDeclarator(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public DeclaratorContext declarator() {
		DeclaratorContext _localctx = new DeclaratorContext(Context, State);
		EnterRule(_localctx, 76, RULE_declarator);
		try {
			State = 548;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case Multiply:
				EnterOuterAlt(_localctx, 1);
				{
				State = 544;
				pointer();
				State = 545;
				directDeclarator(0);
				}
				break;
			case LeftParen:
			case Identifier:
				EnterOuterAlt(_localctx, 2);
				{
				State = 547;
				directDeclarator(0);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SpecifierQualifierListContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public TypeSpecifierContext typeSpecifier() {
			return GetRuleContext<TypeSpecifierContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public SpecifierQualifierListContext specifierQualifierList() {
			return GetRuleContext<SpecifierQualifierListContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Const() { return GetToken(C_GrammarParser.Const, 0); }
		public SpecifierQualifierListContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_specifierQualifierList; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.EnterSpecifierQualifierList(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.ExitSpecifierQualifierList(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IC_GrammarVisitor<TResult> typedVisitor = visitor as IC_GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSpecifierQualifierList(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public SpecifierQualifierListContext specifierQualifierList() {
		SpecifierQualifierListContext _localctx = new SpecifierQualifierListContext(Context, State);
		EnterRule(_localctx, 78, RULE_specifierQualifierList);
		try {
			State = 557;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,39,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 550;
				typeSpecifier();
				State = 551;
				specifierQualifierList();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 553;
				typeSpecifier();
				}
				break;
			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 554;
				Match(Const);
				State = 555;
				specifierQualifierList();
				}
				break;
			case 4:
				EnterOuterAlt(_localctx, 4);
				{
				State = 556;
				Match(Const);
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class StructSpecifierContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Struct() { return GetToken(C_GrammarParser.Struct, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Identifier() { return GetToken(C_GrammarParser.Identifier, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LeftBrace() { return GetToken(C_GrammarParser.LeftBrace, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public StructDeclarationListContext structDeclarationList() {
			return GetRuleContext<StructDeclarationListContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RightBrace() { return GetToken(C_GrammarParser.RightBrace, 0); }
		public StructSpecifierContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_structSpecifier; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.EnterStructSpecifier(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.ExitStructSpecifier(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IC_GrammarVisitor<TResult> typedVisitor = visitor as IC_GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitStructSpecifier(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public StructSpecifierContext structSpecifier() {
		StructSpecifierContext _localctx = new StructSpecifierContext(Context, State);
		EnterRule(_localctx, 80, RULE_structSpecifier);
		try {
			State = 572;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,40,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 559;
				Match(Struct);
				State = 560;
				Match(Identifier);
				State = 561;
				Match(LeftBrace);
				State = 562;
				structDeclarationList(0);
				State = 563;
				Match(RightBrace);
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 565;
				Match(Struct);
				State = 566;
				Match(LeftBrace);
				State = 567;
				structDeclarationList(0);
				State = 568;
				Match(RightBrace);
				}
				break;
			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 570;
				Match(Struct);
				State = 571;
				Match(Identifier);
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class StructDeclarationListContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public StructDeclarationContext structDeclaration() {
			return GetRuleContext<StructDeclarationContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public StructDeclarationListContext structDeclarationList() {
			return GetRuleContext<StructDeclarationListContext>(0);
		}
		public StructDeclarationListContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_structDeclarationList; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.EnterStructDeclarationList(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.ExitStructDeclarationList(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IC_GrammarVisitor<TResult> typedVisitor = visitor as IC_GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitStructDeclarationList(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public StructDeclarationListContext structDeclarationList() {
		return structDeclarationList(0);
	}

	private StructDeclarationListContext structDeclarationList(int _p) {
		ParserRuleContext _parentctx = Context;
		int _parentState = State;
		StructDeclarationListContext _localctx = new StructDeclarationListContext(Context, _parentState);
		StructDeclarationListContext _prevctx = _localctx;
		int _startState = 82;
		EnterRecursionRule(_localctx, 82, RULE_structDeclarationList, _p);
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			{
			State = 575;
			structDeclaration();
			}
			Context.Stop = TokenStream.LT(-1);
			State = 581;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,41,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					if ( ParseListeners!=null )
						TriggerExitRuleEvent();
					_prevctx = _localctx;
					{
					{
					_localctx = new StructDeclarationListContext(_parentctx, _parentState);
					PushNewRecursionContext(_localctx, _startState, RULE_structDeclarationList);
					State = 577;
					if (!(Precpred(Context, 1))) throw new FailedPredicateException(this, "Precpred(Context, 1)");
					State = 578;
					structDeclaration();
					}
					} 
				}
				State = 583;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,41,Context);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			UnrollRecursionContexts(_parentctx);
		}
		return _localctx;
	}

	public partial class StructDeclarationContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public SpecifierQualifierListContext specifierQualifierList() {
			return GetRuleContext<SpecifierQualifierListContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public StructDeclaratorListContext structDeclaratorList() {
			return GetRuleContext<StructDeclaratorListContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Semicolon() { return GetToken(C_GrammarParser.Semicolon, 0); }
		public StructDeclarationContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_structDeclaration; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.EnterStructDeclaration(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.ExitStructDeclaration(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IC_GrammarVisitor<TResult> typedVisitor = visitor as IC_GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitStructDeclaration(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public StructDeclarationContext structDeclaration() {
		StructDeclarationContext _localctx = new StructDeclarationContext(Context, State);
		EnterRule(_localctx, 84, RULE_structDeclaration);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 584;
			specifierQualifierList();
			State = 585;
			structDeclaratorList(0);
			State = 586;
			Match(Semicolon);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class StructDeclaratorListContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public StructDeclaratorContext structDeclarator() {
			return GetRuleContext<StructDeclaratorContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public StructDeclaratorListContext structDeclaratorList() {
			return GetRuleContext<StructDeclaratorListContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Comma() { return GetToken(C_GrammarParser.Comma, 0); }
		public StructDeclaratorListContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_structDeclaratorList; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.EnterStructDeclaratorList(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.ExitStructDeclaratorList(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IC_GrammarVisitor<TResult> typedVisitor = visitor as IC_GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitStructDeclaratorList(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public StructDeclaratorListContext structDeclaratorList() {
		return structDeclaratorList(0);
	}

	private StructDeclaratorListContext structDeclaratorList(int _p) {
		ParserRuleContext _parentctx = Context;
		int _parentState = State;
		StructDeclaratorListContext _localctx = new StructDeclaratorListContext(Context, _parentState);
		StructDeclaratorListContext _prevctx = _localctx;
		int _startState = 86;
		EnterRecursionRule(_localctx, 86, RULE_structDeclaratorList, _p);
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			{
			State = 589;
			structDeclarator();
			}
			Context.Stop = TokenStream.LT(-1);
			State = 596;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,42,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					if ( ParseListeners!=null )
						TriggerExitRuleEvent();
					_prevctx = _localctx;
					{
					{
					_localctx = new StructDeclaratorListContext(_parentctx, _parentState);
					PushNewRecursionContext(_localctx, _startState, RULE_structDeclaratorList);
					State = 591;
					if (!(Precpred(Context, 1))) throw new FailedPredicateException(this, "Precpred(Context, 1)");
					State = 592;
					Match(Comma);
					State = 593;
					structDeclarator();
					}
					} 
				}
				State = 598;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,42,Context);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			UnrollRecursionContexts(_parentctx);
		}
		return _localctx;
	}

	public partial class StructDeclaratorContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public DeclaratorContext declarator() {
			return GetRuleContext<DeclaratorContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Colon() { return GetToken(C_GrammarParser.Colon, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ConstantExpressionContext constantExpression() {
			return GetRuleContext<ConstantExpressionContext>(0);
		}
		public StructDeclaratorContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_structDeclarator; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.EnterStructDeclarator(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.ExitStructDeclarator(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IC_GrammarVisitor<TResult> typedVisitor = visitor as IC_GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitStructDeclarator(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public StructDeclaratorContext structDeclarator() {
		StructDeclaratorContext _localctx = new StructDeclaratorContext(Context, State);
		EnterRule(_localctx, 88, RULE_structDeclarator);
		try {
			State = 606;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,43,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 599;
				declarator();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 600;
				Match(Colon);
				State = 601;
				constantExpression();
				}
				break;
			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 602;
				declarator();
				State = 603;
				Match(Colon);
				State = 604;
				constantExpression();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class StorageClassSpecifierContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Typedef() { return GetToken(C_GrammarParser.Typedef, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Extern() { return GetToken(C_GrammarParser.Extern, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Static() { return GetToken(C_GrammarParser.Static, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Auto() { return GetToken(C_GrammarParser.Auto, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Register() { return GetToken(C_GrammarParser.Register, 0); }
		public StorageClassSpecifierContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_storageClassSpecifier; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.EnterStorageClassSpecifier(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.ExitStorageClassSpecifier(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IC_GrammarVisitor<TResult> typedVisitor = visitor as IC_GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitStorageClassSpecifier(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public StorageClassSpecifierContext storageClassSpecifier() {
		StorageClassSpecifierContext _localctx = new StorageClassSpecifierContext(Context, State);
		EnterRule(_localctx, 90, RULE_storageClassSpecifier);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 608;
			_la = TokenStream.LA(1);
			if ( !((((_la) & ~0x3f) == 0 && ((1L << _la) & 126976L) != 0)) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TypeSpecifierContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Void() { return GetToken(C_GrammarParser.Void, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Char() { return GetToken(C_GrammarParser.Char, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Short() { return GetToken(C_GrammarParser.Short, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Int() { return GetToken(C_GrammarParser.Int, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Long() { return GetToken(C_GrammarParser.Long, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Float() { return GetToken(C_GrammarParser.Float, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Double() { return GetToken(C_GrammarParser.Double, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Signed() { return GetToken(C_GrammarParser.Signed, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Unsigned() { return GetToken(C_GrammarParser.Unsigned, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Bool() { return GetToken(C_GrammarParser.Bool, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public StructSpecifierContext structSpecifier() {
			return GetRuleContext<StructSpecifierContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public TypeNameIdentifierContext typeNameIdentifier() {
			return GetRuleContext<TypeNameIdentifierContext>(0);
		}
		public TypeSpecifierContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_typeSpecifier; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.EnterTypeSpecifier(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.ExitTypeSpecifier(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IC_GrammarVisitor<TResult> typedVisitor = visitor as IC_GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTypeSpecifier(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public TypeSpecifierContext typeSpecifier() {
		TypeSpecifierContext _localctx = new TypeSpecifierContext(Context, State);
		EnterRule(_localctx, 92, RULE_typeSpecifier);
		try {
			State = 622;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case Void:
				EnterOuterAlt(_localctx, 1);
				{
				State = 610;
				Match(Void);
				}
				break;
			case Char:
				EnterOuterAlt(_localctx, 2);
				{
				State = 611;
				Match(Char);
				}
				break;
			case Short:
				EnterOuterAlt(_localctx, 3);
				{
				State = 612;
				Match(Short);
				}
				break;
			case Int:
				EnterOuterAlt(_localctx, 4);
				{
				State = 613;
				Match(Int);
				}
				break;
			case Long:
				EnterOuterAlt(_localctx, 5);
				{
				State = 614;
				Match(Long);
				}
				break;
			case Float:
				EnterOuterAlt(_localctx, 6);
				{
				State = 615;
				Match(Float);
				}
				break;
			case Double:
				EnterOuterAlt(_localctx, 7);
				{
				State = 616;
				Match(Double);
				}
				break;
			case Signed:
				EnterOuterAlt(_localctx, 8);
				{
				State = 617;
				Match(Signed);
				}
				break;
			case Unsigned:
				EnterOuterAlt(_localctx, 9);
				{
				State = 618;
				Match(Unsigned);
				}
				break;
			case Bool:
				EnterOuterAlt(_localctx, 10);
				{
				State = 619;
				Match(Bool);
				}
				break;
			case Struct:
				EnterOuterAlt(_localctx, 11);
				{
				State = 620;
				structSpecifier();
				}
				break;
			case Identifier:
				EnterOuterAlt(_localctx, 12);
				{
				State = 621;
				typeNameIdentifier();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TypeNameIdentifierContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Identifier() { return GetToken(C_GrammarParser.Identifier, 0); }
		public TypeNameIdentifierContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_typeNameIdentifier; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.EnterTypeNameIdentifier(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.ExitTypeNameIdentifier(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IC_GrammarVisitor<TResult> typedVisitor = visitor as IC_GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTypeNameIdentifier(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public TypeNameIdentifierContext typeNameIdentifier() {
		TypeNameIdentifierContext _localctx = new TypeNameIdentifierContext(Context, State);
		EnterRule(_localctx, 94, RULE_typeNameIdentifier);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 624;
			Match(Identifier);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TypeNameContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public SpecifierQualifierListContext specifierQualifierList() {
			return GetRuleContext<SpecifierQualifierListContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public AbstractDeclaratorContext abstractDeclarator() {
			return GetRuleContext<AbstractDeclaratorContext>(0);
		}
		public TypeNameContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_typeName; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.EnterTypeName(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.ExitTypeName(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IC_GrammarVisitor<TResult> typedVisitor = visitor as IC_GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTypeName(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public TypeNameContext typeName() {
		TypeNameContext _localctx = new TypeNameContext(Context, State);
		EnterRule(_localctx, 96, RULE_typeName);
		try {
			State = 630;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,45,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 626;
				specifierQualifierList();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 627;
				specifierQualifierList();
				State = 628;
				abstractDeclarator();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class DeclarationSpecifiersContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public StorageClassSpecifierContext storageClassSpecifier() {
			return GetRuleContext<StorageClassSpecifierContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public DeclarationSpecifiersContext declarationSpecifiers() {
			return GetRuleContext<DeclarationSpecifiersContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public TypeSpecifierContext typeSpecifier() {
			return GetRuleContext<TypeSpecifierContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Const() { return GetToken(C_GrammarParser.Const, 0); }
		public DeclarationSpecifiersContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_declarationSpecifiers; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.EnterDeclarationSpecifiers(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.ExitDeclarationSpecifiers(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IC_GrammarVisitor<TResult> typedVisitor = visitor as IC_GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitDeclarationSpecifiers(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public DeclarationSpecifiersContext declarationSpecifiers() {
		DeclarationSpecifiersContext _localctx = new DeclarationSpecifiersContext(Context, State);
		EnterRule(_localctx, 98, RULE_declarationSpecifiers);
		try {
			State = 643;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,46,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 632;
				storageClassSpecifier();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 633;
				storageClassSpecifier();
				State = 634;
				declarationSpecifiers();
				}
				break;
			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 636;
				typeSpecifier();
				}
				break;
			case 4:
				EnterOuterAlt(_localctx, 4);
				{
				State = 637;
				typeSpecifier();
				State = 638;
				declarationSpecifiers();
				}
				break;
			case 5:
				EnterOuterAlt(_localctx, 5);
				{
				State = 640;
				Match(Const);
				}
				break;
			case 6:
				EnterOuterAlt(_localctx, 6);
				{
				State = 641;
				Match(Const);
				State = 642;
				declarationSpecifiers();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class InitDeclaratorListContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public InitDeclaratorContext initDeclarator() {
			return GetRuleContext<InitDeclaratorContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public InitDeclaratorListContext initDeclaratorList() {
			return GetRuleContext<InitDeclaratorListContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Comma() { return GetToken(C_GrammarParser.Comma, 0); }
		public InitDeclaratorListContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_initDeclaratorList; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.EnterInitDeclaratorList(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.ExitInitDeclaratorList(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IC_GrammarVisitor<TResult> typedVisitor = visitor as IC_GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitInitDeclaratorList(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public InitDeclaratorListContext initDeclaratorList() {
		return initDeclaratorList(0);
	}

	private InitDeclaratorListContext initDeclaratorList(int _p) {
		ParserRuleContext _parentctx = Context;
		int _parentState = State;
		InitDeclaratorListContext _localctx = new InitDeclaratorListContext(Context, _parentState);
		InitDeclaratorListContext _prevctx = _localctx;
		int _startState = 100;
		EnterRecursionRule(_localctx, 100, RULE_initDeclaratorList, _p);
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			{
			State = 646;
			initDeclarator();
			}
			Context.Stop = TokenStream.LT(-1);
			State = 653;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,47,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					if ( ParseListeners!=null )
						TriggerExitRuleEvent();
					_prevctx = _localctx;
					{
					{
					_localctx = new InitDeclaratorListContext(_parentctx, _parentState);
					PushNewRecursionContext(_localctx, _startState, RULE_initDeclaratorList);
					State = 648;
					if (!(Precpred(Context, 1))) throw new FailedPredicateException(this, "Precpred(Context, 1)");
					State = 649;
					Match(Comma);
					State = 650;
					initDeclarator();
					}
					} 
				}
				State = 655;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,47,Context);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			UnrollRecursionContexts(_parentctx);
		}
		return _localctx;
	}

	public partial class InitDeclaratorContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public DeclaratorContext declarator() {
			return GetRuleContext<DeclaratorContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Assign() { return GetToken(C_GrammarParser.Assign, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public InitializerContext initializer() {
			return GetRuleContext<InitializerContext>(0);
		}
		public InitDeclaratorContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_initDeclarator; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.EnterInitDeclarator(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.ExitInitDeclarator(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IC_GrammarVisitor<TResult> typedVisitor = visitor as IC_GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitInitDeclarator(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public InitDeclaratorContext initDeclarator() {
		InitDeclaratorContext _localctx = new InitDeclaratorContext(Context, State);
		EnterRule(_localctx, 102, RULE_initDeclarator);
		try {
			State = 661;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,48,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 656;
				declarator();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 657;
				declarator();
				State = 658;
				Match(Assign);
				State = 659;
				initializer();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class DeclarationContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public DeclarationSpecifiersContext declarationSpecifiers() {
			return GetRuleContext<DeclarationSpecifiersContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Semicolon() { return GetToken(C_GrammarParser.Semicolon, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public InitDeclaratorListContext initDeclaratorList() {
			return GetRuleContext<InitDeclaratorListContext>(0);
		}
		public DeclarationContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_declaration; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.EnterDeclaration(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.ExitDeclaration(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IC_GrammarVisitor<TResult> typedVisitor = visitor as IC_GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitDeclaration(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public DeclarationContext declaration() {
		DeclarationContext _localctx = new DeclarationContext(Context, State);
		EnterRule(_localctx, 104, RULE_declaration);
		try {
			State = 670;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,49,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 663;
				declarationSpecifiers();
				State = 664;
				Match(Semicolon);
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 666;
				declarationSpecifiers();
				State = 667;
				initDeclaratorList(0);
				State = 668;
				Match(Semicolon);
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ConstantExpressionContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ConditionalExpressionContext conditionalExpression() {
			return GetRuleContext<ConditionalExpressionContext>(0);
		}
		public ConstantExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_constantExpression; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.EnterConstantExpression(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.ExitConstantExpression(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IC_GrammarVisitor<TResult> typedVisitor = visitor as IC_GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitConstantExpression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ConstantExpressionContext constantExpression() {
		ConstantExpressionContext _localctx = new ConstantExpressionContext(Context, State);
		EnterRule(_localctx, 106, RULE_constantExpression);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 672;
			conditionalExpression();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ExpressionContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public AssignmentExpressionContext assignmentExpression() {
			return GetRuleContext<AssignmentExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Comma() { return GetToken(C_GrammarParser.Comma, 0); }
		public ExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_expression; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.EnterExpression(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.ExitExpression(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IC_GrammarVisitor<TResult> typedVisitor = visitor as IC_GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitExpression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ExpressionContext expression() {
		return expression(0);
	}

	private ExpressionContext expression(int _p) {
		ParserRuleContext _parentctx = Context;
		int _parentState = State;
		ExpressionContext _localctx = new ExpressionContext(Context, _parentState);
		ExpressionContext _prevctx = _localctx;
		int _startState = 108;
		EnterRecursionRule(_localctx, 108, RULE_expression, _p);
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			{
			State = 675;
			assignmentExpression();
			}
			Context.Stop = TokenStream.LT(-1);
			State = 682;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,50,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					if ( ParseListeners!=null )
						TriggerExitRuleEvent();
					_prevctx = _localctx;
					{
					{
					_localctx = new ExpressionContext(_parentctx, _parentState);
					PushNewRecursionContext(_localctx, _startState, RULE_expression);
					State = 677;
					if (!(Precpred(Context, 1))) throw new FailedPredicateException(this, "Precpred(Context, 1)");
					State = 678;
					Match(Comma);
					State = 679;
					assignmentExpression();
					}
					} 
				}
				State = 684;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,50,Context);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			UnrollRecursionContexts(_parentctx);
		}
		return _localctx;
	}

	public partial class AssignmentOperatorContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Assign() { return GetToken(C_GrammarParser.Assign, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode MulAssign() { return GetToken(C_GrammarParser.MulAssign, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DivAssign() { return GetToken(C_GrammarParser.DivAssign, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ModAssign() { return GetToken(C_GrammarParser.ModAssign, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode AddAssign() { return GetToken(C_GrammarParser.AddAssign, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SubAssign() { return GetToken(C_GrammarParser.SubAssign, 0); }
		public AssignmentOperatorContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_assignmentOperator; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.EnterAssignmentOperator(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.ExitAssignmentOperator(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IC_GrammarVisitor<TResult> typedVisitor = visitor as IC_GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAssignmentOperator(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public AssignmentOperatorContext assignmentOperator() {
		AssignmentOperatorContext _localctx = new AssignmentOperatorContext(Context, State);
		EnterRule(_localctx, 110, RULE_assignmentOperator);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 685;
			_la = TokenStream.LA(1);
			if ( !(((((_la - 43)) & ~0x3f) == 0 && ((1L << (_la - 43)) & 2080374785L) != 0)) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class AssignmentExpressionContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ConditionalExpressionContext conditionalExpression() {
			return GetRuleContext<ConditionalExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public UnaryExpressionContext unaryExpression() {
			return GetRuleContext<UnaryExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public AssignmentOperatorContext assignmentOperator() {
			return GetRuleContext<AssignmentOperatorContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public AssignmentExpressionContext assignmentExpression() {
			return GetRuleContext<AssignmentExpressionContext>(0);
		}
		public AssignmentExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_assignmentExpression; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.EnterAssignmentExpression(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.ExitAssignmentExpression(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IC_GrammarVisitor<TResult> typedVisitor = visitor as IC_GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAssignmentExpression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public AssignmentExpressionContext assignmentExpression() {
		AssignmentExpressionContext _localctx = new AssignmentExpressionContext(Context, State);
		EnterRule(_localctx, 112, RULE_assignmentExpression);
		try {
			State = 692;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,51,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 687;
				conditionalExpression();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 688;
				unaryExpression();
				State = 689;
				assignmentOperator();
				State = 690;
				assignmentExpression();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ConditionalExpressionContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public LogicalOrExpressionContext logicalOrExpression() {
			return GetRuleContext<LogicalOrExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode QuestionMark() { return GetToken(C_GrammarParser.QuestionMark, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Colon() { return GetToken(C_GrammarParser.Colon, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ConditionalExpressionContext conditionalExpression() {
			return GetRuleContext<ConditionalExpressionContext>(0);
		}
		public ConditionalExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_conditionalExpression; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.EnterConditionalExpression(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.ExitConditionalExpression(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IC_GrammarVisitor<TResult> typedVisitor = visitor as IC_GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitConditionalExpression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ConditionalExpressionContext conditionalExpression() {
		ConditionalExpressionContext _localctx = new ConditionalExpressionContext(Context, State);
		EnterRule(_localctx, 114, RULE_conditionalExpression);
		try {
			State = 701;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,52,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 694;
				logicalOrExpression(0);
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 695;
				logicalOrExpression(0);
				State = 696;
				Match(QuestionMark);
				State = 697;
				expression(0);
				State = 698;
				Match(Colon);
				State = 699;
				conditionalExpression();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class LogicalOrExpressionContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public LogicalAndExpressionContext logicalAndExpression() {
			return GetRuleContext<LogicalAndExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public LogicalOrExpressionContext logicalOrExpression() {
			return GetRuleContext<LogicalOrExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode OrOp() { return GetToken(C_GrammarParser.OrOp, 0); }
		public LogicalOrExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_logicalOrExpression; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.EnterLogicalOrExpression(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.ExitLogicalOrExpression(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IC_GrammarVisitor<TResult> typedVisitor = visitor as IC_GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitLogicalOrExpression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public LogicalOrExpressionContext logicalOrExpression() {
		return logicalOrExpression(0);
	}

	private LogicalOrExpressionContext logicalOrExpression(int _p) {
		ParserRuleContext _parentctx = Context;
		int _parentState = State;
		LogicalOrExpressionContext _localctx = new LogicalOrExpressionContext(Context, _parentState);
		LogicalOrExpressionContext _prevctx = _localctx;
		int _startState = 116;
		EnterRecursionRule(_localctx, 116, RULE_logicalOrExpression, _p);
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			{
			State = 704;
			logicalAndExpression(0);
			}
			Context.Stop = TokenStream.LT(-1);
			State = 711;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,53,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					if ( ParseListeners!=null )
						TriggerExitRuleEvent();
					_prevctx = _localctx;
					{
					{
					_localctx = new LogicalOrExpressionContext(_parentctx, _parentState);
					PushNewRecursionContext(_localctx, _startState, RULE_logicalOrExpression);
					State = 706;
					if (!(Precpred(Context, 1))) throw new FailedPredicateException(this, "Precpred(Context, 1)");
					State = 707;
					Match(OrOp);
					State = 708;
					logicalAndExpression(0);
					}
					} 
				}
				State = 713;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,53,Context);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			UnrollRecursionContexts(_parentctx);
		}
		return _localctx;
	}

	public partial class LogicalAndExpressionContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public EqualityExpressionContext equalityExpression() {
			return GetRuleContext<EqualityExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public LogicalAndExpressionContext logicalAndExpression() {
			return GetRuleContext<LogicalAndExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode AndOp() { return GetToken(C_GrammarParser.AndOp, 0); }
		public LogicalAndExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_logicalAndExpression; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.EnterLogicalAndExpression(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.ExitLogicalAndExpression(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IC_GrammarVisitor<TResult> typedVisitor = visitor as IC_GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitLogicalAndExpression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public LogicalAndExpressionContext logicalAndExpression() {
		return logicalAndExpression(0);
	}

	private LogicalAndExpressionContext logicalAndExpression(int _p) {
		ParserRuleContext _parentctx = Context;
		int _parentState = State;
		LogicalAndExpressionContext _localctx = new LogicalAndExpressionContext(Context, _parentState);
		LogicalAndExpressionContext _prevctx = _localctx;
		int _startState = 118;
		EnterRecursionRule(_localctx, 118, RULE_logicalAndExpression, _p);
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			{
			State = 715;
			equalityExpression(0);
			}
			Context.Stop = TokenStream.LT(-1);
			State = 722;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,54,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					if ( ParseListeners!=null )
						TriggerExitRuleEvent();
					_prevctx = _localctx;
					{
					{
					_localctx = new LogicalAndExpressionContext(_parentctx, _parentState);
					PushNewRecursionContext(_localctx, _startState, RULE_logicalAndExpression);
					State = 717;
					if (!(Precpred(Context, 1))) throw new FailedPredicateException(this, "Precpred(Context, 1)");
					State = 718;
					Match(AndOp);
					State = 719;
					equalityExpression(0);
					}
					} 
				}
				State = 724;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,54,Context);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			UnrollRecursionContexts(_parentctx);
		}
		return _localctx;
	}

	public partial class EqualityExpressionContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public RelationalExpressionContext relationalExpression() {
			return GetRuleContext<RelationalExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public EqualityExpressionContext equalityExpression() {
			return GetRuleContext<EqualityExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode EqOp() { return GetToken(C_GrammarParser.EqOp, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NeOp() { return GetToken(C_GrammarParser.NeOp, 0); }
		public EqualityExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_equalityExpression; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.EnterEqualityExpression(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.ExitEqualityExpression(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IC_GrammarVisitor<TResult> typedVisitor = visitor as IC_GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitEqualityExpression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public EqualityExpressionContext equalityExpression() {
		return equalityExpression(0);
	}

	private EqualityExpressionContext equalityExpression(int _p) {
		ParserRuleContext _parentctx = Context;
		int _parentState = State;
		EqualityExpressionContext _localctx = new EqualityExpressionContext(Context, _parentState);
		EqualityExpressionContext _prevctx = _localctx;
		int _startState = 120;
		EnterRecursionRule(_localctx, 120, RULE_equalityExpression, _p);
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			{
			State = 726;
			relationalExpression(0);
			}
			Context.Stop = TokenStream.LT(-1);
			State = 736;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,56,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					if ( ParseListeners!=null )
						TriggerExitRuleEvent();
					_prevctx = _localctx;
					{
					State = 734;
					ErrorHandler.Sync(this);
					switch ( Interpreter.AdaptivePredict(TokenStream,55,Context) ) {
					case 1:
						{
						_localctx = new EqualityExpressionContext(_parentctx, _parentState);
						PushNewRecursionContext(_localctx, _startState, RULE_equalityExpression);
						State = 728;
						if (!(Precpred(Context, 2))) throw new FailedPredicateException(this, "Precpred(Context, 2)");
						State = 729;
						Match(EqOp);
						State = 730;
						relationalExpression(0);
						}
						break;
					case 2:
						{
						_localctx = new EqualityExpressionContext(_parentctx, _parentState);
						PushNewRecursionContext(_localctx, _startState, RULE_equalityExpression);
						State = 731;
						if (!(Precpred(Context, 1))) throw new FailedPredicateException(this, "Precpred(Context, 1)");
						State = 732;
						Match(NeOp);
						State = 733;
						relationalExpression(0);
						}
						break;
					}
					} 
				}
				State = 738;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,56,Context);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			UnrollRecursionContexts(_parentctx);
		}
		return _localctx;
	}

	public partial class RelationalExpressionContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public AdditiveExpressionContext additiveExpression() {
			return GetRuleContext<AdditiveExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public RelationalExpressionContext relationalExpression() {
			return GetRuleContext<RelationalExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Less() { return GetToken(C_GrammarParser.Less, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Greater() { return GetToken(C_GrammarParser.Greater, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LeOp() { return GetToken(C_GrammarParser.LeOp, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode GeOp() { return GetToken(C_GrammarParser.GeOp, 0); }
		public RelationalExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_relationalExpression; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.EnterRelationalExpression(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.ExitRelationalExpression(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IC_GrammarVisitor<TResult> typedVisitor = visitor as IC_GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitRelationalExpression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public RelationalExpressionContext relationalExpression() {
		return relationalExpression(0);
	}

	private RelationalExpressionContext relationalExpression(int _p) {
		ParserRuleContext _parentctx = Context;
		int _parentState = State;
		RelationalExpressionContext _localctx = new RelationalExpressionContext(Context, _parentState);
		RelationalExpressionContext _prevctx = _localctx;
		int _startState = 122;
		EnterRecursionRule(_localctx, 122, RULE_relationalExpression, _p);
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			{
			State = 740;
			additiveExpression(0);
			}
			Context.Stop = TokenStream.LT(-1);
			State = 756;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,58,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					if ( ParseListeners!=null )
						TriggerExitRuleEvent();
					_prevctx = _localctx;
					{
					State = 754;
					ErrorHandler.Sync(this);
					switch ( Interpreter.AdaptivePredict(TokenStream,57,Context) ) {
					case 1:
						{
						_localctx = new RelationalExpressionContext(_parentctx, _parentState);
						PushNewRecursionContext(_localctx, _startState, RULE_relationalExpression);
						State = 742;
						if (!(Precpred(Context, 4))) throw new FailedPredicateException(this, "Precpred(Context, 4)");
						State = 743;
						Match(Less);
						State = 744;
						additiveExpression(0);
						}
						break;
					case 2:
						{
						_localctx = new RelationalExpressionContext(_parentctx, _parentState);
						PushNewRecursionContext(_localctx, _startState, RULE_relationalExpression);
						State = 745;
						if (!(Precpred(Context, 3))) throw new FailedPredicateException(this, "Precpred(Context, 3)");
						State = 746;
						Match(Greater);
						State = 747;
						additiveExpression(0);
						}
						break;
					case 3:
						{
						_localctx = new RelationalExpressionContext(_parentctx, _parentState);
						PushNewRecursionContext(_localctx, _startState, RULE_relationalExpression);
						State = 748;
						if (!(Precpred(Context, 2))) throw new FailedPredicateException(this, "Precpred(Context, 2)");
						State = 749;
						Match(LeOp);
						State = 750;
						additiveExpression(0);
						}
						break;
					case 4:
						{
						_localctx = new RelationalExpressionContext(_parentctx, _parentState);
						PushNewRecursionContext(_localctx, _startState, RULE_relationalExpression);
						State = 751;
						if (!(Precpred(Context, 1))) throw new FailedPredicateException(this, "Precpred(Context, 1)");
						State = 752;
						Match(GeOp);
						State = 753;
						additiveExpression(0);
						}
						break;
					}
					} 
				}
				State = 758;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,58,Context);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			UnrollRecursionContexts(_parentctx);
		}
		return _localctx;
	}

	public partial class AdditiveExpressionContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public MultiplicativeExpressionContext multiplicativeExpression() {
			return GetRuleContext<MultiplicativeExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public AdditiveExpressionContext additiveExpression() {
			return GetRuleContext<AdditiveExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Plus() { return GetToken(C_GrammarParser.Plus, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Minus() { return GetToken(C_GrammarParser.Minus, 0); }
		public AdditiveExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_additiveExpression; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.EnterAdditiveExpression(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.ExitAdditiveExpression(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IC_GrammarVisitor<TResult> typedVisitor = visitor as IC_GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAdditiveExpression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public AdditiveExpressionContext additiveExpression() {
		return additiveExpression(0);
	}

	private AdditiveExpressionContext additiveExpression(int _p) {
		ParserRuleContext _parentctx = Context;
		int _parentState = State;
		AdditiveExpressionContext _localctx = new AdditiveExpressionContext(Context, _parentState);
		AdditiveExpressionContext _prevctx = _localctx;
		int _startState = 124;
		EnterRecursionRule(_localctx, 124, RULE_additiveExpression, _p);
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			{
			State = 760;
			multiplicativeExpression(0);
			}
			Context.Stop = TokenStream.LT(-1);
			State = 770;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,60,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					if ( ParseListeners!=null )
						TriggerExitRuleEvent();
					_prevctx = _localctx;
					{
					State = 768;
					ErrorHandler.Sync(this);
					switch ( Interpreter.AdaptivePredict(TokenStream,59,Context) ) {
					case 1:
						{
						_localctx = new AdditiveExpressionContext(_parentctx, _parentState);
						PushNewRecursionContext(_localctx, _startState, RULE_additiveExpression);
						State = 762;
						if (!(Precpred(Context, 2))) throw new FailedPredicateException(this, "Precpred(Context, 2)");
						State = 763;
						Match(Plus);
						State = 764;
						multiplicativeExpression(0);
						}
						break;
					case 2:
						{
						_localctx = new AdditiveExpressionContext(_parentctx, _parentState);
						PushNewRecursionContext(_localctx, _startState, RULE_additiveExpression);
						State = 765;
						if (!(Precpred(Context, 1))) throw new FailedPredicateException(this, "Precpred(Context, 1)");
						State = 766;
						Match(Minus);
						State = 767;
						multiplicativeExpression(0);
						}
						break;
					}
					} 
				}
				State = 772;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,60,Context);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			UnrollRecursionContexts(_parentctx);
		}
		return _localctx;
	}

	public partial class MultiplicativeExpressionContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public CastExpressionContext castExpression() {
			return GetRuleContext<CastExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public MultiplicativeExpressionContext multiplicativeExpression() {
			return GetRuleContext<MultiplicativeExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Multiply() { return GetToken(C_GrammarParser.Multiply, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Divide() { return GetToken(C_GrammarParser.Divide, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Mod() { return GetToken(C_GrammarParser.Mod, 0); }
		public MultiplicativeExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_multiplicativeExpression; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.EnterMultiplicativeExpression(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.ExitMultiplicativeExpression(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IC_GrammarVisitor<TResult> typedVisitor = visitor as IC_GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitMultiplicativeExpression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public MultiplicativeExpressionContext multiplicativeExpression() {
		return multiplicativeExpression(0);
	}

	private MultiplicativeExpressionContext multiplicativeExpression(int _p) {
		ParserRuleContext _parentctx = Context;
		int _parentState = State;
		MultiplicativeExpressionContext _localctx = new MultiplicativeExpressionContext(Context, _parentState);
		MultiplicativeExpressionContext _prevctx = _localctx;
		int _startState = 126;
		EnterRecursionRule(_localctx, 126, RULE_multiplicativeExpression, _p);
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			{
			State = 774;
			castExpression();
			}
			Context.Stop = TokenStream.LT(-1);
			State = 787;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,62,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					if ( ParseListeners!=null )
						TriggerExitRuleEvent();
					_prevctx = _localctx;
					{
					State = 785;
					ErrorHandler.Sync(this);
					switch ( Interpreter.AdaptivePredict(TokenStream,61,Context) ) {
					case 1:
						{
						_localctx = new MultiplicativeExpressionContext(_parentctx, _parentState);
						PushNewRecursionContext(_localctx, _startState, RULE_multiplicativeExpression);
						State = 776;
						if (!(Precpred(Context, 3))) throw new FailedPredicateException(this, "Precpred(Context, 3)");
						State = 777;
						Match(Multiply);
						State = 778;
						castExpression();
						}
						break;
					case 2:
						{
						_localctx = new MultiplicativeExpressionContext(_parentctx, _parentState);
						PushNewRecursionContext(_localctx, _startState, RULE_multiplicativeExpression);
						State = 779;
						if (!(Precpred(Context, 2))) throw new FailedPredicateException(this, "Precpred(Context, 2)");
						State = 780;
						Match(Divide);
						State = 781;
						castExpression();
						}
						break;
					case 3:
						{
						_localctx = new MultiplicativeExpressionContext(_parentctx, _parentState);
						PushNewRecursionContext(_localctx, _startState, RULE_multiplicativeExpression);
						State = 782;
						if (!(Precpred(Context, 1))) throw new FailedPredicateException(this, "Precpred(Context, 1)");
						State = 783;
						Match(Mod);
						State = 784;
						castExpression();
						}
						break;
					}
					} 
				}
				State = 789;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,62,Context);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			UnrollRecursionContexts(_parentctx);
		}
		return _localctx;
	}

	public partial class CastExpressionContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public UnaryExpressionContext unaryExpression() {
			return GetRuleContext<UnaryExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LeftParen() { return GetToken(C_GrammarParser.LeftParen, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public TypeNameContext typeName() {
			return GetRuleContext<TypeNameContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RightParen() { return GetToken(C_GrammarParser.RightParen, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public CastExpressionContext castExpression() {
			return GetRuleContext<CastExpressionContext>(0);
		}
		public CastExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_castExpression; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.EnterCastExpression(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.ExitCastExpression(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IC_GrammarVisitor<TResult> typedVisitor = visitor as IC_GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCastExpression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public CastExpressionContext castExpression() {
		CastExpressionContext _localctx = new CastExpressionContext(Context, State);
		EnterRule(_localctx, 128, RULE_castExpression);
		try {
			State = 796;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,63,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 790;
				unaryExpression();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 791;
				Match(LeftParen);
				State = 792;
				typeName();
				State = 793;
				Match(RightParen);
				State = 794;
				castExpression();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class UnaryOperatorContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Ampersand() { return GetToken(C_GrammarParser.Ampersand, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Multiply() { return GetToken(C_GrammarParser.Multiply, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Plus() { return GetToken(C_GrammarParser.Plus, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Minus() { return GetToken(C_GrammarParser.Minus, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Exclamation() { return GetToken(C_GrammarParser.Exclamation, 0); }
		public UnaryOperatorContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_unaryOperator; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.EnterUnaryOperator(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.ExitUnaryOperator(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IC_GrammarVisitor<TResult> typedVisitor = visitor as IC_GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitUnaryOperator(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public UnaryOperatorContext unaryOperator() {
		UnaryOperatorContext _localctx = new UnaryOperatorContext(Context, State);
		EnterRule(_localctx, 130, RULE_unaryOperator);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 798;
			_la = TokenStream.LA(1);
			if ( !((((_la) & ~0x3f) == 0 && ((1L << _la) & 1225893892319084544L) != 0)) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class UnaryExpressionContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public PostfixExpressionContext postfixExpression() {
			return GetRuleContext<PostfixExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode IncOp() { return GetToken(C_GrammarParser.IncOp, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public UnaryExpressionContext unaryExpression() {
			return GetRuleContext<UnaryExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DecOp() { return GetToken(C_GrammarParser.DecOp, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public UnaryOperatorContext unaryOperator() {
			return GetRuleContext<UnaryOperatorContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public CastExpressionContext castExpression() {
			return GetRuleContext<CastExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Sizeof() { return GetToken(C_GrammarParser.Sizeof, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LeftParen() { return GetToken(C_GrammarParser.LeftParen, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public TypeNameContext typeName() {
			return GetRuleContext<TypeNameContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RightParen() { return GetToken(C_GrammarParser.RightParen, 0); }
		public UnaryExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_unaryExpression; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.EnterUnaryExpression(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.ExitUnaryExpression(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IC_GrammarVisitor<TResult> typedVisitor = visitor as IC_GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitUnaryExpression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public UnaryExpressionContext unaryExpression() {
		UnaryExpressionContext _localctx = new UnaryExpressionContext(Context, State);
		EnterRule(_localctx, 132, RULE_unaryExpression);
		try {
			State = 815;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,64,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 800;
				postfixExpression(0);
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 801;
				Match(IncOp);
				State = 802;
				unaryExpression();
				}
				break;
			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 803;
				Match(DecOp);
				State = 804;
				unaryExpression();
				}
				break;
			case 4:
				EnterOuterAlt(_localctx, 4);
				{
				State = 805;
				unaryOperator();
				State = 806;
				castExpression();
				}
				break;
			case 5:
				EnterOuterAlt(_localctx, 5);
				{
				State = 808;
				Match(Sizeof);
				State = 809;
				unaryExpression();
				}
				break;
			case 6:
				EnterOuterAlt(_localctx, 6);
				{
				State = 810;
				Match(Sizeof);
				State = 811;
				Match(LeftParen);
				State = 812;
				typeName();
				State = 813;
				Match(RightParen);
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ArgumentExpressionListContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public AssignmentExpressionContext assignmentExpression() {
			return GetRuleContext<AssignmentExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ArgumentExpressionListContext argumentExpressionList() {
			return GetRuleContext<ArgumentExpressionListContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Comma() { return GetToken(C_GrammarParser.Comma, 0); }
		public ArgumentExpressionListContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_argumentExpressionList; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.EnterArgumentExpressionList(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.ExitArgumentExpressionList(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IC_GrammarVisitor<TResult> typedVisitor = visitor as IC_GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitArgumentExpressionList(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ArgumentExpressionListContext argumentExpressionList() {
		return argumentExpressionList(0);
	}

	private ArgumentExpressionListContext argumentExpressionList(int _p) {
		ParserRuleContext _parentctx = Context;
		int _parentState = State;
		ArgumentExpressionListContext _localctx = new ArgumentExpressionListContext(Context, _parentState);
		ArgumentExpressionListContext _prevctx = _localctx;
		int _startState = 134;
		EnterRecursionRule(_localctx, 134, RULE_argumentExpressionList, _p);
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			{
			State = 818;
			assignmentExpression();
			}
			Context.Stop = TokenStream.LT(-1);
			State = 825;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,65,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					if ( ParseListeners!=null )
						TriggerExitRuleEvent();
					_prevctx = _localctx;
					{
					{
					_localctx = new ArgumentExpressionListContext(_parentctx, _parentState);
					PushNewRecursionContext(_localctx, _startState, RULE_argumentExpressionList);
					State = 820;
					if (!(Precpred(Context, 1))) throw new FailedPredicateException(this, "Precpred(Context, 1)");
					State = 821;
					Match(Comma);
					State = 822;
					assignmentExpression();
					}
					} 
				}
				State = 827;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,65,Context);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			UnrollRecursionContexts(_parentctx);
		}
		return _localctx;
	}

	public partial class PostfixExpressionContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public PrimaryExpressionContext primaryExpression() {
			return GetRuleContext<PrimaryExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public PostfixExpressionContext postfixExpression() {
			return GetRuleContext<PostfixExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LeftBracket() { return GetToken(C_GrammarParser.LeftBracket, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RightBracket() { return GetToken(C_GrammarParser.RightBracket, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LeftParen() { return GetToken(C_GrammarParser.LeftParen, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RightParen() { return GetToken(C_GrammarParser.RightParen, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ArgumentExpressionListContext argumentExpressionList() {
			return GetRuleContext<ArgumentExpressionListContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Dot() { return GetToken(C_GrammarParser.Dot, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Identifier() { return GetToken(C_GrammarParser.Identifier, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Arrow() { return GetToken(C_GrammarParser.Arrow, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode IncOp() { return GetToken(C_GrammarParser.IncOp, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DecOp() { return GetToken(C_GrammarParser.DecOp, 0); }
		public PostfixExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_postfixExpression; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.EnterPostfixExpression(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.ExitPostfixExpression(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IC_GrammarVisitor<TResult> typedVisitor = visitor as IC_GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitPostfixExpression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public PostfixExpressionContext postfixExpression() {
		return postfixExpression(0);
	}

	private PostfixExpressionContext postfixExpression(int _p) {
		ParserRuleContext _parentctx = Context;
		int _parentState = State;
		PostfixExpressionContext _localctx = new PostfixExpressionContext(Context, _parentState);
		PostfixExpressionContext _prevctx = _localctx;
		int _startState = 136;
		EnterRecursionRule(_localctx, 136, RULE_postfixExpression, _p);
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			{
			State = 829;
			primaryExpression();
			}
			Context.Stop = TokenStream.LT(-1);
			State = 856;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,67,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					if ( ParseListeners!=null )
						TriggerExitRuleEvent();
					_prevctx = _localctx;
					{
					State = 854;
					ErrorHandler.Sync(this);
					switch ( Interpreter.AdaptivePredict(TokenStream,66,Context) ) {
					case 1:
						{
						_localctx = new PostfixExpressionContext(_parentctx, _parentState);
						PushNewRecursionContext(_localctx, _startState, RULE_postfixExpression);
						State = 831;
						if (!(Precpred(Context, 7))) throw new FailedPredicateException(this, "Precpred(Context, 7)");
						State = 832;
						Match(LeftBracket);
						State = 833;
						expression(0);
						State = 834;
						Match(RightBracket);
						}
						break;
					case 2:
						{
						_localctx = new PostfixExpressionContext(_parentctx, _parentState);
						PushNewRecursionContext(_localctx, _startState, RULE_postfixExpression);
						State = 836;
						if (!(Precpred(Context, 6))) throw new FailedPredicateException(this, "Precpred(Context, 6)");
						State = 837;
						Match(LeftParen);
						State = 838;
						Match(RightParen);
						}
						break;
					case 3:
						{
						_localctx = new PostfixExpressionContext(_parentctx, _parentState);
						PushNewRecursionContext(_localctx, _startState, RULE_postfixExpression);
						State = 839;
						if (!(Precpred(Context, 5))) throw new FailedPredicateException(this, "Precpred(Context, 5)");
						State = 840;
						Match(LeftParen);
						State = 841;
						argumentExpressionList(0);
						State = 842;
						Match(RightParen);
						}
						break;
					case 4:
						{
						_localctx = new PostfixExpressionContext(_parentctx, _parentState);
						PushNewRecursionContext(_localctx, _startState, RULE_postfixExpression);
						State = 844;
						if (!(Precpred(Context, 4))) throw new FailedPredicateException(this, "Precpred(Context, 4)");
						State = 845;
						Match(Dot);
						State = 846;
						Match(Identifier);
						}
						break;
					case 5:
						{
						_localctx = new PostfixExpressionContext(_parentctx, _parentState);
						PushNewRecursionContext(_localctx, _startState, RULE_postfixExpression);
						State = 847;
						if (!(Precpred(Context, 3))) throw new FailedPredicateException(this, "Precpred(Context, 3)");
						State = 848;
						Match(Arrow);
						State = 849;
						Match(Identifier);
						}
						break;
					case 6:
						{
						_localctx = new PostfixExpressionContext(_parentctx, _parentState);
						PushNewRecursionContext(_localctx, _startState, RULE_postfixExpression);
						State = 850;
						if (!(Precpred(Context, 2))) throw new FailedPredicateException(this, "Precpred(Context, 2)");
						State = 851;
						Match(IncOp);
						}
						break;
					case 7:
						{
						_localctx = new PostfixExpressionContext(_parentctx, _parentState);
						PushNewRecursionContext(_localctx, _startState, RULE_postfixExpression);
						State = 852;
						if (!(Precpred(Context, 1))) throw new FailedPredicateException(this, "Precpred(Context, 1)");
						State = 853;
						Match(DecOp);
						}
						break;
					}
					} 
				}
				State = 858;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,67,Context);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			UnrollRecursionContexts(_parentctx);
		}
		return _localctx;
	}

	public partial class PrimaryExpressionContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Identifier() { return GetToken(C_GrammarParser.Identifier, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Constant() { return GetToken(C_GrammarParser.Constant, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode StringLiteral() { return GetToken(C_GrammarParser.StringLiteral, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LeftParen() { return GetToken(C_GrammarParser.LeftParen, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RightParen() { return GetToken(C_GrammarParser.RightParen, 0); }
		public PrimaryExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_primaryExpression; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.EnterPrimaryExpression(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IC_GrammarListener typedListener = listener as IC_GrammarListener;
			if (typedListener != null) typedListener.ExitPrimaryExpression(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IC_GrammarVisitor<TResult> typedVisitor = visitor as IC_GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitPrimaryExpression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public PrimaryExpressionContext primaryExpression() {
		PrimaryExpressionContext _localctx = new PrimaryExpressionContext(Context, State);
		EnterRule(_localctx, 138, RULE_primaryExpression);
		try {
			State = 866;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case Identifier:
				EnterOuterAlt(_localctx, 1);
				{
				State = 859;
				Match(Identifier);
				}
				break;
			case Constant:
				EnterOuterAlt(_localctx, 2);
				{
				State = 860;
				Match(Constant);
				}
				break;
			case StringLiteral:
				EnterOuterAlt(_localctx, 3);
				{
				State = 861;
				Match(StringLiteral);
				}
				break;
			case LeftParen:
				EnterOuterAlt(_localctx, 4);
				{
				State = 862;
				Match(LeftParen);
				State = 863;
				expression(0);
				State = 864;
				Match(RightParen);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public override bool Sempred(RuleContext _localctx, int ruleIndex, int predIndex) {
		switch (ruleIndex) {
		case 1: return translationUnit_sempred((TranslationUnitContext)_localctx, predIndex);
		case 6: return elseIfBlock_sempred((ElseIfBlockContext)_localctx, predIndex);
		case 21: return statementList_sempred((StatementListContext)_localctx, predIndex);
		case 22: return declarationList_sempred((DeclarationListContext)_localctx, predIndex);
		case 24: return blockItemList_sempred((BlockItemListContext)_localctx, predIndex);
		case 28: return initializerList_sempred((InitializerListContext)_localctx, predIndex);
		case 30: return directAbstractDeclarator_sempred((DirectAbstractDeclaratorContext)_localctx, predIndex);
		case 32: return identifierList_sempred((IdentifierListContext)_localctx, predIndex);
		case 34: return parameterList_sempred((ParameterListContext)_localctx, predIndex);
		case 35: return typeQualifierList_sempred((TypeQualifierListContext)_localctx, predIndex);
		case 37: return directDeclarator_sempred((DirectDeclaratorContext)_localctx, predIndex);
		case 41: return structDeclarationList_sempred((StructDeclarationListContext)_localctx, predIndex);
		case 43: return structDeclaratorList_sempred((StructDeclaratorListContext)_localctx, predIndex);
		case 50: return initDeclaratorList_sempred((InitDeclaratorListContext)_localctx, predIndex);
		case 54: return expression_sempred((ExpressionContext)_localctx, predIndex);
		case 58: return logicalOrExpression_sempred((LogicalOrExpressionContext)_localctx, predIndex);
		case 59: return logicalAndExpression_sempred((LogicalAndExpressionContext)_localctx, predIndex);
		case 60: return equalityExpression_sempred((EqualityExpressionContext)_localctx, predIndex);
		case 61: return relationalExpression_sempred((RelationalExpressionContext)_localctx, predIndex);
		case 62: return additiveExpression_sempred((AdditiveExpressionContext)_localctx, predIndex);
		case 63: return multiplicativeExpression_sempred((MultiplicativeExpressionContext)_localctx, predIndex);
		case 67: return argumentExpressionList_sempred((ArgumentExpressionListContext)_localctx, predIndex);
		case 68: return postfixExpression_sempred((PostfixExpressionContext)_localctx, predIndex);
		}
		return true;
	}
	private bool translationUnit_sempred(TranslationUnitContext _localctx, int predIndex) {
		switch (predIndex) {
		case 0: return Precpred(Context, 2);
		case 1: return Precpred(Context, 1);
		}
		return true;
	}
	private bool elseIfBlock_sempred(ElseIfBlockContext _localctx, int predIndex) {
		switch (predIndex) {
		case 2: return Precpred(Context, 1);
		}
		return true;
	}
	private bool statementList_sempred(StatementListContext _localctx, int predIndex) {
		switch (predIndex) {
		case 3: return Precpred(Context, 1);
		}
		return true;
	}
	private bool declarationList_sempred(DeclarationListContext _localctx, int predIndex) {
		switch (predIndex) {
		case 4: return Precpred(Context, 1);
		}
		return true;
	}
	private bool blockItemList_sempred(BlockItemListContext _localctx, int predIndex) {
		switch (predIndex) {
		case 5: return Precpred(Context, 1);
		}
		return true;
	}
	private bool initializerList_sempred(InitializerListContext _localctx, int predIndex) {
		switch (predIndex) {
		case 6: return Precpred(Context, 1);
		}
		return true;
	}
	private bool directAbstractDeclarator_sempred(DirectAbstractDeclaratorContext _localctx, int predIndex) {
		switch (predIndex) {
		case 7: return Precpred(Context, 6);
		case 8: return Precpred(Context, 5);
		case 9: return Precpred(Context, 2);
		case 10: return Precpred(Context, 1);
		}
		return true;
	}
	private bool identifierList_sempred(IdentifierListContext _localctx, int predIndex) {
		switch (predIndex) {
		case 11: return Precpred(Context, 1);
		}
		return true;
	}
	private bool parameterList_sempred(ParameterListContext _localctx, int predIndex) {
		switch (predIndex) {
		case 12: return Precpred(Context, 1);
		}
		return true;
	}
	private bool typeQualifierList_sempred(TypeQualifierListContext _localctx, int predIndex) {
		switch (predIndex) {
		case 13: return Precpred(Context, 1);
		}
		return true;
	}
	private bool directDeclarator_sempred(DirectDeclaratorContext _localctx, int predIndex) {
		switch (predIndex) {
		case 14: return Precpred(Context, 5);
		case 15: return Precpred(Context, 4);
		case 16: return Precpred(Context, 3);
		case 17: return Precpred(Context, 2);
		case 18: return Precpred(Context, 1);
		}
		return true;
	}
	private bool structDeclarationList_sempred(StructDeclarationListContext _localctx, int predIndex) {
		switch (predIndex) {
		case 19: return Precpred(Context, 1);
		}
		return true;
	}
	private bool structDeclaratorList_sempred(StructDeclaratorListContext _localctx, int predIndex) {
		switch (predIndex) {
		case 20: return Precpred(Context, 1);
		}
		return true;
	}
	private bool initDeclaratorList_sempred(InitDeclaratorListContext _localctx, int predIndex) {
		switch (predIndex) {
		case 21: return Precpred(Context, 1);
		}
		return true;
	}
	private bool expression_sempred(ExpressionContext _localctx, int predIndex) {
		switch (predIndex) {
		case 22: return Precpred(Context, 1);
		}
		return true;
	}
	private bool logicalOrExpression_sempred(LogicalOrExpressionContext _localctx, int predIndex) {
		switch (predIndex) {
		case 23: return Precpred(Context, 1);
		}
		return true;
	}
	private bool logicalAndExpression_sempred(LogicalAndExpressionContext _localctx, int predIndex) {
		switch (predIndex) {
		case 24: return Precpred(Context, 1);
		}
		return true;
	}
	private bool equalityExpression_sempred(EqualityExpressionContext _localctx, int predIndex) {
		switch (predIndex) {
		case 25: return Precpred(Context, 2);
		case 26: return Precpred(Context, 1);
		}
		return true;
	}
	private bool relationalExpression_sempred(RelationalExpressionContext _localctx, int predIndex) {
		switch (predIndex) {
		case 27: return Precpred(Context, 4);
		case 28: return Precpred(Context, 3);
		case 29: return Precpred(Context, 2);
		case 30: return Precpred(Context, 1);
		}
		return true;
	}
	private bool additiveExpression_sempred(AdditiveExpressionContext _localctx, int predIndex) {
		switch (predIndex) {
		case 31: return Precpred(Context, 2);
		case 32: return Precpred(Context, 1);
		}
		return true;
	}
	private bool multiplicativeExpression_sempred(MultiplicativeExpressionContext _localctx, int predIndex) {
		switch (predIndex) {
		case 33: return Precpred(Context, 3);
		case 34: return Precpred(Context, 2);
		case 35: return Precpred(Context, 1);
		}
		return true;
	}
	private bool argumentExpressionList_sempred(ArgumentExpressionListContext _localctx, int predIndex) {
		switch (predIndex) {
		case 36: return Precpred(Context, 1);
		}
		return true;
	}
	private bool postfixExpression_sempred(PostfixExpressionContext _localctx, int predIndex) {
		switch (predIndex) {
		case 37: return Precpred(Context, 7);
		case 38: return Precpred(Context, 6);
		case 39: return Precpred(Context, 5);
		case 40: return Precpred(Context, 4);
		case 41: return Precpred(Context, 3);
		case 42: return Precpred(Context, 2);
		case 43: return Precpred(Context, 1);
		}
		return true;
	}

	private static int[] _serializedATN = {
		4,1,82,869,2,0,7,0,2,1,7,1,2,2,7,2,2,3,7,3,2,4,7,4,2,5,7,5,2,6,7,6,2,7,
		7,7,2,8,7,8,2,9,7,9,2,10,7,10,2,11,7,11,2,12,7,12,2,13,7,13,2,14,7,14,
		2,15,7,15,2,16,7,16,2,17,7,17,2,18,7,18,2,19,7,19,2,20,7,20,2,21,7,21,
		2,22,7,22,2,23,7,23,2,24,7,24,2,25,7,25,2,26,7,26,2,27,7,27,2,28,7,28,
		2,29,7,29,2,30,7,30,2,31,7,31,2,32,7,32,2,33,7,33,2,34,7,34,2,35,7,35,
		2,36,7,36,2,37,7,37,2,38,7,38,2,39,7,39,2,40,7,40,2,41,7,41,2,42,7,42,
		2,43,7,43,2,44,7,44,2,45,7,45,2,46,7,46,2,47,7,47,2,48,7,48,2,49,7,49,
		2,50,7,50,2,51,7,51,2,52,7,52,2,53,7,53,2,54,7,54,2,55,7,55,2,56,7,56,
		2,57,7,57,2,58,7,58,2,59,7,59,2,60,7,60,2,61,7,61,2,62,7,62,2,63,7,63,
		2,64,7,64,2,65,7,65,2,66,7,66,2,67,7,67,2,68,7,68,2,69,7,69,1,0,3,0,142,
		8,0,1,0,1,0,1,1,1,1,1,1,3,1,149,8,1,1,1,1,1,1,1,1,1,5,1,155,8,1,10,1,12,
		1,158,9,1,1,2,1,2,1,2,1,2,1,2,1,2,3,2,166,8,2,1,3,1,3,1,3,1,3,1,3,1,3,
		3,3,174,8,3,1,4,1,4,1,4,1,4,1,5,1,5,3,5,182,8,5,1,5,3,5,185,8,5,1,6,1,
		6,1,6,1,6,1,6,5,6,192,8,6,10,6,12,6,195,9,6,1,7,1,7,1,7,1,7,1,8,1,8,1,
		8,1,9,1,9,1,9,1,9,1,10,1,10,1,10,1,11,1,11,1,11,1,11,1,11,1,12,1,12,1,
		12,1,12,1,12,1,13,1,13,1,13,1,13,1,13,1,14,1,14,1,15,1,15,3,15,230,8,15,
		1,16,1,16,1,16,1,16,1,16,1,16,1,16,1,16,1,16,1,16,1,16,1,16,1,16,1,16,
		1,16,1,16,3,16,248,8,16,1,17,1,17,1,17,1,17,1,17,1,17,1,17,1,17,1,17,1,
		17,3,17,260,8,17,1,18,1,18,1,18,1,18,1,18,1,18,1,18,1,18,1,18,1,18,1,18,
		1,18,1,18,1,18,1,18,1,18,1,18,1,18,3,18,280,8,18,1,18,1,18,1,18,1,18,1,
		18,1,18,1,18,1,18,3,18,290,8,18,1,18,1,18,1,18,1,18,1,18,3,18,297,8,18,
		1,19,1,19,1,19,1,19,1,19,1,19,1,19,1,19,1,19,1,19,1,19,1,19,1,19,1,19,
		1,19,1,19,1,19,1,19,1,19,1,19,3,19,319,8,19,1,20,1,20,1,20,1,20,3,20,325,
		8,20,1,21,1,21,1,21,1,21,1,21,5,21,332,8,21,10,21,12,21,335,9,21,1,22,
		1,22,1,22,1,22,1,22,5,22,342,8,22,10,22,12,22,345,9,22,1,23,1,23,3,23,
		349,8,23,1,23,1,23,1,24,1,24,1,24,1,24,1,24,5,24,358,8,24,10,24,12,24,
		361,9,24,1,25,1,25,1,25,3,25,366,8,25,1,26,1,26,1,26,1,26,1,26,1,26,1,
		26,1,26,1,26,1,26,1,26,3,26,379,8,26,1,27,1,27,1,27,1,27,1,27,1,27,3,27,
		387,8,27,1,28,1,28,1,28,1,28,1,28,1,28,5,28,395,8,28,10,28,12,28,398,9,
		28,1,29,1,29,1,29,1,29,1,29,1,29,1,29,1,29,1,29,1,29,3,29,410,8,29,1,30,
		1,30,1,30,1,30,1,30,1,30,1,30,1,30,1,30,1,30,1,30,1,30,1,30,1,30,1,30,
		1,30,1,30,3,30,429,8,30,1,30,1,30,1,30,1,30,1,30,1,30,1,30,1,30,1,30,1,
		30,1,30,1,30,1,30,1,30,1,30,1,30,5,30,447,8,30,10,30,12,30,450,9,30,1,
		31,1,31,1,31,1,31,1,31,3,31,457,8,31,1,32,1,32,1,32,1,32,1,32,1,32,5,32,
		465,8,32,10,32,12,32,468,9,32,1,33,1,33,1,33,1,33,1,33,1,33,1,33,3,33,
		477,8,33,1,34,1,34,1,34,1,34,1,34,1,34,5,34,485,8,34,10,34,12,34,488,9,
		34,1,35,1,35,1,35,1,35,1,35,5,35,495,8,35,10,35,12,35,498,9,35,1,36,1,
		36,1,36,1,36,1,36,1,36,1,36,1,36,1,36,3,36,509,8,36,1,37,1,37,1,37,1,37,
		1,37,1,37,3,37,517,8,37,1,37,1,37,1,37,1,37,1,37,1,37,1,37,1,37,1,37,1,
		37,1,37,1,37,1,37,1,37,1,37,1,37,1,37,1,37,1,37,1,37,1,37,5,37,540,8,37,
		10,37,12,37,543,9,37,1,38,1,38,1,38,1,38,3,38,549,8,38,1,39,1,39,1,39,
		1,39,1,39,1,39,1,39,3,39,558,8,39,1,40,1,40,1,40,1,40,1,40,1,40,1,40,1,
		40,1,40,1,40,1,40,1,40,1,40,3,40,573,8,40,1,41,1,41,1,41,1,41,1,41,5,41,
		580,8,41,10,41,12,41,583,9,41,1,42,1,42,1,42,1,42,1,43,1,43,1,43,1,43,
		1,43,1,43,5,43,595,8,43,10,43,12,43,598,9,43,1,44,1,44,1,44,1,44,1,44,
		1,44,1,44,3,44,607,8,44,1,45,1,45,1,46,1,46,1,46,1,46,1,46,1,46,1,46,1,
		46,1,46,1,46,1,46,1,46,3,46,623,8,46,1,47,1,47,1,48,1,48,1,48,1,48,3,48,
		631,8,48,1,49,1,49,1,49,1,49,1,49,1,49,1,49,1,49,1,49,1,49,1,49,3,49,644,
		8,49,1,50,1,50,1,50,1,50,1,50,1,50,5,50,652,8,50,10,50,12,50,655,9,50,
		1,51,1,51,1,51,1,51,1,51,3,51,662,8,51,1,52,1,52,1,52,1,52,1,52,1,52,1,
		52,3,52,671,8,52,1,53,1,53,1,54,1,54,1,54,1,54,1,54,1,54,5,54,681,8,54,
		10,54,12,54,684,9,54,1,55,1,55,1,56,1,56,1,56,1,56,1,56,3,56,693,8,56,
		1,57,1,57,1,57,1,57,1,57,1,57,1,57,3,57,702,8,57,1,58,1,58,1,58,1,58,1,
		58,1,58,5,58,710,8,58,10,58,12,58,713,9,58,1,59,1,59,1,59,1,59,1,59,1,
		59,5,59,721,8,59,10,59,12,59,724,9,59,1,60,1,60,1,60,1,60,1,60,1,60,1,
		60,1,60,1,60,5,60,735,8,60,10,60,12,60,738,9,60,1,61,1,61,1,61,1,61,1,
		61,1,61,1,61,1,61,1,61,1,61,1,61,1,61,1,61,1,61,1,61,5,61,755,8,61,10,
		61,12,61,758,9,61,1,62,1,62,1,62,1,62,1,62,1,62,1,62,1,62,1,62,5,62,769,
		8,62,10,62,12,62,772,9,62,1,63,1,63,1,63,1,63,1,63,1,63,1,63,1,63,1,63,
		1,63,1,63,1,63,5,63,786,8,63,10,63,12,63,789,9,63,1,64,1,64,1,64,1,64,
		1,64,1,64,3,64,797,8,64,1,65,1,65,1,66,1,66,1,66,1,66,1,66,1,66,1,66,1,
		66,1,66,1,66,1,66,1,66,1,66,1,66,1,66,3,66,816,8,66,1,67,1,67,1,67,1,67,
		1,67,1,67,5,67,824,8,67,10,67,12,67,827,9,67,1,68,1,68,1,68,1,68,1,68,
		1,68,1,68,1,68,1,68,1,68,1,68,1,68,1,68,1,68,1,68,1,68,1,68,1,68,1,68,
		1,68,1,68,1,68,1,68,1,68,1,68,1,68,5,68,855,8,68,10,68,12,68,858,9,68,
		1,69,1,69,1,69,1,69,1,69,1,69,1,69,3,69,867,8,69,1,69,0,23,2,12,42,44,
		48,56,60,64,68,70,74,82,86,100,108,116,118,120,122,124,126,134,136,70,
		0,2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,
		50,52,54,56,58,60,62,64,66,68,70,72,74,76,78,80,82,84,86,88,90,92,94,96,
		98,100,102,104,106,108,110,112,114,116,118,120,122,124,126,128,130,132,
		134,136,138,0,3,1,0,12,16,2,0,43,43,69,73,4,0,46,46,48,49,56,56,60,60,
		929,0,141,1,0,0,0,2,148,1,0,0,0,4,165,1,0,0,0,6,173,1,0,0,0,8,175,1,0,
		0,0,10,179,1,0,0,0,12,186,1,0,0,0,14,196,1,0,0,0,16,200,1,0,0,0,18,203,
		1,0,0,0,20,207,1,0,0,0,22,210,1,0,0,0,24,215,1,0,0,0,26,220,1,0,0,0,28,
		225,1,0,0,0,30,229,1,0,0,0,32,247,1,0,0,0,34,259,1,0,0,0,36,296,1,0,0,
		0,38,318,1,0,0,0,40,324,1,0,0,0,42,326,1,0,0,0,44,336,1,0,0,0,46,346,1,
		0,0,0,48,352,1,0,0,0,50,365,1,0,0,0,52,378,1,0,0,0,54,386,1,0,0,0,56,388,
		1,0,0,0,58,409,1,0,0,0,60,428,1,0,0,0,62,456,1,0,0,0,64,458,1,0,0,0,66,
		476,1,0,0,0,68,478,1,0,0,0,70,489,1,0,0,0,72,508,1,0,0,0,74,516,1,0,0,
		0,76,548,1,0,0,0,78,557,1,0,0,0,80,572,1,0,0,0,82,574,1,0,0,0,84,584,1,
		0,0,0,86,588,1,0,0,0,88,606,1,0,0,0,90,608,1,0,0,0,92,622,1,0,0,0,94,624,
		1,0,0,0,96,630,1,0,0,0,98,643,1,0,0,0,100,645,1,0,0,0,102,661,1,0,0,0,
		104,670,1,0,0,0,106,672,1,0,0,0,108,674,1,0,0,0,110,685,1,0,0,0,112,692,
		1,0,0,0,114,701,1,0,0,0,116,703,1,0,0,0,118,714,1,0,0,0,120,725,1,0,0,
		0,122,739,1,0,0,0,124,759,1,0,0,0,126,773,1,0,0,0,128,796,1,0,0,0,130,
		798,1,0,0,0,132,815,1,0,0,0,134,817,1,0,0,0,136,828,1,0,0,0,138,866,1,
		0,0,0,140,142,3,2,1,0,141,140,1,0,0,0,141,142,1,0,0,0,142,143,1,0,0,0,
		143,144,5,0,0,1,144,1,1,0,0,0,145,146,6,1,-1,0,146,149,3,4,2,0,147,149,
		3,30,15,0,148,145,1,0,0,0,148,147,1,0,0,0,149,156,1,0,0,0,150,151,10,2,
		0,0,151,155,3,4,2,0,152,153,10,1,0,0,153,155,3,30,15,0,154,150,1,0,0,0,
		154,152,1,0,0,0,155,158,1,0,0,0,156,154,1,0,0,0,156,157,1,0,0,0,157,3,
		1,0,0,0,158,156,1,0,0,0,159,166,3,26,13,0,160,166,3,18,9,0,161,166,3,20,
		10,0,162,166,3,6,3,0,163,166,3,22,11,0,164,166,3,24,12,0,165,159,1,0,0,
		0,165,160,1,0,0,0,165,161,1,0,0,0,165,162,1,0,0,0,165,163,1,0,0,0,165,
		164,1,0,0,0,166,5,1,0,0,0,167,168,3,8,4,0,168,169,5,4,0,0,169,174,1,0,
		0,0,170,171,3,10,5,0,171,172,5,4,0,0,172,174,1,0,0,0,173,167,1,0,0,0,173,
		170,1,0,0,0,174,7,1,0,0,0,175,176,5,7,0,0,176,177,3,108,54,0,177,178,3,
		30,15,0,178,9,1,0,0,0,179,181,3,8,4,0,180,182,3,12,6,0,181,180,1,0,0,0,
		181,182,1,0,0,0,182,184,1,0,0,0,183,185,3,16,8,0,184,183,1,0,0,0,184,185,
		1,0,0,0,185,11,1,0,0,0,186,187,6,6,-1,0,187,188,3,14,7,0,188,193,1,0,0,
		0,189,190,10,1,0,0,190,192,3,14,7,0,191,189,1,0,0,0,192,195,1,0,0,0,193,
		191,1,0,0,0,193,194,1,0,0,0,194,13,1,0,0,0,195,193,1,0,0,0,196,197,5,8,
		0,0,197,198,3,108,54,0,198,199,3,30,15,0,199,15,1,0,0,0,200,201,5,9,0,
		0,201,202,3,30,15,0,202,17,1,0,0,0,203,204,5,2,0,0,204,205,5,74,0,0,205,
		206,5,75,0,0,206,19,1,0,0,0,207,208,5,5,0,0,208,209,5,74,0,0,209,21,1,
		0,0,0,210,211,5,6,0,0,211,212,5,74,0,0,212,213,3,30,15,0,213,214,5,4,0,
		0,214,23,1,0,0,0,215,216,5,3,0,0,216,217,5,74,0,0,217,218,3,30,15,0,218,
		219,5,4,0,0,219,25,1,0,0,0,220,221,5,1,0,0,221,222,5,39,0,0,222,223,3,
		28,14,0,223,224,5,40,0,0,224,27,1,0,0,0,225,226,5,78,0,0,226,29,1,0,0,
		0,227,230,3,32,16,0,228,230,3,104,52,0,229,227,1,0,0,0,229,228,1,0,0,0,
		230,31,1,0,0,0,231,232,3,98,49,0,232,233,3,76,38,0,233,234,3,44,22,0,234,
		235,3,46,23,0,235,248,1,0,0,0,236,237,3,98,49,0,237,238,3,76,38,0,238,
		239,3,46,23,0,239,248,1,0,0,0,240,241,3,76,38,0,241,242,3,44,22,0,242,
		243,3,46,23,0,243,248,1,0,0,0,244,245,3,76,38,0,245,246,3,46,23,0,246,
		248,1,0,0,0,247,231,1,0,0,0,247,236,1,0,0,0,247,240,1,0,0,0,247,244,1,
		0,0,0,248,33,1,0,0,0,249,250,5,36,0,0,250,260,5,41,0,0,251,252,5,37,0,
		0,252,260,5,41,0,0,253,254,5,28,0,0,254,260,5,41,0,0,255,256,5,28,0,0,
		256,257,3,108,54,0,257,258,5,41,0,0,258,260,1,0,0,0,259,249,1,0,0,0,259,
		251,1,0,0,0,259,253,1,0,0,0,259,255,1,0,0,0,260,35,1,0,0,0,261,262,5,33,
		0,0,262,263,5,50,0,0,263,264,3,108,54,0,264,265,5,51,0,0,265,266,3,54,
		27,0,266,297,1,0,0,0,267,268,5,38,0,0,268,269,3,54,27,0,269,270,5,33,0,
		0,270,271,5,50,0,0,271,272,3,108,54,0,272,273,5,51,0,0,273,274,5,41,0,
		0,274,297,1,0,0,0,275,276,5,32,0,0,276,279,5,50,0,0,277,280,3,40,20,0,
		278,280,3,104,52,0,279,277,1,0,0,0,279,278,1,0,0,0,280,281,1,0,0,0,281,
		282,3,40,20,0,282,283,5,51,0,0,283,284,3,54,27,0,284,297,1,0,0,0,285,286,
		5,32,0,0,286,289,5,50,0,0,287,290,3,40,20,0,288,290,3,104,52,0,289,287,
		1,0,0,0,289,288,1,0,0,0,290,291,1,0,0,0,291,292,3,40,20,0,292,293,3,108,
		54,0,293,294,5,51,0,0,294,295,3,54,27,0,295,297,1,0,0,0,296,261,1,0,0,
		0,296,267,1,0,0,0,296,275,1,0,0,0,296,285,1,0,0,0,297,37,1,0,0,0,298,299,
		5,29,0,0,299,300,5,50,0,0,300,301,3,108,54,0,301,302,5,51,0,0,302,303,
		3,54,27,0,303,319,1,0,0,0,304,305,5,29,0,0,305,306,5,50,0,0,306,307,3,
		108,54,0,307,308,5,51,0,0,308,309,3,54,27,0,309,310,5,30,0,0,310,311,3,
		54,27,0,311,319,1,0,0,0,312,313,5,31,0,0,313,314,5,50,0,0,314,315,3,108,
		54,0,315,316,5,51,0,0,316,317,3,54,27,0,317,319,1,0,0,0,318,298,1,0,0,
		0,318,304,1,0,0,0,318,312,1,0,0,0,319,39,1,0,0,0,320,325,5,41,0,0,321,
		322,3,108,54,0,322,323,5,41,0,0,323,325,1,0,0,0,324,320,1,0,0,0,324,321,
		1,0,0,0,325,41,1,0,0,0,326,327,6,21,-1,0,327,328,3,54,27,0,328,333,1,0,
		0,0,329,330,10,1,0,0,330,332,3,54,27,0,331,329,1,0,0,0,332,335,1,0,0,0,
		333,331,1,0,0,0,333,334,1,0,0,0,334,43,1,0,0,0,335,333,1,0,0,0,336,337,
		6,22,-1,0,337,338,3,104,52,0,338,343,1,0,0,0,339,340,10,1,0,0,340,342,
		3,104,52,0,341,339,1,0,0,0,342,345,1,0,0,0,343,341,1,0,0,0,343,344,1,0,
		0,0,344,45,1,0,0,0,345,343,1,0,0,0,346,348,5,52,0,0,347,349,3,48,24,0,
		348,347,1,0,0,0,348,349,1,0,0,0,349,350,1,0,0,0,350,351,5,53,0,0,351,47,
		1,0,0,0,352,353,6,24,-1,0,353,354,3,50,25,0,354,359,1,0,0,0,355,356,10,
		1,0,0,356,358,3,50,25,0,357,355,1,0,0,0,358,361,1,0,0,0,359,357,1,0,0,
		0,359,360,1,0,0,0,360,49,1,0,0,0,361,359,1,0,0,0,362,366,3,42,21,0,363,
		366,3,44,22,0,364,366,3,4,2,0,365,362,1,0,0,0,365,363,1,0,0,0,365,364,
		1,0,0,0,366,51,1,0,0,0,367,368,5,74,0,0,368,369,5,45,0,0,369,379,3,54,
		27,0,370,371,5,34,0,0,371,372,3,106,53,0,372,373,5,45,0,0,373,374,3,54,
		27,0,374,379,1,0,0,0,375,376,5,35,0,0,376,377,5,45,0,0,377,379,3,54,27,
		0,378,367,1,0,0,0,378,370,1,0,0,0,378,375,1,0,0,0,379,53,1,0,0,0,380,387,
		3,52,26,0,381,387,3,46,23,0,382,387,3,40,20,0,383,387,3,38,19,0,384,387,
		3,36,18,0,385,387,3,34,17,0,386,380,1,0,0,0,386,381,1,0,0,0,386,382,1,
		0,0,0,386,383,1,0,0,0,386,384,1,0,0,0,386,385,1,0,0,0,387,55,1,0,0,0,388,
		389,6,28,-1,0,389,390,3,58,29,0,390,396,1,0,0,0,391,392,10,1,0,0,392,393,
		5,42,0,0,393,395,3,58,29,0,394,391,1,0,0,0,395,398,1,0,0,0,396,394,1,0,
		0,0,396,397,1,0,0,0,397,57,1,0,0,0,398,396,1,0,0,0,399,410,3,112,56,0,
		400,401,5,52,0,0,401,402,3,56,28,0,402,403,5,53,0,0,403,410,1,0,0,0,404,
		405,5,52,0,0,405,406,3,56,28,0,406,407,5,42,0,0,407,408,5,53,0,0,408,410,
		1,0,0,0,409,399,1,0,0,0,409,400,1,0,0,0,409,404,1,0,0,0,410,59,1,0,0,0,
		411,412,6,30,-1,0,412,413,5,50,0,0,413,414,3,62,31,0,414,415,5,51,0,0,
		415,429,1,0,0,0,416,417,5,54,0,0,417,429,5,55,0,0,418,419,5,54,0,0,419,
		420,3,106,53,0,420,421,5,55,0,0,421,429,1,0,0,0,422,423,5,50,0,0,423,429,
		5,51,0,0,424,425,5,50,0,0,425,426,3,68,34,0,426,427,5,51,0,0,427,429,1,
		0,0,0,428,411,1,0,0,0,428,416,1,0,0,0,428,418,1,0,0,0,428,422,1,0,0,0,
		428,424,1,0,0,0,429,448,1,0,0,0,430,431,10,6,0,0,431,432,5,54,0,0,432,
		447,5,55,0,0,433,434,10,5,0,0,434,435,5,54,0,0,435,436,3,106,53,0,436,
		437,5,55,0,0,437,447,1,0,0,0,438,439,10,2,0,0,439,440,5,50,0,0,440,447,
		5,51,0,0,441,442,10,1,0,0,442,443,5,50,0,0,443,444,3,68,34,0,444,445,5,
		51,0,0,445,447,1,0,0,0,446,430,1,0,0,0,446,433,1,0,0,0,446,438,1,0,0,0,
		446,441,1,0,0,0,447,450,1,0,0,0,448,446,1,0,0,0,448,449,1,0,0,0,449,61,
		1,0,0,0,450,448,1,0,0,0,451,457,3,72,36,0,452,457,3,60,30,0,453,454,3,
		72,36,0,454,455,3,60,30,0,455,457,1,0,0,0,456,451,1,0,0,0,456,452,1,0,
		0,0,456,453,1,0,0,0,457,63,1,0,0,0,458,459,6,32,-1,0,459,460,5,74,0,0,
		460,466,1,0,0,0,461,462,10,1,0,0,462,463,5,42,0,0,463,465,5,74,0,0,464,
		461,1,0,0,0,465,468,1,0,0,0,466,464,1,0,0,0,466,467,1,0,0,0,467,65,1,0,
		0,0,468,466,1,0,0,0,469,470,3,98,49,0,470,471,3,76,38,0,471,477,1,0,0,
		0,472,473,3,98,49,0,473,474,3,62,31,0,474,477,1,0,0,0,475,477,3,98,49,
		0,476,469,1,0,0,0,476,472,1,0,0,0,476,475,1,0,0,0,477,67,1,0,0,0,478,479,
		6,34,-1,0,479,480,3,66,33,0,480,486,1,0,0,0,481,482,10,1,0,0,482,483,5,
		42,0,0,483,485,3,66,33,0,484,481,1,0,0,0,485,488,1,0,0,0,486,484,1,0,0,
		0,486,487,1,0,0,0,487,69,1,0,0,0,488,486,1,0,0,0,489,490,6,35,-1,0,490,
		491,5,10,0,0,491,496,1,0,0,0,492,493,10,1,0,0,493,495,5,10,0,0,494,492,
		1,0,0,0,495,498,1,0,0,0,496,494,1,0,0,0,496,497,1,0,0,0,497,71,1,0,0,0,
		498,496,1,0,0,0,499,509,5,46,0,0,500,501,5,46,0,0,501,509,3,70,35,0,502,
		503,5,46,0,0,503,509,3,72,36,0,504,505,5,46,0,0,505,506,3,70,35,0,506,
		507,3,72,36,0,507,509,1,0,0,0,508,499,1,0,0,0,508,500,1,0,0,0,508,502,
		1,0,0,0,508,504,1,0,0,0,509,73,1,0,0,0,510,511,6,37,-1,0,511,517,5,74,
		0,0,512,513,5,50,0,0,513,514,3,76,38,0,514,515,5,51,0,0,515,517,1,0,0,
		0,516,510,1,0,0,0,516,512,1,0,0,0,517,541,1,0,0,0,518,519,10,5,0,0,519,
		520,5,54,0,0,520,521,3,106,53,0,521,522,5,55,0,0,522,540,1,0,0,0,523,524,
		10,4,0,0,524,525,5,54,0,0,525,540,5,55,0,0,526,527,10,3,0,0,527,528,5,
		50,0,0,528,529,3,68,34,0,529,530,5,51,0,0,530,540,1,0,0,0,531,532,10,2,
		0,0,532,533,5,50,0,0,533,534,3,64,32,0,534,535,5,51,0,0,535,540,1,0,0,
		0,536,537,10,1,0,0,537,538,5,50,0,0,538,540,5,51,0,0,539,518,1,0,0,0,539,
		523,1,0,0,0,539,526,1,0,0,0,539,531,1,0,0,0,539,536,1,0,0,0,540,543,1,
		0,0,0,541,539,1,0,0,0,541,542,1,0,0,0,542,75,1,0,0,0,543,541,1,0,0,0,544,
		545,3,72,36,0,545,546,3,74,37,0,546,549,1,0,0,0,547,549,3,74,37,0,548,
		544,1,0,0,0,548,547,1,0,0,0,549,77,1,0,0,0,550,551,3,92,46,0,551,552,3,
		78,39,0,552,558,1,0,0,0,553,558,3,92,46,0,554,555,5,10,0,0,555,558,3,78,
		39,0,556,558,5,10,0,0,557,550,1,0,0,0,557,553,1,0,0,0,557,554,1,0,0,0,
		557,556,1,0,0,0,558,79,1,0,0,0,559,560,5,11,0,0,560,561,5,74,0,0,561,562,
		5,52,0,0,562,563,3,82,41,0,563,564,5,53,0,0,564,573,1,0,0,0,565,566,5,
		11,0,0,566,567,5,52,0,0,567,568,3,82,41,0,568,569,5,53,0,0,569,573,1,0,
		0,0,570,571,5,11,0,0,571,573,5,74,0,0,572,559,1,0,0,0,572,565,1,0,0,0,
		572,570,1,0,0,0,573,81,1,0,0,0,574,575,6,41,-1,0,575,576,3,84,42,0,576,
		581,1,0,0,0,577,578,10,1,0,0,578,580,3,84,42,0,579,577,1,0,0,0,580,583,
		1,0,0,0,581,579,1,0,0,0,581,582,1,0,0,0,582,83,1,0,0,0,583,581,1,0,0,0,
		584,585,3,78,39,0,585,586,3,86,43,0,586,587,5,41,0,0,587,85,1,0,0,0,588,
		589,6,43,-1,0,589,590,3,88,44,0,590,596,1,0,0,0,591,592,10,1,0,0,592,593,
		5,42,0,0,593,595,3,88,44,0,594,591,1,0,0,0,595,598,1,0,0,0,596,594,1,0,
		0,0,596,597,1,0,0,0,597,87,1,0,0,0,598,596,1,0,0,0,599,607,3,76,38,0,600,
		601,5,45,0,0,601,607,3,106,53,0,602,603,3,76,38,0,603,604,5,45,0,0,604,
		605,3,106,53,0,605,607,1,0,0,0,606,599,1,0,0,0,606,600,1,0,0,0,606,602,
		1,0,0,0,607,89,1,0,0,0,608,609,7,0,0,0,609,91,1,0,0,0,610,623,5,18,0,0,
		611,623,5,19,0,0,612,623,5,20,0,0,613,623,5,21,0,0,614,623,5,22,0,0,615,
		623,5,23,0,0,616,623,5,24,0,0,617,623,5,25,0,0,618,623,5,26,0,0,619,623,
		5,27,0,0,620,623,3,80,40,0,621,623,3,94,47,0,622,610,1,0,0,0,622,611,1,
		0,0,0,622,612,1,0,0,0,622,613,1,0,0,0,622,614,1,0,0,0,622,615,1,0,0,0,
		622,616,1,0,0,0,622,617,1,0,0,0,622,618,1,0,0,0,622,619,1,0,0,0,622,620,
		1,0,0,0,622,621,1,0,0,0,623,93,1,0,0,0,624,625,5,74,0,0,625,95,1,0,0,0,
		626,631,3,78,39,0,627,628,3,78,39,0,628,629,3,62,31,0,629,631,1,0,0,0,
		630,626,1,0,0,0,630,627,1,0,0,0,631,97,1,0,0,0,632,644,3,90,45,0,633,634,
		3,90,45,0,634,635,3,98,49,0,635,644,1,0,0,0,636,644,3,92,46,0,637,638,
		3,92,46,0,638,639,3,98,49,0,639,644,1,0,0,0,640,644,5,10,0,0,641,642,5,
		10,0,0,642,644,3,98,49,0,643,632,1,0,0,0,643,633,1,0,0,0,643,636,1,0,0,
		0,643,637,1,0,0,0,643,640,1,0,0,0,643,641,1,0,0,0,644,99,1,0,0,0,645,646,
		6,50,-1,0,646,647,3,102,51,0,647,653,1,0,0,0,648,649,10,1,0,0,649,650,
		5,42,0,0,650,652,3,102,51,0,651,648,1,0,0,0,652,655,1,0,0,0,653,651,1,
		0,0,0,653,654,1,0,0,0,654,101,1,0,0,0,655,653,1,0,0,0,656,662,3,76,38,
		0,657,658,3,76,38,0,658,659,5,43,0,0,659,660,3,58,29,0,660,662,1,0,0,0,
		661,656,1,0,0,0,661,657,1,0,0,0,662,103,1,0,0,0,663,664,3,98,49,0,664,
		665,5,41,0,0,665,671,1,0,0,0,666,667,3,98,49,0,667,668,3,100,50,0,668,
		669,5,41,0,0,669,671,1,0,0,0,670,663,1,0,0,0,670,666,1,0,0,0,671,105,1,
		0,0,0,672,673,3,114,57,0,673,107,1,0,0,0,674,675,6,54,-1,0,675,676,3,112,
		56,0,676,682,1,0,0,0,677,678,10,1,0,0,678,679,5,42,0,0,679,681,3,112,56,
		0,680,677,1,0,0,0,681,684,1,0,0,0,682,680,1,0,0,0,682,683,1,0,0,0,683,
		109,1,0,0,0,684,682,1,0,0,0,685,686,7,1,0,0,686,111,1,0,0,0,687,693,3,
		114,57,0,688,689,3,132,66,0,689,690,3,110,55,0,690,691,3,112,56,0,691,
		693,1,0,0,0,692,687,1,0,0,0,692,688,1,0,0,0,693,113,1,0,0,0,694,702,3,
		116,58,0,695,696,3,116,58,0,696,697,5,44,0,0,697,698,3,108,54,0,698,699,
		5,45,0,0,699,700,3,114,57,0,700,702,1,0,0,0,701,694,1,0,0,0,701,695,1,
		0,0,0,702,115,1,0,0,0,703,704,6,58,-1,0,704,705,3,118,59,0,705,711,1,0,
		0,0,706,707,10,1,0,0,707,708,5,63,0,0,708,710,3,118,59,0,709,706,1,0,0,
		0,710,713,1,0,0,0,711,709,1,0,0,0,711,712,1,0,0,0,712,117,1,0,0,0,713,
		711,1,0,0,0,714,715,6,59,-1,0,715,716,3,120,60,0,716,722,1,0,0,0,717,718,
		10,1,0,0,718,719,5,64,0,0,719,721,3,120,60,0,720,717,1,0,0,0,721,724,1,
		0,0,0,722,720,1,0,0,0,722,723,1,0,0,0,723,119,1,0,0,0,724,722,1,0,0,0,
		725,726,6,60,-1,0,726,727,3,122,61,0,727,736,1,0,0,0,728,729,10,2,0,0,
		729,730,5,66,0,0,730,735,3,122,61,0,731,732,10,1,0,0,732,733,5,65,0,0,
		733,735,3,122,61,0,734,728,1,0,0,0,734,731,1,0,0,0,735,738,1,0,0,0,736,
		734,1,0,0,0,736,737,1,0,0,0,737,121,1,0,0,0,738,736,1,0,0,0,739,740,6,
		61,-1,0,740,741,3,124,62,0,741,756,1,0,0,0,742,743,10,4,0,0,743,744,5,
		39,0,0,744,755,3,124,62,0,745,746,10,3,0,0,746,747,5,40,0,0,747,755,3,
		124,62,0,748,749,10,2,0,0,749,750,5,68,0,0,750,755,3,124,62,0,751,752,
		10,1,0,0,752,753,5,67,0,0,753,755,3,124,62,0,754,742,1,0,0,0,754,745,1,
		0,0,0,754,748,1,0,0,0,754,751,1,0,0,0,755,758,1,0,0,0,756,754,1,0,0,0,
		756,757,1,0,0,0,757,123,1,0,0,0,758,756,1,0,0,0,759,760,6,62,-1,0,760,
		761,3,126,63,0,761,770,1,0,0,0,762,763,10,2,0,0,763,764,5,48,0,0,764,769,
		3,126,63,0,765,766,10,1,0,0,766,767,5,49,0,0,767,769,3,126,63,0,768,762,
		1,0,0,0,768,765,1,0,0,0,769,772,1,0,0,0,770,768,1,0,0,0,770,771,1,0,0,
		0,771,125,1,0,0,0,772,770,1,0,0,0,773,774,6,63,-1,0,774,775,3,128,64,0,
		775,787,1,0,0,0,776,777,10,3,0,0,777,778,5,46,0,0,778,786,3,128,64,0,779,
		780,10,2,0,0,780,781,5,47,0,0,781,786,3,128,64,0,782,783,10,1,0,0,783,
		784,5,57,0,0,784,786,3,128,64,0,785,776,1,0,0,0,785,779,1,0,0,0,785,782,
		1,0,0,0,786,789,1,0,0,0,787,785,1,0,0,0,787,788,1,0,0,0,788,127,1,0,0,
		0,789,787,1,0,0,0,790,797,3,132,66,0,791,792,5,50,0,0,792,793,3,96,48,
		0,793,794,5,51,0,0,794,795,3,128,64,0,795,797,1,0,0,0,796,790,1,0,0,0,
		796,791,1,0,0,0,797,129,1,0,0,0,798,799,7,2,0,0,799,131,1,0,0,0,800,816,
		3,136,68,0,801,802,5,62,0,0,802,816,3,132,66,0,803,804,5,61,0,0,804,816,
		3,132,66,0,805,806,3,130,65,0,806,807,3,128,64,0,807,816,1,0,0,0,808,809,
		5,17,0,0,809,816,3,132,66,0,810,811,5,17,0,0,811,812,5,50,0,0,812,813,
		3,96,48,0,813,814,5,51,0,0,814,816,1,0,0,0,815,800,1,0,0,0,815,801,1,0,
		0,0,815,803,1,0,0,0,815,805,1,0,0,0,815,808,1,0,0,0,815,810,1,0,0,0,816,
		133,1,0,0,0,817,818,6,67,-1,0,818,819,3,112,56,0,819,825,1,0,0,0,820,821,
		10,1,0,0,821,822,5,42,0,0,822,824,3,112,56,0,823,820,1,0,0,0,824,827,1,
		0,0,0,825,823,1,0,0,0,825,826,1,0,0,0,826,135,1,0,0,0,827,825,1,0,0,0,
		828,829,6,68,-1,0,829,830,3,138,69,0,830,856,1,0,0,0,831,832,10,7,0,0,
		832,833,5,54,0,0,833,834,3,108,54,0,834,835,5,55,0,0,835,855,1,0,0,0,836,
		837,10,6,0,0,837,838,5,50,0,0,838,855,5,51,0,0,839,840,10,5,0,0,840,841,
		5,50,0,0,841,842,3,134,67,0,842,843,5,51,0,0,843,855,1,0,0,0,844,845,10,
		4,0,0,845,846,5,59,0,0,846,855,5,74,0,0,847,848,10,3,0,0,848,849,5,58,
		0,0,849,855,5,74,0,0,850,851,10,2,0,0,851,855,5,62,0,0,852,853,10,1,0,
		0,853,855,5,61,0,0,854,831,1,0,0,0,854,836,1,0,0,0,854,839,1,0,0,0,854,
		844,1,0,0,0,854,847,1,0,0,0,854,850,1,0,0,0,854,852,1,0,0,0,855,858,1,
		0,0,0,856,854,1,0,0,0,856,857,1,0,0,0,857,137,1,0,0,0,858,856,1,0,0,0,
		859,867,5,74,0,0,860,867,5,75,0,0,861,867,5,77,0,0,862,863,5,50,0,0,863,
		864,3,108,54,0,864,865,5,51,0,0,865,867,1,0,0,0,866,859,1,0,0,0,866,860,
		1,0,0,0,866,861,1,0,0,0,866,862,1,0,0,0,867,139,1,0,0,0,69,141,148,154,
		156,165,173,181,184,193,229,247,259,279,289,296,318,324,333,343,348,359,
		365,378,386,396,409,428,446,448,456,466,476,486,496,508,516,539,541,548,
		557,572,581,596,606,622,630,643,653,661,670,682,692,701,711,722,734,736,
		754,756,768,770,785,787,796,815,825,854,856,866
	};

	public static readonly ATN _ATN =
		new ATNDeserializer().Deserialize(_serializedATN);


}
} // namespace CGrammar
